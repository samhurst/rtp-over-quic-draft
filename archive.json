{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-11-28T00:18:19.038406+00:00",
  "repo": "mengelbart/rtp-over-quic-draft",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "SDP",
      "description": "",
      "color": "528EC7"
    },
    {
      "name": "NextDoc",
      "description": "Potential additions in a next-generation document",
      "color": "bfdadc"
    },
    {
      "name": "NextInterim",
      "description": "Targeting PR for next interim meeting",
      "color": "52B96A"
    },
    {
      "name": "NotJustRTP",
      "description": "Issue is not specific to RTP over QUIC",
      "color": "bfdadc"
    },
    {
      "name": "IETF118",
      "description": "Targeting PR at IETF 118",
      "color": "bfd4f2"
    },
    {
      "name": "Review outside AVTCORE needed",
      "description": "Issue relies on expertise outside WG core competence",
      "color": "5319e7"
    },
    {
      "name": "Not Yet",
      "description": "Text would depend on implementation/deployment experience",
      "color": "fbca04"
    },
    {
      "name": "external doc",
      "description": "Can likely be solved in another document",
      "color": "c2e0c6"
    },
    {
      "name": "Discussion required",
      "description": "Need to know what WG thinks before applying PR",
      "color": "1d76db"
    },
    {
      "name": "Current Focus",
      "description": "Authors working on this now/soon",
      "color": "d4c5f9"
    }
  ],
  "issues": [
    {
      "number": 11,
      "id": "I_kwDOFUmh7s5KFI8X",
      "title": "RTCP and delay based CC in QUIC",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/11",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Section 6.1](https://datatracker.ietf.org/doc/html/draft-engelbart-rtp-over-quic#section-6.1) currently says that QUIC MUST use a timestamp extension to implement a delay-based congestion controller. Technically, the timestamps could also be implemented in RTCP using [RFC 8888](https://www.rfc-editor.org/rfc/rfc8888.html), but that would mean, that the application has to give timestamps back to the QUIC layer via some API. I am not sure if this is useful or if it would, for example, suffer from timing problems given that the arrival timestamp feedback would pass through the application layer before reaching the congestion controller at the transport layer.\r\n\r\nMaybe the document should give some guidance on what to do if no QUIC ack timestamps are available, e.g., \"RTCP MAY be used as a replacement\" or \"RTCP SHOULD NOT be used and instead CC option 2 (Section 6.2) SHOULD be used\".\r\n\r\nSee also the Editor's note in Section 6.1",
      "createdAt": "2022-05-20T09:14:13Z",
      "updatedAt": "2022-09-12T13:46:36Z",
      "closedAt": "2022-09-12T13:46:36Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOFUmh7s5MlxXl",
      "title": "State what endpoints should do if the QUIC datagram extension is not enabled",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/13",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "question",
        "SDP",
        "NotJustRTP",
        "IETF118",
        "Current Focus"
      ],
      "body": "The RTP over QUIC puts a hard requirement on endpoints advertising their support for the QUIC datagram extension.\r\n\r\nIf endpoints use ALPN to select RTP over QUIC, but the QUIC transport parameters do not contain a `max_datagram_frame_size`, it is not clear what should happen. One approach would be to fail the connection at the point this is detected, such as rejcting the connection handshake. \r\n\r\nNot stating an expected way to handle this could lead to some interop problems.",
      "createdAt": "2022-06-26T16:29:35Z",
      "updatedAt": "2023-10-23T14:27:51Z",
      "closedAt": "2023-10-23T14:27:51Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Datagram support in the QUIC implementation is only required if RTP over QUIC datagrams is required. If datagrams are not supported, endpoints can still use QUIC streams. Would it be helpful to add something like \"endpoints MUST not use datagrams unless support was indicated via `max_datagram_frame_size` by both endpoints\"?",
          "createdAt": "2022-06-27T10:32:05Z",
          "updatedAt": "2022-06-27T10:32:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "So I might be misunderstanding (and if so, let me know) but I don't think that requirement quite captures what your goals would be. When your peer doesn't support receiving QUIC datagrams you *can't* send them by definition of QUIC.\r\n\r\nThe quandry RTP over QUIC has is offering two ways to carry application data with little guidance on how applications would use these features. For example, if the client *only* wants to send datagrams and the server doesn't state it supports the QUIC datagram extension, what happens?\r\n\r\nEqually and oppositely, imagine a client only wants to use streams, and the server only wants to receive datagrams - so provides zero credits for creating streams. What happens?\r\n\r\nYou suggest QUIC streams can be used as a fallback from datagrams, but I think that highlights a design assumption in the specification, which could benefit from being made explicit. I'm not sure everybody is on board with that design if it isn't written down.\r\n\r\nSince you have two ways to carry data, and those capabilities are advertised unilaterally, you have a matrix of combinations. You might want to think about codifying these, so that applications can communicate their intent early. For instance, defining an RTP-over-QUIC transport parameter or a few ALPNs, to help negotiate the capabilities at the start.",
          "createdAt": "2022-06-27T10:47:00Z",
          "updatedAt": "2022-06-27T10:47:00Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think I misunderstood the issue. You're right, my suggestion doesn't make much sense, since using datagrams is already impossible when it is not supported.\r\n\r\nMaybe our assumption is, that since peers have to negotiate the session out of band, we expect them to negotiate only what their QUIC implementations support and then adhere to what they negotiated. But that probably doesn't really prevent the situations you describe.\r\n\r\nI think we might want to add some explanation about what we expect from the external signalling and then also add a transport parameter or different ALPNs as you suggested.\r\n\r\nI am thinking about how to implement this in the draft, but I am not (yet) sure if I understand all the implications. For example, the situation you describe, where a server provides zero credits for streams, wouldn't that still be possible, even with the correct signalling and is there anything we could do about it?",
          "createdAt": "2022-07-01T11:50:41Z",
          "updatedAt": "2022-07-01T11:50:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm not an RTP expert so take my comments with a pinch of salt. But any time I hear that a signalling mechanism puts some expectations on a loosely coupled transport, I get a bit nervy. This is primarily because applications don't always have as tight a coupling (or control) over their transport layer as they think they might like. HTTP/3 has a bit of this now, where multi-cloud or multi-CDN deployments can invalidate prior advertisements.\r\n\r\nDesigning some robustness into handling mismatches can help spot them earlier. Transport parameters or ALPNs have different tradeoffs. I wouldn't rush into picking one without understanding your problem space. So this issue might need some time to mature.\r\n\r\nYou're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance. ",
          "createdAt": "2022-07-02T23:55:33Z",
          "updatedAt": "2022-07-02T23:55:33Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion with @joerg-ott and @mengelbart, I think this comment from @LPardue is an excellent place to start ... \r\n\r\n> You're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance.\r\n\r\nWhat I'm thinking, is that we can reasonably say \r\n1. If both sides don't support datagrams/provides zero credits for datagrams, you won't be using datagrams (duh), \r\n2. So you're going to be using streams, and we can make suggestions that will help this \"suck less\". \r\n\r\nI can propose text for this, at least as a starting point. I'm not tagging the issue as a pre-IETF 116 priority for now. \r\n\r\nDoes that all make sense?",
          "createdAt": "2023-01-13T16:43:02Z",
          "updatedAt": "2023-01-13T16:46:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue #76 adding error codes will help with this one. ",
          "createdAt": "2023-05-17T16:37:15Z",
          "updatedAt": "2023-05-17T16:37:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Error codes were added in #91, including an [explanation for handling the absence of datagram support](https://github.com/mengelbart/rtp-over-quic-draft/pull/91/files#diff-88df85545ee4dd07f1027eb4174149926d2df360b5dff6dd0c8f80dd802b2e26R631).\r\n\r\nThere will be more changes to the IANA considerations for error codes (#140), but I suggest we close this issue already. We still have #76 tracking the error codes more generally.",
          "createdAt": "2023-10-11T12:52:31Z",
          "updatedAt": "2023-10-11T12:52:31Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @LPardue - so, the text [for handling the absence of datagram support](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-quic-datagrams), first paragraph: \r\n\r\n> Senders can also transmit RTP packets in QUIC datagrams. QUIC datagrams are an extension to QUIC described in [RFC9221]. QUIC datagrams can only be used if the use of the extension was successfully negotiated during the QUIC handshake. **If the use of an extension was signaled using a signaling protocol, but the extension was not negotiated during the QUIC handshake, a peer MAY close the connection with the ROQ_EXPECTATION_UNMET error code.**\r\n\r\nhandles the case where I told you (via signaling) that I will be sending you QUIC datagrams, but when we do our QUIC handshake, for whatever reason, we fail to negotiate the datagram extension. \r\n\r\nI chatted with several MoQ folks during the Hackathon at IETF 117, and the consensus was that \r\n\r\n- people know what an implementation should do when the implementation receives a frame type it has never seen or heard of before (\"a grommet frame\") - return a connection error of type FRAME_ENCODING_ERROR , as described in [Section 12.4 of RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-frames-and-frame-types), but \r\n- people don't agree on what implementations should do when the implementation receives a frame type that it understands, **except** that the frame type is defined for a QUIC extension that has not been negotiated (\"a datagram frame\") - some implementations treat the known but unnegotiated frame **as if it were unknown**, and other implementations might do \"something else\". \r\n\r\nSo, my question here, is - is it helpful for us to say anything about this inconsistency in RoQ, or should I be doing something else?\r\n\r\nOne possibility would be a short draft targeted at the QUIC WG, updating RFC 9000, that at least explains the issue, and could reasonably caution application developers about the possibility that an implementation might surprise them, but I'm sure there are other, possibly smarter, possibilities. ",
          "createdAt": "2023-10-18T20:12:34Z",
          "updatedAt": "2023-10-18T20:12:34Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "A LONG time ago, @LPardue said (above), \r\n\r\n> You're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance.\r\n\r\nThat's gotten a bit lost, up until now, and it doesn't have anything to do with datagrams, so I'll create a separate issue for it. (#142 ) \r\n\r\n",
          "createdAt": "2023-10-18T20:28:17Z",
          "updatedAt": "2023-10-18T20:44:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> people don't agree on what implementations should do when the implementation receives a frame type that it understands, except that the frame type is defined for a QUIC extension that has not been negotiated (\"a datagram frame\") - some implementations treat the known but unnegotiated frame as if it were unknown, and other implementations might do \"something else\".\r\n\r\nI think [RFC 9221](https://www.rfc-editor.org/rfc/rfc9221.html#name-transport-parameter) is quite clear about this:\r\n\r\n> An endpoint that receives a DATAGRAM frame when it has not indicated support via the transport parameter MUST terminate the connection with an error of type PROTOCOL_VIOLATION.\r\n\r\nI don't know if it is an issue that the error codes are different. One could possibly use this to learn about the implementation of the other endpoint: If you get a PROTOCOL_VIOLATION, the endpoint seems to be using an implementation that supports the datagram extension. If you get a FRAME_ENCODING_ERROR, the implementation does not seem to know datagrams. But I don't think RoQ is the right place to discuss this.",
          "createdAt": "2023-10-19T07:20:22Z",
          "updatedAt": "2023-10-19T07:20:22Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOFUmh7s5Mlx2F",
      "title": "What stream types are used?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/14",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "QUIC provides 4 stream types, the spec seems to overlook stating if there are any requirements on the use of these streams. An application needs to know the right type to pick for interop.\r\n\r\nIn the simplest case, I can imagine that a single RTP packet is sent on a unidirectional stream, which is then closed. But perhaps you picture a bidirectional stream being used to exchange a pair of packets?",
      "createdAt": "2022-06-26T16:37:40Z",
      "updatedAt": "2022-09-23T07:18:16Z",
      "closedAt": "2022-09-23T07:18:16Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree, we should clarify that in the spec. I also realized that we don't state explicitly, that a stream MUST be closed immediately after the RTP packet is completely sent, otherwise streams don't work as implicit framing. I think we just assumed unidirectional streams because we expect senders to close streams after sending a packet. I think technically it might be possible to use bidirectional streams, too, but since there is no synchronous relationship between sent and received RTP/RTCP packets, it is probably easier to use unidirectional streams.\r\n\r\nI just opened #17 for this.",
          "createdAt": "2022-06-27T13:49:56Z",
          "updatedAt": "2022-06-27T13:49:56Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOFUmh7s5Mlx9R",
      "title": "Missing considerations about stream concurrecy",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/15",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When RTP packets are sent on streams, the spec only allows one packet per stream send side. This immediately limits the number of concurrent packets to be bound by the number of concurrent streams. \r\n\r\nI don't know which stream types you picture using (see #14) but that is tangential. Whatever types are used, the spec should give some consideration to the minumum and maximum number of concurrent streams for RTP over QUIC. Applications that fail to provide enough concurrency credit can cause deadlocks or timeouts.",
      "createdAt": "2022-06-26T16:39:53Z",
      "updatedAt": "2022-10-24T14:28:42Z",
      "closedAt": "2022-10-24T14:28:42Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOFUmh7s5MlyFM",
      "title": "Does RTP over datagram retransmission happen on the same flow ID?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/16",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See https://www.ietf.org/archive/id/draft-engelbart-rtp-over-quic-04.html#section-6.2\r\n\r\nIt would seem to be sensible to recommend retransmitting the RTP packet on the same datagram flow ID but I'm not an expert on RTP stuff.",
      "createdAt": "2022-06-26T16:42:12Z",
      "updatedAt": "2022-09-12T13:54:24Z",
      "closedAt": "2022-09-12T13:54:24Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think it would depend on how the RTP implementation is doing retransmissions. RFC 4588 allows retransmissions either in the same session with a different SSRC or in a separate session. If different flow IDs are required for different sessions, as is the case in the current draft, then that would also be the case for retransmissions in different sessions, but not for retransmissions that happen in the same session.",
          "createdAt": "2022-06-27T10:55:58Z",
          "updatedAt": "2022-06-27T10:55:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "That sounds reasonable. Since it sounds like there are some implementation decisions to make, It might be helpful to note that this type of retransmission behaviour is possible, and what the implications are for both stream-based or datagram-based retransmissions. ",
          "createdAt": "2022-06-27T11:07:40Z",
          "updatedAt": "2022-06-27T11:07:40Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOFUmh7s5PDxu-",
      "title": "Section 8: Bandwidth sharing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/20",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"*TODO:* Add considerations for bandwidth shares when a QUIC connection is shared between RTP and non-RTP streams?\"",
      "createdAt": "2022-08-02T20:54:03Z",
      "updatedAt": "2022-09-12T13:45:29Z",
      "closedAt": "2022-09-12T13:45:29Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This was done by adding [section 8.3](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#name-shared-quic-connections) but I forgot to remove the TODO. I will create a PR.",
          "createdAt": "2022-08-03T07:46:57Z",
          "updatedAt": "2022-08-03T07:46:57Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOFUmh7s5PDzWj",
      "title": "Section 8.1: Congestion control recommendations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/21",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"  If congestion control is to be applied at the transport layer, it is\r\n   RECOMMENDED to configure the QUIC Implementation to use a delay-based\r\n   real-time congestion control algorithm instead of a loss-based\r\n   algorithm.  The currently available delay-based congestion control\r\n   algorithms depend on detailed arrival time feedback to estimate the\r\n   current one-way delay between sender and receiver. \"\r\n\r\n[BA] Can we make this a bit more specific? \r\n\r\n1. By \"delay-based congestion control algorithms\" are you referring to the algorithms mentioned in RFC 8888 Section 1?\r\n2. Would BBRv2 qualify?\r\n3. Mac OS X 16 includes support for L4S and scalable congestion control.  Would this qualify? \r\nSee: https://developer.apple.com/videos/play/wwdc2022/10078/\r\n\r\n",
      "createdAt": "2022-08-02T21:02:07Z",
      "updatedAt": "2022-10-24T14:41:47Z",
      "closedAt": "2022-10-24T14:41:47Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> [BA] Can we make this a bit more specific?\r\n> \r\n>     1. By \"delay-based congestion control algorithms\" are you referring to the algorithms mentioned in RFC 8888 Section 1?\r\n\r\nI think that was the intention when we wrote this paragraph. When thinking about this again now, I think it may be better to express this recommendation by explaining the application's requirements rather than by the congestion signals used by the employed algorithm or even listing specific ones. If we do that, it would also make sense to relax the following sentences:\r\n\r\n> The currently available delay-based congestion control algorithms depend on detailed arrival time feedback to estimate the current one-way delay between sender and receiver. Since QUIC does not provide arrival timestamps in its acknowledgments, the QUIC implementations of the sender and receiver MUST use an extension to add this information to QUICs acknowledgment frames\"\r\n\r\nIf we don't specify how the algorithms should work internally, it also doesn't make sense to require the use of a timestamp extension to provide one-way delay measurements.\r\n\r\n>     2. Would BBRv2 qualify?\r\n> \r\n>     3. Mac OS X 16 includes support for L4S and scalable congestion control.  Would this qualify?\r\n>        See: https://developer.apple.com/videos/play/wwdc2022/10078/\r\n\r\nWould it be specific enough to express a need for a congestion controller that ensures that RTP/RTCP packets are transmitted at low latencies? I think that would exclude loss-based algorithms and may exclude BBRv1 due to probing. I don't know if BBRv2 would qualify and I think L4S would.",
          "createdAt": "2022-08-03T08:48:17Z",
          "updatedAt": "2022-08-03T08:49:12Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I like the idea of specifying the general requirement (e.g. low-latency).  Separately, it would be worth understanding whether QUIC cc algorithms meet that requirement (e.g. whether BBRv2 is usable or not, whether iOS 16 L4S is helpful, etc.). ",
          "createdAt": "2022-08-03T14:35:59Z",
          "updatedAt": "2022-08-03T14:35:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened #36. I agree that it would be worth understanding which algorithms meet the requirement, but since I can currently not answer that for algorithms like BBRv2 or L4S, I don't want to put my assumptions in the document.",
          "createdAt": "2022-09-12T15:43:59Z",
          "updatedAt": "2022-09-12T15:43:59Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOFUmh7s5PD1SK",
      "title": "Section 8.1: QUIC connection sharing with non-RTP streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/22",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's note:* How can a QUIC connection be shared with non-RTP\r\n      streams, when SCReAM/NADA/GCC is used as congestion controller?\r\n      Can these algorithms be adapted to allow different streams\r\n      including non-real-time streams?  Do they even have to be adapted\r\n      or _should_ this just work?\r\n\r\n[BA] When a file is being transferred within an audio/video chat session, it is typically desired for the file transfer not to interfere with media. To accomplish this, the file transfer is subjected to the same low-latency cc algorithm and also, the bandwidth allocated to the transfer may be restricted. Subjecting the transfer to unified congestion control means that it will take longer that it would if it were on a separate connection competing with the A/V traffic, but that's the desired outcome.",
      "createdAt": "2022-08-02T21:11:41Z",
      "updatedAt": "2022-09-12T13:51:07Z",
      "closedAt": "2022-09-12T13:51:06Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "That makes sense, I think we can delete the note.",
          "createdAt": "2022-08-04T17:06:09Z",
          "updatedAt": "2022-08-04T17:06:09Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOFUmh7s5PD1jA",
      "title": "Section 8.1: Timestamp extension requirement",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/23",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's note:* An alternative to the hard requirement to use a\r\n      timestamp extension could be to use RTCP, but that would mean,\r\n      that an application has to negotiate RTCP congestion control\r\n      feedback which would then have to be passed to the QUIC congestion\r\n      controller.",
      "createdAt": "2022-08-02T21:13:06Z",
      "updatedAt": "2022-09-12T13:46:36Z",
      "closedAt": "2022-09-12T13:46:36Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "See also #11 \r\n\r\n[Section 7](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#name-rtcp) explains in detail how information from the QUIC layer can be used to replace RTCP. This is the opposite: we want to use information from RTCP at the QUIC layer. I don't think is useful to add text for this to the document for the following reasons:\r\n\r\n- The QUIC congestion controller would depend on the information that is only present at the application layer. If we want to use RTCP (e.g., because timestamps are not available), we can still have congestion control at the application layer as explained in [section 8.2](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-8.2). If there's no API to disable/manage the QUIC congestion controller, there will likely be no API to pass feedback to it either.\r\n- It would be unclear how the QUIC congestion controller should treat non-RTP data for which we still don't have arrival times.\r\n\r\nShould we add an explanation for these problems or just delete the note?",
          "createdAt": "2022-08-03T09:04:36Z",
          "updatedAt": "2022-08-03T09:04:36Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I'd delete the note. ",
          "createdAt": "2022-08-03T14:20:15Z",
          "updatedAt": "2022-08-03T14:20:15Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOFUmh7s5PD41X",
      "title": "Section 6: Multiplexing of non-RTP/RTCP data streams and datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/24",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "\"  For multiplexing different RTP and other data streams on the same\r\n   QUIC connection, each RTP/RTCP packet is prefixed with a flow\r\n   identifier.  A flow identifier is a QUIC variable-length integer\r\n   which must be unique per stream...\r\n\r\n   Differentiating RTP/RTCP packets of different RTP sessions from non-\r\n   RTP/RTCP datagrams is the responsibility of the application by means\r\n   of appropriate use of flow identifiers and the corresponding\r\n   signaling.\"\r\n\r\n[BA] This text is a bit vague with respect to setup of non-RTP/RTCP data streams and datagrams.\r\n\r\nAs an example, in WebRTC it is possible to [create additional data channels without signaling](https://w3c.github.io/webrtc-pc/#rtcdatachannel). \r\n\r\nHow would equivalent functionality be supported in RTP over QUIC? For example, one might assume that the desire to exchange data is negotiated, but once done, that a non-RTP/RTCP data stream or datagrams could then be received.  How are these non-RTP/RTCP data streams or datagrams distinguished from RTP/RTCP?  Do we examine the first octet as per RFC 7983bis or is some other multiplexing mechanism used? ",
      "createdAt": "2022-08-02T21:30:21Z",
      "updatedAt": "2023-01-18T16:22:10Z",
      "closedAt": "2023-01-18T16:22:09Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Initially, the idea was to require the flow identifier in every datagram sent on the QUIC connection, allowing the receiver to demultiplex based on the flow identifier. However, that may require some signaling to map flow identifiers to protocols, and as you rightly point out, it may be desired to open new channels without additional signaling, and the flow identifier could also conflict with other protocol mappings to QUIC streams/datagrams.\r\n\r\nI think this is also related to #31. Depending on what ALPN we define in this document and which combinations of protocols this ALPN includes, we may have different multiplexing requirements.\r\n\r\nThe easiest case would probably be an ALPN like \"rtp-quic\" that identifies RTP over QUIC without multiplexing additional non-RTP/RTCP protocols. In that case, we could rely on traditional multiplexing mechanisms for RTP/RTCP, such as RFC 5761 for multiplexing RTP and RTCP or RFC 8860 for sending multiple types of media in a single RTP session. However, I think both RFCs have some limitations that a flow identifier could potentially solve at the cost of some bytes.\r\n\r\nMultiplexing RTP/RTCP and other protocols will be more complicated. One solution could be RFC 7983bis. RFC 7983bis may not work if RTP/RTCP packets are prepended with a flow identifier, which may be solved by prepending the flow identifier with another byte that takes a value that does not yet match any other protocol in RFC 7983bis. But I am not sure if RFC 7983bis is what we need here, given that something like data channels could run directly in QUIC and would not necessarily need to be encapsulated in SCTP/DTLS over QUIC.\r\n\r\nIf we leave multiplexing of multiple protocols to future documents with a separate ALPN in #31, we could also leave the specifics of how the multiplexing works to those documents. In that case, it might be valuable to add a *Multiplexing Guidelines* section to this document.",
          "createdAt": "2022-09-19T14:39:56Z",
          "updatedAt": "2022-09-19T14:39:56Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Resolved in #54 ",
          "createdAt": "2023-01-18T16:22:09Z",
          "updatedAt": "2023-01-18T16:22:09Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOFUmh7s5PD5ch",
      "title": "Section 6.1: RTP topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/25",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's Note:* Note, however, that using a single frame per\r\n      stream in a single RTP packet may cause interworking issues when a\r\n      translator wants to forward packets received via RTP-over-QUIC to\r\n      an endpoint as UDP packets because the received ADUs may exceed\r\n      the MTU size or even maximum UDP packet size.\r\n\r\n[BA] This (and other aspects, such as lack of multicast support) has implications for the [supportable RTP topologies](https://datatracker.ietf.org/doc/html/rfc7667). There is also the issue of RTCP interworking. Are there specific topologies that are not supported for use with RTP over QUIC? ",
      "createdAt": "2022-08-02T21:33:54Z",
      "updatedAt": "2022-10-24T15:26:29Z",
      "closedAt": "2022-10-24T15:26:29Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The introduction currently limits RTP over QUIC to unicast topologies:\r\n\r\n> The scope of this document is limited to unicast RTP/RTCP.\r\n\r\nWe may need to re-evaluate multicast topologies if [QUIC multicast](https://datatracker.ietf.org/doc/draft-jholland-quic-multicast/) becomes available.\r\n\r\nI think most of the non-multicast topologies should be supportable with a few constraints. Whenever a middlebox like a translator needs access to the RTP packet, the QUIC connection must be terminated at the middlebox. I think RTP over QUIC can also support the case described in the note if the translator can rewrite the RTP packets to smaller ones.\r\n\r\nShould we add a new section to explain these limitations?",
          "createdAt": "2022-09-20T08:13:18Z",
          "updatedAt": "2022-09-20T08:13:18Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Adding a section to explain the limitations would make sense. \r\n\r\nHaving a middlebox packetizing frames is complex, because RTP packetization is codec-specific.  Some MANEs do this today (e.g. in order to adjust to MTU differences), but typically those MANEs only support a single codec. ",
          "createdAt": "2022-09-20T18:56:41Z",
          "updatedAt": "2022-09-20T18:56:41Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOFUmh7s5PD7AB",
      "title": "Section 9.2: Disabling QUIC Congestion Control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/26",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "   *  _Disable Congestion Controller_: If congestion control is to be\r\n      implemented at the application layer as described in Section 8.2,\r\n      and the application layer is trusted to apply adequate congestion\r\n      control, it is RECOMMENDED to allow the application to disable QUIC\r\n      layer congestion control entirely.\r\n\r\n[BA] In terms of the overall requirements, you might cite RFC 9002 Section 7, which says: \r\n\r\n\"If a sender uses a different controller than that specified in this\r\n   document, the chosen controller MUST conform to the congestion\r\n   control guidelines specified in [Section 3.1 of [RFC8085]](https://datatracker.ietf.org/doc/html/rfc8085#section-3.1).\"",
      "createdAt": "2022-08-02T21:42:31Z",
      "updatedAt": "2022-09-23T07:19:09Z",
      "closedAt": "2022-09-23T07:19:09Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOFUmh7s5PD77e",
      "title": "Section 9.2: Choosing an appropriate congestion control algorithm",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/27",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"   *  _Select Congestion Controller_: If congestion control is to be\r\n      implemented at the QUIC connection layer as described in\r\n      Section 8.1, the application must be able to choose an appropriate\r\n      congestion control algorithm.\"\r\n\r\n[BA] Is the need to choose an appropriate algorithm, or to be able to provide information on what characteristics are desired? \r\nRelated: https://github.com/w3c/webtransport/issues/365",
      "createdAt": "2022-08-02T21:47:52Z",
      "updatedAt": "2022-10-24T15:00:35Z",
      "closedAt": "2022-10-24T15:00:35Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "If we decide to state the characteristics in section 8.1 instead of specific algorithms, as discussed in #21 and #36, I think we can leave it to the implementation to decide what the concrete API should look like. I think some QUIC implementations allow choosing between algorithms, but I could also imagine an implementation that lets the application provide information that the QUIC implementation can use to make a decision. Maybe we can change the wording to something like this:\r\n\r\n```\r\nIf congestion control is to be implemented at the QUIC connection (layer as\r\ndescribed in Section 8.1), the QUIC implementation SHOULD expose an API to\r\nconfigure the congestion control algorithm.\r\n```",
          "createdAt": "2022-09-12T16:10:54Z",
          "updatedAt": "2022-09-12T16:10:54Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "In WebTransport, the approach taken has been to provide a \"hint\" to the QUIC stack which would allow it to select an appropriate congestion control algorithm.  There is no implementation of this yet.  That approach was selected over more detailed configuration of the congestion control algorithm. ",
          "createdAt": "2022-09-20T18:52:31Z",
          "updatedAt": "2022-09-20T18:52:31Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think that makes sense for WebTransport, but I am not sure we need to be specific about this here. For example, a QUIC implementation that only offers a low latency congestion controller would be fine, even if it does not provide any configuration options to the application. It may be more useful not to phrase this as what the application can control, but rather as how the QUIC implementation must do congestion control.",
          "createdAt": "2022-09-29T10:44:11Z",
          "updatedAt": "2022-09-29T10:44:11Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOFUmh7s5PImlZ",
      "title": "SFrame/SPacket",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/29",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question",
        "wontfix",
        "NotJustRTP",
        "external doc"
      ],
      "body": "The spec does not currently describe how [SFrame](https://datatracker.ietf.org/doc/draft-ietf-sframe-enc/) is supported in RTP over QUIC, or what an RTP translator should do. One way to address this would be to add a section that would deal with the issues that come up when implementing [SFrame](https://datatracker.ietf.org/doc/draft-ietf-sframe-enc/) in RTP over QUIC.",
      "createdAt": "2022-08-03T18:56:51Z",
      "updatedAt": "2023-10-16T14:37:33Z",
      "closedAt": "2023-10-16T14:37:33Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I may be missing some background on SFrame/SPacket, but as far as I understand the document you linked, SFrame tries to be independent of the underlying transport, so I don't understand why the RTP over QUIC document should cover its usage. Could you explain why SFrame should only be used with QUIC streams and SPacket only in QUIC datagrams?",
          "createdAt": "2022-09-19T10:41:40Z",
          "updatedAt": "2022-09-19T10:41:40Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "SFrame encrypts an entire frame, making it opaque.\r\n\r\nThis creates problems for an RTP translator.  Since the RTP translator cannot know what is inside the SFrame (since it typically will not have access to the encryption key), it cannot re-packetize the SFrame in a codec-specific way.  This problem can arise if the SFrame is transported using RTP over a reliable QUIC stream and it is desired to translate to RTP over UDP.",
          "createdAt": "2022-09-20T18:48:53Z",
          "updatedAt": "2022-11-07T01:28:30Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> if the SFrame doesn't need to be packetized (e.g. it is put into a QUIC stream) this is not an issue.\r\n\r\nThe frame would still be packetized in RTP packets in both QUIC datagrams and streams. The RTP packet size in a QUIC stream may be much larger (containing the entire frame instead of just one fragment), and each stream can only be used for one RTP packet.\r\n\r\nIf I understand it correctly, RTP over QUIC (Datagrams and Streams) would have the same support (and issues) for SFrame/SPacket as RTP over UDP?",
          "createdAt": "2022-09-21T11:37:55Z",
          "updatedAt": "2022-09-21T11:37:55Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are issues with the implementation of RTP translation between RTP over QUIC and RTP/UDP, regardless of whether RTP over QUIC uses QUIC reliable streams or datagrams: \r\n\r\n1. When RTP over QUIC is transported in a QUIC reliable stream, the MTU size is much larger than the RTP over UDP MTU.  So the RTP/QUIC payload needs to be re-packetized to be sent over RTP/UDP. \r\n\r\n2. When RTP/UDP is translated to RTP over QUIC datagrams, there can also be a re-packetization issue. If the UDP MTU is larger than the QUIC datagram MTU, then re-packetization would be required or else oversize RTP over QUIC datagrams would be fragmented. \r\n\r\nSFrame complicates these issues further since the RTP payloads are opaque, and are thus not amenable to codec-specific re-packetization. ",
          "createdAt": "2022-11-07T01:33:25Z",
          "updatedAt": "2022-11-07T01:34:43Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Related: https://github.com/pthatcher/sframe-over-rtp-over-quic-draft/blob/main/draft-pthatcher-sframe-over-rtp-over-quic.txt",
          "createdAt": "2022-11-07T01:38:12Z",
          "updatedAt": "2022-11-07T01:38:12Z"
        },
        {
          "author": "pthatcher",
          "authorAssociation": "NONE",
          "body": "I tried to explain the issue in the draft I wrote to solve this. \r\n\r\nThe gist is that the problem is when a translator has larger RTP packets on one side smaller RTP packets on the other.   QUIC streams allow for very large RTP packets, and the translator has to deal with that.  The RTP-over-QUIC document says that the solution is to use \"codec-specific packetization\", but when SFrame encrypts the codec, it effectively becomes the codec, so you need, basically, an SFrame-specific way to repacketize a large RTP packet containing SFrame into smaller RTP packets containing SFrame.   SPacket doesn't help because we're talking about large RTP packets, and SPackets will still have the same problem.  \r\n\r\nSo what I wrote in the draft Bernard just linked to is a mechanism to repacketize a large RTP packet containing SFrame (or SPacket; that works too) into smaller RTP packets containing SFrame (or SPacket).\r\n\r\nIt also discusses and supports the other direction: turning many smaller RTP packets back into one large RTP packet (translating the other way).",
          "createdAt": "2022-11-07T14:43:17Z",
          "updatedAt": "2022-11-07T14:43:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @pthatcher, @mengelbart and I think this question is being handled as generic for RTP, not for RTP-over-QUIC, and the relevant Githubs (draft-pthatcher-sframe-over-rtp-over-quic and draft-codec-agnostic-rtp-payload-format) are where this will be worked out. Is that also your understanding? ",
          "createdAt": "2023-03-09T16:42:28Z",
          "updatedAt": "2023-03-09T16:42:28Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @SpencerDawkins have reflected on this issue several times, and we are thinking \r\n\r\n- there's not much we can say in the RoQ draft that is specific to RoQ - whatever one does with RTP in SFrames would be the same with RTP over QUIC in SFrames\r\n- we would love to be able to repacketize SFrames (especially if there is a problem with PMTU size), but that's not RoQ-specific, either\r\n- RoQ does include a length field, so that an endpoint can do something about that, if it needs to. \r\n\r\nWe're happy to listen to reason, and closed issues can be reopened in GitHub, but we're closing this one, for now. ",
          "createdAt": "2023-10-16T14:37:06Z",
          "updatedAt": "2023-10-16T14:37:06Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOFUmh7s5PLdfS",
      "title": "ALPN for sharing a connection between RTP/RTCP and other protocols",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/31",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "SDP",
        "IETF116"
      ],
      "body": "One of the advantages of RTP over QUIC is the possibility to multiplex different protocols on the same connection. A simple use case for this is to share a single QUIC connection between a media session using RTP and some non-RTP data transfer, similar to WebRTC Data Channels. *draft-ietf-avtcore-rtp-over-quic* specifies a minimal application usage of QUIC for RTP. The draft defines an ALPN token (\u201crtp-mux-quic\u201d) because QUIC requires the usage of a mechanism to agree on an application layer protocol, and ALPN is the currently specified way of doing this using TLS. Other application usages of QUIC will have to define their own ALPN token, which implies that they must use a different QUIC connection from RTP over QUIC.\r\n\r\nWe currently see two possible ways to allow usage of RTP and other protocols multiplexed on the same QUIC connection:\r\n\r\n* Define a generic ALPN (e.g. \u201crtp-mux-sdp\u201d), which indicates that the application protocols to be carried in this connection are to be negotiated out of band (SDP). The problem with this approach is that we cannot define the actual multiplexing of the two protocols.\r\n* Explicitly state in the RTP over QUIC draft that future documents are allowed to define new ALPNs that identify protocols for multiplexing RTP over QUIC with other protocols. For example, an ALPN \u201crtp-mux-h3\u201d could be defined in a document that defines how RTP and HTTP/3 can be multiplexed in one QUIC connection. This document could reference the RTP over QUIC document but would have to explain how to multiplex the different protocols.\r\n\r\nOf course, these two options are not mutually exclusive.",
      "createdAt": "2022-08-04T10:20:26Z",
      "updatedAt": "2023-01-18T16:24:02Z",
      "closedAt": "2023-01-18T16:24:01Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "For an example of how this can be handled, see [RFC 8833](https://www.rfc-editor.org/rfc/rfc8833.html), which defines the ALPN registration for WebRTC.  The document defines two ALPNs, each of which supports multiplexing of both data and media. At no point does the document mention SDP. Looking at that document, something simple like \"rtp-mux-quic\" might be fine.\r\n\r\nMultiplexing of RTP-over-QUIC and HTTP/3 would be quite a complex exercise, because this would pull in interactions with HTTP/3 pooling, where multiple applications can interact.  As you've noted, RTP-over-QUIC has unique congestion control requirements which QUIC implementations used with HTTP/3 might not comply with (e.g. BBRv1). ",
          "createdAt": "2022-08-05T18:35:06Z",
          "updatedAt": "2022-08-05T18:35:06Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think RFC 8833 would be an example of the second option, where a separate document defines an ALPN for multiplexing two protocols. I agree HTTP/3 might be very complex and there are better examples that may be easier to define and possibly more useful. I assume we still need an ALPN in the RTP over QUIC document (e.g., \"rtp-quic\"), that can be used to exclusively send RTP and some other document could define an ALPN \"rtp-mux-quic\", for multiplexing RTP and something like data channels.",
          "createdAt": "2022-08-06T22:05:34Z",
          "updatedAt": "2022-08-06T22:05:34Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Not sure you'd need multiple ALPNs here. As an example, applications using WebTransport do not need a separate ALPN for each use case.  Similarly, WebRTC was able to use a single ALPN for both data and media by leveraging RFC 7983. ",
          "createdAt": "2022-09-20T18:40:52Z",
          "updatedAt": "2022-09-20T18:40:52Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think leveraging RFC 7983bis could work, but I am not sure it is what we need. WebRTC uses DTLS/SCTP for data, both of which *I think* we do not need on top of QUIC. But that leaves the question of what protocol will be used on top of QUIC to carry data instead. That's why I thought we could just define one ALPN (\"rtp-quic\") now and maybe later add one or more ALPNs for multiplexing RTP/RTCP and some other (data) protocols on top of QUIC. We could then also define the actual multiplexing similar to RFC 7983.\r\n\r\nI don't think we want to assign an ALPN now that allows multiplexing RTP/RTCP and any other unspecified protocol in the future because it would be unclear how to do the multiplexing.",
          "createdAt": "2022-09-21T08:44:12Z",
          "updatedAt": "2022-09-21T08:44:12Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "#54 solves the multiplexing issue using flow identifiers, which works with the ALPN currently defined in the document.",
          "createdAt": "2023-01-18T16:24:01Z",
          "updatedAt": "2023-01-18T16:24:01Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOFUmh7s5RqgMO",
      "title": "Add current bandwidth estimation to API considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/35",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Section 8.1](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-8.1) explains:\r\n\r\n> If congestion control is done by the QUIC implementation, the application needs a mechanism to query the currently available bandwidth to adapt media codec configurations. The employed congestion controller of the QUIC connection SHOULD expose such an API to the application.\r\n\r\nbut the API considerations in [Section 9.1](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-9.1) do not include such an API.",
      "createdAt": "2022-09-12T15:25:38Z",
      "updatedAt": "2022-09-22T08:50:13Z",
      "closedAt": "2022-09-22T08:50:13Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "I_kwDOFUmh7s5SPx3a",
      "title": "Length field",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/39",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's Note:* We considered adding a framing like the one\r\n      described in [RFC4571] to send multiple RTP packets on one stream,\r\n      but we don't think it is worth the additional overhead only to\r\n      reduce the number of streams.  Moreover, putting multiple ADUs\r\n      into a single stream would also require defining policies when to\r\n      use the same (and which) stream and when to open a new one.\r\n\r\n[BA] The Length field isn't just for sending multiple RTP packets on one stream.  If the sender implements partial reliability, it may set a timer and then send a RESET_STREAM frame if the timer expires, in order to ensure against excessive retransmissions.  In that case, the receiver may only receive a portion of the frame, and the length field can enable it to determine that the frame was not completely received and should be discarded.  Also, the length field can be useful in memory allocation (e.g. a buffer can be allocated based on the expected length). \r\n\r\nI would also note that the 16-bit length defined in RFC 4571 was designed to be large enough to cover RTP packets, not entire frames sent in RTP over QUIC streams.  So if a length field is to be used in RTP over QUIC, it would either need to be larger (e.g. 32 bits) or if kept at 16 bits, could be used to denote the length in units of 4 octets.  ",
      "createdAt": "2022-09-20T19:04:35Z",
      "updatedAt": "2022-10-24T15:16:14Z",
      "closedAt": "2022-10-24T15:16:14Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "RESET_STREAM frames contain the final size of the stream, so the receiver can determine if the frame was completely received or not. But a length field may be helpful for the receiver to calculate how much data is still missing and to determine whether it is worth waiting longer before sending a STOP_SENDING frame.\r\n\r\nAn alternative for the 16-bit length field could also be to use a [variable-length integer](https://www.rfc-editor.org/rfc/rfc9000.html#section-16) as we did for the flow ID.",
          "createdAt": "2022-09-21T07:52:48Z",
          "updatedAt": "2022-09-21T07:52:48Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I just realized that the final size contained in a RESET_STREAM frame is not the size of the frame, but the\r\n\r\n> amount of flow control credit that is consumed by a stream\r\n\r\n[Section 4.5 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#section-4.5), so the receiver cannot use it to determine if a frame was completely received or not.\r\n\r\nSorry for the confusion.",
          "createdAt": "2022-09-23T08:25:49Z",
          "updatedAt": "2022-09-23T08:25:49Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I added the length field in #43 ",
          "createdAt": "2022-10-24T15:16:14Z",
          "updatedAt": "2022-10-24T15:16:14Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOFUmh7s5Sdo7k",
      "title": "Consider allowing mixing of QUIC streams and datagrams within RTP sessions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/41",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "> This specification defines two ways of carrying RTP packets in QUIC: 1) using reliable QUIC streams and 2) using unreliable QUIC DATAGRAMs. Every RTP session MUST choose exactly one way of carrying RTP and RTCP packets, different RTP sessions MAY choose different ways\r\n\r\nThe restriction to choosing exactly one way of carrying packets was added to avoid any unexpected outcomes of sending some RTP packets reliably on QUIC streams and others unreliably in QUIC datagrams.\r\n\r\nIt may however be desired to allow mixing streams and datagrams to implement partial reliability. For example, a sender may want to send I-frames of a video stream in QUIC streams to ensure reliable delivery, while sending P-frames in datagrams. Another scenario might be to send base layers of a stream using scalable video in QUIC streams and any additional layers in QUIC datagrams.",
      "createdAt": "2022-09-23T09:02:45Z",
      "updatedAt": "2022-10-24T14:30:04Z",
      "closedAt": "2022-10-24T14:30:04Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "As you mention, there are several use cases for using both QUIC streams and datagrams. \r\n\r\nWith SVC, base layer packets may represent a minority of the packets sent (as little as 25 percent with L1T3).  Since the base layer packets depend on each other, and losing one may prevent decoding of subsequent frames at all layers, losing a base layer frame has a high cost (e.g. keyframe generation).  \r\n\r\nTo avoid this cost, it may be necessary to set partial reliability timers considerably higher for base layer frames than for \"discardable\" extension layers.  In such a situation, sending base layer frames via frame/stream may not be that different from sending base layer frames over a single unidirectional stream. \r\n",
          "createdAt": "2022-10-04T03:04:34Z",
          "updatedAt": "2022-10-04T03:04:34Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I will bring this up in the meeting today. My general impression is that it is something that we should support. We were hesitant about this in the beginning because we were unsure of the potential problems this could bring up. When experimenting with this setup I ran into a synchronization issue where P-frames arrived before the first I-frame because the implementation prioritized sending datagrams first. This is solvable by having a jitter buffer wait for the first I-frame before passing anything to a decoder, but there may be other problems we haven't thought of yet.\r\n\r\n> To avoid this cost, it may be necessary to set partial reliability timers considerably higher for base layer frames than for \"discardable\" extension layers. In such a situation, sending base layer frames via frame/stream may not be that different from sending base layer frames over a single unidirectional stream.\r\n\r\nI think allowing multiple frames/ADUs per frame may be a follow-up discussion of #39?",
          "createdAt": "2022-10-04T08:43:29Z",
          "updatedAt": "2022-10-04T08:43:29Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOFUmh7s5TPau_",
      "title": "Interoperability between RTP over QUIC streams and plain RTP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/42",
      "state": "CLOSED",
      "author": "murillo128",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If I understood the draft correctly, basically when sending a frame with RTP over QUIC using streams, it will be \"packetized\" considering the MTU being infinite, that is, the whole frame would be sent as payload of the RTP packet (while still adhering to RTP packetization rules, I assume).\r\n\r\nThis would cause issues when trying to do a gateway that bridges between \"normal\" RTP and the QUIC stream version, as it will have to packetize/depacketize the whole frame again.\r\n\r\nOne potential solution is to still generate multiple RTP packets per frame and send them using RFC4571 over a single QUIC stream:\r\n\r\n```\r\n|len 1|RTP Packet1|len 2|RTP Packet2|...|len n|RTP PacketN|\r\n```\r\n\r\nThis would solve the interoperability issues, although will have a higher bandwdith overhead. ",
      "createdAt": "2022-10-04T16:30:12Z",
      "updatedAt": "2022-10-26T05:14:12Z",
      "closedAt": "2022-10-24T15:35:27Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I believe there are two sets of interop issues: \r\n\r\n1. - Interop between RTP over QUIC datagrams and RTP over UDP\r\n2. - Interop between RTP over QUIC frame/stream transport and RTP over UDP\r\n\r\nMTU issues can arise in either case. For example, RTP over QUIC datagrams may have a smaller MTU than RTP over UDP so RTP/UDP packets might need to be repacketized into multiple RTP/QUIC datagrams. \r\n\r\nTo enable a translator to operate without repacketization (which could require codec-specific knowledge), the RTP/UDP MTU needs to be set smaller, so as to allow the translated RTP/QUIC datagrams to stay within the MTU. \r\n\r\nSimilarly, RTP/QUIC stream transport could be configured with a non-infinite MTU, so as to allow a translator to translate to RTP/UDP without repacketizing.",
          "createdAt": "2022-10-15T22:35:16Z",
          "updatedAt": "2022-10-15T22:35:16Z"
        },
        {
          "author": "murillo128",
          "authorAssociation": "NONE",
          "body": "What is QUIC datagram overhead? i doubt #1 will ever be an issue in real life, while i doubt that QUIC over stream will be configured for non-infinite MTU as it defeat the whole pourpose of using streams.",
          "createdAt": "2022-10-15T23:50:26Z",
          "updatedAt": "2022-10-15T23:50:26Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "The RTP Topologies section is there to describe topologies, issues and potential solutions.  The topologies include use cases such as conferencing where the SFU and browser clients could be designed to work together. \r\n\r\nIn a use case where the conferencing server wants to support both RTP over QUIC and RTP/UDP clients, how can this be accomplished? In such a use case, the topology section needs to think about not only what a client should send, but also what it would need to be able to receive. \r\n\r\nIf the conferencing server is an SFU and is willing to parse the payload, it can re-packetize from RTP over QUIC streams to RTP/UDP.  But it may not want to do this.  For example, if the SFU wants to support multiple codecs (e.g. VP8, VP9, H.264, AV1) it might want to handle forwarding in a generic way rather than include code to parse each codec. \r\n\r\nTo be able to enable the SFU to do generic forwarding, the client can either configure a non-infinite MTU for RTP over QUIC streams or can send RTP over QUIC datagrams. Clients that only support RTP/UDP (e.g. browsers that only support WebRTC) could be handled by translating to RTP over QUIC streams if the alternative (RTP over QUIC datagrams) would result in fragmentation. ",
          "createdAt": "2022-10-16T00:37:32Z",
          "updatedAt": "2022-10-16T00:37:32Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened #43 to add a length field and allow multiple RTP packets per stream as you suggested, @murillo128.\r\n\r\nOne feature I removed by doing this is the ability of a receiver to request to cancel a stream by sending a `STOP_SENDING` frame, if the receiver knows that a packet is no longer needed. This doesn't work, if there are other packets following on the same stream and the receiver does not know if those are still required. We could add it back if we still require senders to open new streams for each ADU, but since they might be fragmented into multiple RTP packets, I am not sure if it is worth keeping this restriction only to enable receivers to cancel streams.\r\n\r\nWhat do you think about this?\r\n\r\n\r\n@aboba I agree that RTP over QUIC Datagrams and RTP over UDP may still lead to interop issues, but I don't know if there is anything we can do about it except to document it in the topology section?",
          "createdAt": "2022-10-17T10:40:34Z",
          "updatedAt": "2022-10-17T10:40:34Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I merged #43, which adds the length field and allows multiple packets per stream, and added an issue for the `STOP_SENDING` frame problem (#45). I also documented the second MTU interop issue in the new topology section. Closing this issue for now, but feel free to reopen or create new issues if I missed something.",
          "createdAt": "2022-10-24T15:35:27Z",
          "updatedAt": "2022-10-24T15:35:27Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I think that the important thing is to be clear about what topologies are tractable and which are more difficult.  Conferencing servers are quite different from generic translators; the former often have the codec-specific knowledge to re-packetize, whereas translators do not.  ",
          "createdAt": "2022-10-26T05:14:12Z",
          "updatedAt": "2022-10-26T05:14:12Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOFUmh7s5Usx1W",
      "title": "Receiver can't request stream cancellation vie STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/45",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim",
        "NotJustRTP"
      ],
      "body": "In #43 we added a length field to RTP packets that are sent over QUIC streams and allowed multiple packets per stream. Until now, it was possible for a receiver to request cancellation of a stream, if a packet is not needed anymore, e.g., because a deadline has passed. \r\n\r\nNow, since the receiver does not know how many packets to expect on a stream, it cannot know if it is safe to request cancellation, because the following packets may still be relevant.\r\n\r\nOne possible solution is to go back to one Application Data Unit (ADU) (e.g., one media frame) per stream, while still allowing this ADU to be fragmented into multiple RTP packets. ",
      "createdAt": "2022-10-24T15:32:06Z",
      "updatedAt": "2023-05-18T09:02:53Z",
      "closedAt": "2023-05-18T09:02:53Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "We need to be careful about ascribing meaning to STOP_SENDING since the interpretation could differ depending on what is being sent on the stream. If a new stream is sent for each frame, then STOP_SENDING would imply cancelling reception of one and only one frame. But if  SVC layers are sent on different streams, does a STOP_SENDING imply cancelling the sending of the layer sent on that stream?  Or if all frames are sent on a single stream, does STOP_SENDING mean that it is desired for the sender to pause sending that stream?\r\n\r\nUsing RTCP messages might be less ambiguous. ",
          "createdAt": "2023-02-23T23:13:46Z",
          "updatedAt": "2023-04-14T15:56:02Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "That is an interesting feature that I didn't think about before. Does it require some signaling to tell the receiver what layers are sent on which stream? How would a sender know when to restart sending the higher layer(s)?\r\n\r\nWhen we discussed this problem in London, there was a tendency to require the sender to close a stream after exactly one ADU. But it is unclear what an ADU is in different payload formats. For some audio codecs, that could lead to streams being closed after each frame containing only a few ms of data. That would then lead to a very large number of new streams. Too many streams could be a problem itself (see also #49), but it may also be unnecessary to transmit each of these audio frames independently.",
          "createdAt": "2023-02-24T09:22:02Z",
          "updatedAt": "2023-02-24T09:22:02Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "The receiver would need to know that the layers were segregated by stream. This could occur because the receiver requested a layer or because the sender set it up that way. If the receiver is getting one-way delay info, it could ask for more layers if the delay was stable and close to the transmission line, indicating low queuing and loss. But without probing, neither sender nor receiver can estimate the bottleneck bandwidth if the rate is well below that. So requesting more layers could result in increasing delays, indicating queue buildup.",
          "createdAt": "2023-02-24T15:06:51Z",
          "updatedAt": "2023-02-24T15:06:51Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This issue was discussed at IETF116, bringing up more details about the problem. We can drop the text around having `STOP_SENDING` as a feature that can be used to cancel a certain frame or even an SVC layer. However, we should add considerations about how a sender should react to an incoming `STOP_SENDING` frame. `STOP_SENDING` does not include an offset, so if the sender sent more than one media frame on that stream, it does not know which media frame the receiver intended to cancel. Receiving `STOP_SENDING` should not be treated as a request to retransmit any frames, there are RTCP messages for this already. I think the correct way to handle this would be to continue sending new media frames on new QUIC streams but without resending any media frame that was previously transmitted on the stream that received `STOP_SENDING`.\r\n\r\n@LPardue brought up the `CANCEL_PUSH` frame of HTTP/3, which solves a somewhat similar problem in HTTP/3. I am not sure how this could be mapped to RTP since we don't define any control messages so far, and I am not aware of any RTCP messages that could be used instead.\r\n\r\n@martinthomson recently submitted a new [draft for an `ENOUGH` frame](https://datatracker.ietf.org/doc/draft-thomson-quic-enough/) that adds an offset to `STOP_SENDING`. `ENOUGH` could inform the sender at which offset a receiver wants to cancel the stream. This would let the sender know which media frames to retransmit and which parts can be dropped. It would also indicate where to continue sending media on new QUIC streams.\r\n\r\nThe considerations about `STOP_SENDING` should also include an error code (see #76).",
          "createdAt": "2023-04-14T10:25:42Z",
          "updatedAt": "2023-04-14T10:25:42Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Clarifications to STOP_SENDING or RESET_STREAM can be helpful in guiding sender behavior.  But we also need to be clear what RTCP messages can be implied from QUIC semantics and which cannot.",
          "createdAt": "2023-04-14T16:13:43Z",
          "updatedAt": "2023-04-14T16:13:43Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOFUmh7s5ZNaHu",
      "title": "Provide detailed list of supported unicast topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/47",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Section 4.1 is an excellent start. I'd like to see a detailed list of supported RFC 7667 topologies in this draft, along with any additional considerations (the size mismatch between QUIC-RTP and UDP-RTP that's already described is a great example of what I'm thinking about).\r\n\r\nFeel free to assign this to me, of course. :wink:",
      "createdAt": "2022-12-14T13:59:05Z",
      "updatedAt": "2023-04-27T06:26:05Z",
      "closedAt": "2023-04-27T06:26:05Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed with @mengelbart and @joerg-ott, this might morph into enough informational guidance about how to use QUIC-RTP to justify splitting it into a separate document, which might or might not update RFC 7667, but that would be a call for @aboba and @JonathanLennox.",
          "createdAt": "2022-12-14T16:01:48Z",
          "updatedAt": "2022-12-14T16:01:48Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> As discussed with @mengelbart and @joerg-ott, this might morph into enough informational guidance about how to use QUIC-RTP to justify splitting it into a separate document, which might or might not update RFC 7667, but that would be a call for @aboba and @JonathanLennox.\r\n\r\nAnd, just like magic, the MUST required for using secure AVP profiles for non-RTP-over-QUIC paths interconnected to RTP-over-QUIC paths popped up. This is no longer informational guidance ... ",
          "createdAt": "2023-03-27T07:41:24Z",
          "updatedAt": "2023-03-27T07:41:24Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOFUmh7s5ZOZj5",
      "title": "Add any other relevant details about what QUIC feedback can replace AVP/AVPF feedback",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/48",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "SDP",
        "IETF116"
      ],
      "body": "This probably has impacts on SDP, depending on whether one QUIC/RTP endpoint needs to tell the other QUIC/RTP endpoint what feedback to send. ",
      "createdAt": "2022-12-14T16:06:13Z",
      "updatedAt": "2023-04-27T07:19:50Z",
      "closedAt": "2023-04-27T07:05:41Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "RTCP messages to consider include messages defined in RFCs 4585, 5104, 8888 and draft-ietf-avtcore-rtcp-green-metadata.",
          "createdAt": "2023-04-14T18:01:53Z",
          "updatedAt": "2023-04-14T18:01:53Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think 4585, 5104, and 8888 should all be included now, and I created a new issue to track draft-ietf-avtcore-rtcp-green-metadata: #79 ",
          "createdAt": "2023-04-27T07:19:50Z",
          "updatedAt": "2023-04-27T07:19:50Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOFUmh7s5ZOgZC",
      "title": "MAX_STREAMS and frame/stream transport",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/49",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF116",
        "NotJustRTP"
      ],
      "body": "A recent post on the MoQ list relates to the interaction of MAX_STREAMS and frame/stream transport:\r\nhttps://mailarchive.ietf.org/arch/msg/moq/hecXJfwaysqbyp85ZUwAT9I5CM0/\r\n\r\nLooking at the thread and after having done some experiments, there do appear to be scenarios (e.g. conferencing) where a low MAX_STREAMS limit could be exceeded. \r\n\r\nRelated: WebTransport API [Issue 446](https://github.com/w3c/webtransport/issues/446)",
      "createdAt": "2022-12-14T16:21:26Z",
      "updatedAt": "2023-05-18T09:03:04Z",
      "closedAt": "2023-05-18T09:03:04Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "We have been discussing this issue in the W3C WEBTRANSPORT WG.  Even though the MAX_STREAMS limit is cumulative, web browsers continually update the limit, based on the default maximum number of simultaneous streams on a QUIC connection (100 for Chrome).  The maximum number of simultaneous streams in use is determined by the maximum number of RTP streams and the level of concurrency (e.g. how many QUIC streams are simultaneously in use for each RTP stream).  \r\n\r\nThere are some scenarios in a limit of 100 simultaneous QUIC streams can be exceeded.  For example, consider a conference in which there are 50 participants and each RTP stream may have 4 QUIC streams in use at a time (e.g. 4 frames in transit).  This might require a limit of 200+ QUIC streams rather than 100.  ",
          "createdAt": "2023-02-23T23:21:02Z",
          "updatedAt": "2023-02-23T23:21:02Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The current draft says:\r\n\r\n> Opening new streams for new packets MAY implicitly limit the number of packets concurrently in transit because the QUIC receiver provides an upper bound of parallel streams, which it can update using QUIC MAX_STREAMS frames. The number of packets that have to be transmitted concurrently depends on several factors, such as the number of RTP streams within a QUIC connection, the bitrate of the media streams, and the maximum acceptable transmission delay of a given packet. Receivers are responsible for providing senders with enough credit to open new streams for new packets at any time.\r\n\r\nAs Christian mentioned on the MoQ list, a sender may need additional credits for background streams that are not RTP/RTCP. However, depending on the type of these background streams, they may or may not take some of the credit that is also used for media streams. According to [RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#name-controlling-concurrency), `max_streams` of 100 means that a sender can open `100 * 4 + first_stream_id_of_type` streams. `first_stream_id_of_type` can either be `2` if the sender is a client or `3` if it is a server (since we are only using unidirectional streams. If the background data transfer also uses unidirectional streams, it may be necessary to rate limit it to avoid the problem that it takes up all the credit all the time.\r\n\r\nThe level of concurrency depends on how the sender decides to use streams. The draft currently allows sending any number of packets on a stream or opening new streams at any time, but this may change (see #45). If the receiver knows the properties of the incoming media streams, how many there are, and how the sender uses QUIC streams, it may be able to calculate how often and by how much it must increase the MAX_STREAMS limit.",
          "createdAt": "2023-03-20T09:53:31Z",
          "updatedAt": "2023-03-20T09:53:31Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "I_kwDOFUmh7s5ZOpbl",
      "title": "QUIC interaction with ICE",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/50",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "joerg-ott"
      ],
      "labels": [
        "SDP",
        "Not Yet",
        "external doc",
        "Discussion required"
      ],
      "body": "We need QUIC-ICE in order to support peer-to-peer operation, but some functionalities overlap between ICE and QUIC. For example,\r\n- QUIC validates addresses, and ICE nominates candidate pairs\r\n- QUIC Ping frames and ICE Keepalives\r\nAnd, of course, ICE prioritizes candidate pairs, which QUIC might have opinions about for connection migration. \r\n\r\nThat's probably an incomplete list. But we need to figure this out. ",
      "createdAt": "2022-12-14T16:43:15Z",
      "updatedAt": "2023-10-23T15:48:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "QUIC over ICE shipped in a [Chromium Origin Trial in 2019](https://developer.chrome.com/blog/rtcquictransport-api/), and these issues were addressed as follows: \r\n\r\n* QUIC connection migration was not enabled, since this was handled by ICE, just as SCTP migration is not supported in WebRTC data channel. \r\n\r\n* ICE keepalives were implemented, since the socket can be shared (e.g. QUIC, SRTP/SRTCP, DTLS, ZRTP can be multiplexed) and so you can't assume that the keepalives are solely handled by QUIC. \r\n\r\n* For similar reasons, you need both ICE connectivity checks and QUIC address validation. ",
          "createdAt": "2022-12-14T21:34:40Z",
          "updatedAt": "2022-12-14T21:34:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins and @mengelbart suspect that the ICE negotiations may belong in another document that this document will reference, saying \"you need an open validate QUIC connection, and if you can't find the other endpoint without ICE, you need to go look at ICE-for-QUIC and come back here when you do have an open valid QUIC connection\". ",
          "createdAt": "2023-06-16T16:40:42Z",
          "updatedAt": "2023-06-16T16:40:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins thinks this is probably the RoQ version of https://github.com/moq-wg/moq-requirements/issues/103, and should probably have the same proposed path forward at this time, which is, for reference, \r\n\r\n> I think the Right Thing To DO is for us to participate in, and gate this issue on, discussion of draft-seemann-quic-nat-traversal-00 and draft-thatcher-p2p-quic-00 in the QUIC working group. @LPardue, is that WRONG?\r\n\r\n> I'll leave this tagged \"Deferred for now\" for now.\r\n\r\nWe don't have \"Deferred for now\" in THIS repo, but we do have \"Not Yet\", so it's probably correctly tagged for now. ",
          "createdAt": "2023-08-11T16:01:36Z",
          "updatedAt": "2023-08-11T16:01:36Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins is taking the action to see what, if anything, the QUIC working group can/will do to add ICE support to the base QUIC protocol, noting that my understanding from @aboba is that this is critical for WebRTC use of RoQ. ",
          "createdAt": "2023-09-01T16:19:00Z",
          "updatedAt": "2023-09-01T16:19:00Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "A complete replacement of ICE by QUIC is probably a long-term project.  But there are a few immediate questions: \r\n\r\na. The overlap between ICE candidate pair selection and QUIC interface selection.  Only one of these is probably needed.\r\nb. The use of QUIC ping for consent freshness versus RFC 7675. \r\n\r\nOther things (possibly handled in an SDP doc)\r\nc. The authentication mechanism. Self-signed certs with hash verification in signaling? \r\nd. It is possible to multiplex more than one RoQ connection on the same socket? ",
          "createdAt": "2023-09-02T01:54:37Z",
          "updatedAt": "2023-09-02T01:58:21Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "(This was actually part of a comment in the wrong issue - sorry! fixed now)\r\n\r\n> I'm thinking we can defer this issue for now and see how [P2P QUIC](https://datatracker.ietf.org/doc/draft-thatcher-p2p-quic/) and/or [Using QUIC to traverse NATs](https://datatracker.ietf.org/doc/draft-seemann-quic-nat-traversal/) progress. Thoughts?",
          "createdAt": "2023-10-23T15:44:35Z",
          "updatedAt": "2023-10-23T15:48:58Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOFUmh7s5ZO8vp",
      "title": "Possible use of QUIC multipath?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/51",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "NextDoc",
        "Not Yet"
      ],
      "body": "We can easily imagine usages of QUIC-RTP that would benefit from multipath capabilities. There are likely a number of considerations that we need to think through - for instance, would we provide one path to the application, that uses multiple paths below the application, or would we expect the application to manage multiple paths on its own? \r\n\r\nSome details: \r\n\r\n- [Multipath Extension for QUIC](https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/) is a QUIC working group draft now. \r\n- If we expect QUIC-RTP to use QUIC connection migration, we are already a long way toward a finished specification on how to use MPQUIC. \r\n- [Multipath RTP (MPRTP)](https://datatracker.ietf.org/doc/draft-ietf-avtcore-mprtp/) was adopted as an AVTCORE draft, but expired in 2016, due to lack of cycles for the folks who were working on it. \r\n- If we could resurrect MPRTP, we could provide a capability that RTCP understands. \r\n\r\nThis would need exploration, in order to propose a path forward. ",
      "createdAt": "2022-12-14T17:28:54Z",
      "updatedAt": "2023-10-23T15:54:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "If we are talking about RTP over QUIC over ICE (e.g. RTP over P2P QUIC) then we may not need QUIC connection migration, just as WebRTC data channel relied on ICE rather than SCTP connection migration.\r\n\r\nFor RTP over WebTransport, QUIC connection migration might be more interesting, since ICE is not involved.\r\n\r\nThen there is QUIC multipath versus multipath RTP. \r\n\r\n",
          "createdAt": "2022-12-14T21:28:44Z",
          "updatedAt": "2022-12-14T21:28:44Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We've added \"multipath\" to the [motivations section](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-exploiting-multiple-connect), but more details about this in the RoQ specification should probably wait until [Multipath Extension for QUIC](https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/) is at least past WGLC in QUIC. \r\n\r\n, ",
          "createdAt": "2023-10-23T15:54:02Z",
          "updatedAt": "2023-10-23T15:54:02Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOFUmh7s5ZPAI7",
      "title": "Possible use of QUIC Multicast? ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/52",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "wontfix",
        "NextDoc"
      ],
      "body": "QUIC does not have a [Multicast Extension for QUIC](https://datatracker.ietf.org/doc/draft-jholland-quic-multicast/) on its plate - this is currently an individual draft. \r\n\r\nIf $SOMEONE could move this draft forward in QUIC, and $SOMEONE could take on working through the details in AVTCORE, we could provide a QUIC-RTP that could support many of the [RFC 7667](https://datatracker.ietf.org/doc/rfc7667/) topologies that are currently out of scope for us. \r\n\r\nNo need for immediate attention to this issue, but it is something to keep in mind, until we decide that it's not. ",
      "createdAt": "2022-12-14T17:39:30Z",
      "updatedAt": "2023-10-16T14:47:13Z",
      "closedAt": "2023-10-16T14:47:13Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are no plans to support multicast in WebTransport, so I think we can rule that out. \r\n\r\nAre there any implementations of multicast over raw QUIC?  ",
          "createdAt": "2022-12-14T21:23:07Z",
          "updatedAt": "2022-12-14T21:23:07Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "We haven't discussed this explicitly, but I think we agree that multicast is not something that needs to be addressed in this version of RoQ. It would add a new dependency to an individual draft which contradicts #127, so I suggest we close this as *won't fix*.",
          "createdAt": "2023-10-11T12:57:52Z",
          "updatedAt": "2023-10-11T12:57:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins agrees with @mengelbart on closing this issue within the current RoQ draft work. If we do move forward on this, it should definitely be in another (\"follow-on\") document, anyway. ",
          "createdAt": "2023-10-16T14:47:13Z",
          "updatedAt": "2023-10-16T14:47:13Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOFUmh7s5ZQNEi",
      "title": "Review of RTP over QUIC draft (Vidhi Goel)",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/53",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Posted to the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/BA7LGvYhodx-PnnaKKPj2gcnzBc/\r\n\r\nHello Authors,\r\n\r\nI have read and reviewed draft-ietf-avtcore-rtp-over-quic-01 and below are my comments.\r\n\r\nGeneral comment - I think this draft will be really helpful for developers of real time applications in migrating to QUIC (from UDP and DTLS). The current draft touches on some important aspects such as multiplexing, de-depulication of RTCP feedback fields etc. But it needs some more details and clarifications regarding sections like congestion control, connection migration, multi path capability.\r\n\r\nSpecific comments - I am providing my comments section wise and there are a mix of minor nits, typos and major comments.\r\n\r\nSection 1. - A very big advantage of migrating to QUIC would be connection migration and MPQUIC. I think this should be mentioned in the intro and later described the impact of each of these on RTP. \r\nSection 3. - Current text - Such new media transport protocols may be covered elsewhere, e.g., in the MOQ WG. I don\u2019t think reference to MOQ is needed here. \r\nSection 6. - Multiplexing RTP/RTCP and non RTP (eg. HTTP) - since this will be discussed on Dec 15th interim, I will leave out my comment until a decision has been made.\r\nSection 6.1 - Current text - If it is known to either the sender, that a packet, which was not yet successfully and completely transmitted, is no longer needed.... Typo in the first part where \u201ceither\u201d is not needed.\r\nSection 7. - Typo in the word \u201cadditional\u201d -  QUIC layer to the application instead of exchanging addtional\r\nSection 7.1 - The list of replaceable RTCP reports appears without any pretext before \u201cReceiver Reports\u201d. A simple line that says what is coming next would solve it.\r\n                   - Under Receiver reports->Fractions lost, current text - Later packets SHOULD be ignored, since they may still be in flight, unless other QUIC packets that were sent after the datagram frame,. Why only sent after the datagram frame (and not stream) - maybe reframe the sentence to say RTP packet instead?\r\n\t\t   - Under Receiver reports->Highest Sequence Number received - This field is not clear. It would be clearer if it\u2019d say what does this field mean in RTP and can QUIC provide the exact same feedback from its ACKs.\r\n\t\t   - Negative acknowledgements - Probably make the recommendation clearer that since QUIC can provide all the information that a negative ack provides, there is no need to use RTCP negative Ack.\r\n   \t\t   - ECN feedback - same comment as above, clearly state that reporting of ECN feedback should be done via QUIC instead of RTCP feedback.\r\nSection 7.2 - English nit in current text - A QUIC receiver can also not calculate. Suggestion, Nor can a QUIC receiver calculate..\r\nSection 8 - This section needs some work IMO with regards to,\r\n\t1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\t2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\t3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nSection 10.2 - This is a sub section for impact of connection migration and it would be good to add one for MP QUIC as Multipath offers more benefits than migration. And, both the sections should clearly state if the RTP layer needs to do anything on path change.\r\n\t\t     - This line caught my attention - Application layer congestion control mechanisms (and also packet repair schemes such as retransmissions) need to be prepared to cope with such spikes.  Isn\u2019t this something they already deal with UDP anyway? I wasn\u2019t sure the reason for mentioning this explicitly.\r\n\r\nCommon to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places. The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n\r\nI can send out a PR for some of these comments.\r\n\r\nThanks,\r\nVidhi\r\n",
      "createdAt": "2022-12-14T21:20:49Z",
      "updatedAt": "2023-01-23T15:51:33Z",
      "closedAt": "2023-01-23T15:51:33Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @goelvidhi, as you can see, @aboba entered your review comments after the December virtual interim meeting. They are all in this issue, and most of the resolutions should be easy, so I will just respond to them as individual comments here, and they're likely to all end up in one PR. \r\n\r\nAnd thank you for your help!",
          "createdAt": "2023-01-12T20:19:35Z",
          "updatedAt": "2023-01-12T20:19:35Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 1. - A very big advantage of migrating to QUIC would be connection migration and MPQUIC. I think this should be mentioned in the intro and later described the impact of each of these on RTP.\r\n\r\nI have a couple of thoughts. \r\n\r\n- I agree that these advantages are worth mentioning, but one of the major points the authors are working on, is to specify as much as we **need** to specify, without waiting until we specify everything that **can** be specified. I'll mention both of these, without promising that they will be added in the short term.\r\n- QUIC connection migration is included in [RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-connection-migration), but Multipath QUIC is still an [Internet Draft](https://datatracker.ietf.org/doc/html/draft-ietf-quic-multipath-03). It's been adopted by the QUIC working group, but hasn't been WGLCed yet, so perhaps we should wait a bit before including details about how RTP can exploit multipath QUIC capabilities. \r\n\r\nI opened issue #51, and will follow up on this comment when I'm working on that issue. ",
          "createdAt": "2023-01-13T00:33:05Z",
          "updatedAt": "2023-01-16T23:00:27Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment:\r\n\r\n> Section 3. - Current text - Such new media transport protocols may be covered elsewhere, e.g., in the MOQ WG. I don\u2019t think reference to MOQ is needed here.\r\n\r\nSpencer agrees. Making this change now. ",
          "createdAt": "2023-01-13T00:34:02Z",
          "updatedAt": "2023-01-16T16:45:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 6. - Multiplexing RTP/RTCP and non RTP (eg. HTTP) - since this will be discussed on Dec 15th interim, I will leave out my comment until a decision has been made.\r\n\r\n@mengelbart has been working on this independently, in #54. Let's track this comment there. ",
          "createdAt": "2023-01-13T00:37:33Z",
          "updatedAt": "2023-01-16T16:48:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 6.1 - Current text - If it is known to either the sender, that a packet, which was not yet successfully and completely transmitted, is no longer needed.... Typo in the first part where \u201ceither\u201d is not needed.\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:38:25Z",
          "updatedAt": "2023-01-16T16:49:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7. - Typo in the word \u201cadditional\u201d - QUIC layer to the application instead of exchanging addtional\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:39:15Z",
          "updatedAt": "2023-01-16T19:42:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7.1 - The list of replaceable RTCP reports appears without any pretext before \u201cReceiver Reports\u201d. A simple line that says what is coming next would solve it.\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:40:03Z",
          "updatedAt": "2023-01-16T19:43:13Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>- Under Receiver reports->Fractions lost, current text - Later packets SHOULD be ignored, since they may still be in flight, unless other QUIC packets that were sent after the datagram frame,. Why only sent after the datagram frame (and not stream) - maybe reframe the sentence to say RTP packet instead?\r\n\r\nUpon reflection, Spencer suspects that this bullet really is datagram-specific, because QUIC (helpfully? :raised_eyebrow:) retransmits RTP packets carried in QUIC stream. A couple of paragraphs earlier, the text talks about direct mapping understating RTP losses and misstating RTP jitter when QUIC streams are used, and this might be clearer if it's restated in this bullet. \r\n\r\n@mengelbart, could you look at this, and tell me if I'm completely wrong? \r\n\r\nIn the meantime, I'm proposing this text, to make (my understanding of the point) clearer. \r\n\r\n  * *Fraction lost*: When RTP packets are carried in QUIC datagrams, the fraction of lost packets can be directly inferred from\r\n    QUIC's acknowledgments. The calculation SHOULD include all packets up to the\r\n    acknowledged RTP packet with the highest RTP sequence number. Later packets\r\n    SHOULD be ignored, since they may still be in flight, unless other QUIC\r\n    packets that were sent after the RTP packet frame, were already acknowledged.",
          "createdAt": "2023-01-13T00:42:23Z",
          "updatedAt": "2023-01-16T21:15:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment:\r\n\r\n> - Under Receiver reports->Highest Sequence Number received - This field is not clear. It would be clearer if it\u2019d say what does this field mean in RTP and can QUIC provide the exact same feedback from its ACKs.\r\n\r\nI'm proposing this text,\r\n\r\n  * *Highest Sequence Number received*: The highest sequence number received is\r\n    the highest sequence number of all RTP packets carried in a QUIC packet that was acknowledged.",
          "createdAt": "2023-01-13T00:43:12Z",
          "updatedAt": "2023-01-16T21:22:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - Negative acknowledgements - Probably make the recommendation clearer that since QUIC can provide all the information that a negative ack provides, there is no need to use RTCP negative Ack.\r\n\r\nI'm proposing this text.\r\n\r\n  * The generic negative acknowledgment packet contains information about\r\n    packets which the receiver considered lost. {{Section 6.2.1. of !RFC4585}}\r\n    recommends to use this feature only, if the underlying protocol cannot\r\n    provide similar feedback. QUIC does not provide negative acknowledgments,\r\n    but can detect lost packets through acknowledgments based on the Gap numbers contained in QUIC ACK frames.",
          "createdAt": "2023-01-13T00:44:12Z",
          "updatedAt": "2023-01-16T21:31:39Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - ECN feedback - same comment as above, clearly state that reporting of ECN feedback should be done via QUIC instead of RTCP feedback.\r\n\r\nThe draft currently says this.\r\n\r\n> QUIC\r\n>     supports ECN reporting through acknowledgments. If the connection supports\r\n>     ECN, the reporting of ECN counts SHOULD be done using QUIC acknowledgments.\r\n\r\nIf this isn't clear enough for the reader, I'm proposing this. \r\n\r\n  * ECN feedback packets report the count of observed ECN-CE marks. {{!RFC6679}}\r\n    defines two RTCP reports, one packet type (with `PT=205` and `FMT=8`) and a\r\n    new report block for the extended reports which are listed below. QUIC\r\n    supports ECN reporting through acknowledgments. If the connection supports\r\n    ECN, the reporting of ECN counts SHOULD be done using QUIC acknowledgments,\r\n    rather than RTCP ECN feedback reports.",
          "createdAt": "2023-01-13T00:45:10Z",
          "updatedAt": "2023-01-16T21:49:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7.2 - English nit in current text - A QUIC receiver can also not calculate. Suggestion, Nor can a QUIC receiver calculate..\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:46:38Z",
          "updatedAt": "2023-01-16T21:50:43Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n> 1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\r\nI'm not sure what spec we should comply to, but I definitely agree that we should say explicitly that RFC 9002 isn't the only possible spec that makes sense for realtime applications! I'll propose text here. ",
          "createdAt": "2023-01-13T00:49:55Z",
          "updatedAt": "2023-01-13T00:49:55Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n\r\n> 2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\r\nI'll propose text here. ",
          "createdAt": "2023-01-13T00:51:21Z",
          "updatedAt": "2023-01-13T00:51:41Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n> \r\n> 3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nMy opinion, and I'm sure we need to talk about this, is that for realtime media applications intended to run over the Internet, the application needs to do SOMETHING for (as you mention in another commend) rate adaptation. I'd make two observations here. \r\n\r\nFirst, and foremost, we don't have an agreed mechanism for how to tell a QUIC implementation at each end of a QUIC connection that this connection will be used to carry realtime media. Without that, the QUIC implementation has no way of knowing that the connection is not carrying HTTP/3, and we're going to get RFC 9002 behavior (or worse for realtime media, for example, BBF behavior). We should say that. \r\n\r\nSecond, for realtime media applications intended to run outside of controlled environments (as described in [RFC 8085](https://datatracker.ietf.org/doc/html/rfc8085#autoid-22), at a minimum, we can point to discussion about RTP circuit breakers in [RFC 8083](https://datatracker.ietf.org/doc/html/rfc8083).\r\n\r\nI've opened issue #59 to start more specific work on bandwidth estimation, rate adaptation, and congestion control, and will follow up there. ",
          "createdAt": "2023-01-13T01:27:20Z",
          "updatedAt": "2023-01-16T22:56:04Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 10.2 - This is a sub section for impact of connection migration and it would be good to add one for MP QUIC as Multipath offers more benefits than migration. And, both the sections should clearly state if the RTP layer needs to do anything on path change.\r\n\r\nThis is related to the comment about QUIC connection migration and MP-QUIC made for Section 1, and whatever we say in Section 10.2 should be summarized in Section 1. ",
          "createdAt": "2023-01-13T01:34:29Z",
          "updatedAt": "2023-01-13T01:34:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - This line caught my attention - Application layer congestion control mechanisms (and also packet repair schemes such as retransmissions) need to be prepared to cope with such spikes. Isn\u2019t this something they already deal with UDP anyway? I wasn\u2019t sure the reason for mentioning this explicitly.\r\n\r\nI think this is related to our discussion of rate adaptation for a previous comment. I'll come back to this comment in #59.",
          "createdAt": "2023-01-13T01:38:39Z",
          "updatedAt": "2023-01-16T22:57:24Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For these two comments: \r\n\r\n> Common to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places. \r\n>\r\n> The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n\r\n1. At a minimum, we can say \"QUIC datagrams, which are unreliable\" once, and remove all other occurrences. @mengelbart and @joerg-ott would know better, but some of this text, or at least some of the thinking behind it, may date back to the days when the QUIC working group was talking about whether they also needed to support reliable datagrams, but these days, I don't think we need to be as careful about saying this clearly. \r\n\r\n2. \"rate adaptation algorithm\u201d works for me, and for @mengelbart.",
          "createdAt": "2023-01-13T01:45:03Z",
          "updatedAt": "2023-01-16T22:53:04Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thank you, Spencer, for preparing a PR!\r\n\r\nI don't know if you intentionally skipped the comments about the fraction lost and the highest sequence number fields of receiver reports, so I just opened two PRs to address these: https://github.com/mengelbart/rtp-over-quic-draft/pull/56 https://github.com/mengelbart/rtp-over-quic-draft/pull/57 (Feel free to ignore them if you already made changes for these, too).",
          "createdAt": "2023-01-13T09:16:00Z",
          "updatedAt": "2023-01-13T09:16:00Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> > Common to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places.\r\n> > The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n> \r\n>     1. At a minimum, we can say \"QUIC datagrams, which are unreliable\" once, and remove all other occurrences. @mengelbart and @joerg-ott would know better, but some of this text, or at least some of the thinking behind it, may date back to the days when the QUIC working group was talking about whether they also needed to support reliable datagrams, but these days, I don't think we need to be as careful about saying this clearly.\r\n\r\nMentioning that QUIC datagrams are unreliable once should be enough. The RFC 9221 also has \"unreliable\" in its name, so the reference should make clear that these are unreliable datagrams.\r\n \r\n>     2. \"rate adaptation algorithm\u201d works for me. Does it work for the authors (and, of course, for the working group, but let's start with @mengelbart and @joerg-ott).\r\n\r\n\"rate adaptation algorithm\" works for me when we talk about real-time media. I'd prefer to keep \"congestion control\" when talking about QUIC's congestion control because it is also the term used in RFC 9002.",
          "createdAt": "2023-01-13T09:30:25Z",
          "updatedAt": "2023-01-13T09:30:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n> I don't know if you intentionally skipped the comments about the fraction lost and the highest sequence number fields of receiver reports, so I just opened two PRs to address these: #56 #57 (Feel free to ignore them if you already made changes for these, too).\r\n\r\nYou're probably learning that I do a lot of stuff UNintentionally. When I read your comment, I instantly remembered that comment, so whoops, my bad. :zany_face: \r\n\r\nThank you for cleaning up after me, and opening these PRs. I'll work on them as well. \r\n\r\n",
          "createdAt": "2023-01-13T14:30:14Z",
          "updatedAt": "2023-01-13T14:30:14Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> Mentioning that QUIC datagrams are unreliable once should be enough. The RFC 9221 also has \"unreliable\" in its name, so the reference should make clear that these are unreliable datagrams.\r\n\r\nThis actually turned out to be two mentions (one in the introduction, which precedes the terminology section, and one in the terminology section. \r\n\r\n",
          "createdAt": "2023-01-16T23:04:51Z",
          "updatedAt": "2023-01-16T23:04:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> \"rate adaptation algorithm\" works for me when we talk about real-time media. I'd prefer to keep \"congestion control\" when talking about QUIC's congestion control because it is also the term used in RFC 9002.\r\n\r\nI touched a lot of text with this one - see what you think!\r\n\r\n",
          "createdAt": "2023-01-16T23:06:15Z",
          "updatedAt": "2023-01-16T23:06:15Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOFUmh7s5bRjMq",
      "title": "Catch up on acknowledgements to date",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/55",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "@mengelbart, I added Vidhi Goel when I was working through her review comments (#53), and (I hope this is OK) alphabetized the names that were already included so we can avoid omissions and duplications as we get more (and more) reviews and comments, but it will be good for you and @joerg-ott to make sure we have everyone who has helped so far. ",
      "createdAt": "2023-01-12T20:32:27Z",
      "updatedAt": "2023-02-20T08:24:09Z",
      "closedAt": "2023-02-20T08:24:09Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Alphabetized sounds good. I have more additions, but I will wait for your PR so we don't create unnecessary merge conflicts.",
          "createdAt": "2023-01-13T09:33:57Z",
          "updatedAt": "2023-01-13T09:33:57Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOFUmh7s5bWHFS",
      "title": "Scoping description for Abstract and Introduction ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/58",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Starting with material in https://notes.ietf.org/k36X3Z4MR_qXbHtI5HTXFA?edit",
      "createdAt": "2023-01-13T15:50:21Z",
      "updatedAt": "2023-02-20T08:46:25Z",
      "closedAt": "2023-02-20T08:46:25Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@joerg-ott put together an excellent first draft for the scope statement, in [HedgeDoc](https://notes.ietf.org/k36X3Z4MR_qXbHtI5HTXFA?edit). I'll start with that, stir, and season. ",
          "createdAt": "2023-01-27T14:56:20Z",
          "updatedAt": "2023-01-27T14:56:20Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOFUmh7s5bhsfr",
      "title": "CC/RA: Explain how to avoid nested congestion controller loops for real time media",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/59",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "The current draft says (in \"Congestion Control at the Application Layer\"), \r\n\r\n> If the application implements full congestion control rather than just a\r\n> bandwidth estimation at the application layer using a congestion controller that\r\n> satisfies the requirements of {{Section 7 of !RFC9002}}, and the connection is\r\n> only used to send real-time media which is subject to the application layer\r\n> congestion control, **it is RECOMMENDED to disable any other congestion control\r\n> that is possibly running at the QUIC layer**. Disabling the additional congestion\r\n> controllers helps to avoid any interference between the different congestion\r\n> controllers.\r\n\r\nWe have talked about this for at least a couple of years, back when \"RTP over QUIC\" was still in the QUIC working group, but as I understand it, there's no way to do this now (in a standardized way), and a plain reading of the emphasized text makes me think what's being described would require a QUIC extension. \r\n\r\nI don't care how we actually do this, but we need to write down how to do it!",
      "createdAt": "2023-01-16T22:31:46Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Just noting down the points from my email that needs addressing,\r\n\r\n```\r\nSection 8 - This section needs some work IMO with regards to,\r\n1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n```",
          "createdAt": "2023-01-18T00:49:17Z",
          "updatedAt": "2023-01-18T00:49:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "From discussion with @joerg-ott and @mengelbart -\r\n\r\n- this is mostly about how a sending application tells a QUIC implementation what general type of congestion controller the QUIC implementation should use (say, NADA vs NewReno, \"please DON'T use an h3-optimized congestion controller for media\")\r\n- are we expecting the QUIC implementation to figure this out automagically? \r\n- how badly are h3-optimized congestion controllers going to work for application-limited, interactive applications?\r\n- Mathis work shows that rate-limited RTP rarely encounters QUIC limits that bulk transfer traffic would encounter",
          "createdAt": "2023-01-27T16:19:56Z",
          "updatedAt": "2023-01-27T16:19:56Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is about the proposal to disable QUIC's congestion controller, since a rate-limiting congestion controller is already in use at the application level. ",
          "createdAt": "2023-01-27T16:29:40Z",
          "updatedAt": "2023-01-27T16:29:40Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I replied to @goelvidhi s comments in #62 .\r\n\r\nI agree that the quoted text above is a bit unclear and maybe mixes a few things together that should be separated.\r\n\r\nI think as long as a sender complies to the congestion control requirements of QUIC as stated in RFC 9002/RFC 8085, it does not matter how it is implemented We might want to state this explicitly in the introduction to section 8 (see also #62).\r\n\r\nThe emphasized text above is about disabling one congestion controller when another is active as long as the active congestion controller applies to all outgoing traffic. The idea was to separate between an *RTP layer* and a *QUIC layer* and have the *RTP layer* do congestion control for real-time media. But that only works as long as the *RTP layer* is the only one sending data over the *QUIC layer*. As soon as the QUIC connection is shared between the *RTP layer* and some other datastream, congestion control must be done for both. \r\n\r\n> * this is mostly about how a sending application tells a QUIC implementation what general type of congestion controller the QUIC implementation should use (say, NADA vs NewReno, \"please DON'T use an h3-optimized congestion controller for media\")\r\n> * are we expecting the QUIC implementation to figure this out automagically?\r\n\r\nI don't see how a QUIC extension could help us solve this, but maybe this is rather an API question than a congestion control question?",
          "createdAt": "2023-02-01T12:57:22Z",
          "updatedAt": "2023-02-01T12:57:22Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Maybe we can discuss this issue either here or at #62. The general idea is to talk about the 3 options very clearly,\r\n1. CC/rate adaptation at both QUIC and RTP\r\n2. CC at QUIC only with necessary bandwidth estimation (perhaps other things) feedback provided from QUIC to RTP\r\n3. real time rate adaptation only with some compliance to 8085 - this one is tricky. Is there any existing rate adaptation algorithm that does this? If not, then this option is least preferable.\r\n\r\nI am not sure about the performance of option 1 and 2, so if there is some testing done for these, I would like to see the results. And testing on physical machines is preferable over emulators.\r\n",
          "createdAt": "2023-02-03T19:49:32Z",
          "updatedAt": "2023-02-03T19:51:33Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think there are multiple dimensions in which we can list different options. The first one is the layer at which congestion control is applied, either at the QUIC implementation layer or the application layer on top of QUIC or both. The second is the kind of congestion control used at both layers, which could for example be optimized for low latency or bulk transfer. And then, we have to distinguish between connections that are used for RTP only and connections that are shared between RTP and other non-RTP streams. Trying to break this down I get to something like this:\r\n\r\n### 0. No App CC + No QUIC CC \r\n\r\n  * Forbidden\r\n\r\n### 1. App CC + No QUIC CC\r\n\r\n* a) If only RTP runs on top of the QUIC connection, this can be any real-time rate adaptation that works well with RTP as long as it satisfies RFC 8085 and ideally also RFC 8836.\r\n* b) If RTP and non-RTP data share a QUIC connection, then all application protocols on top of that connection MUST do their own congestion control. It must be ensured that the result is still compliant with QUIC or RFC 8085 and that each stream receives a fair share of the bandwidth, which might be quite hard to get right.\r\n\r\n### 2. No App CC + QUIC CC\r\n\r\n* a) If only RTP runs on top of QUIC, the connection should ideally use a low latency congestion control algorithm and expose an estimated bandwidth to the application for codec configuration. This option looks very similar to 1a) above, because it is only an implementation detail where CC is implemented.\r\n* b) If RTP and non-RTP data share a connection, the congestion controller should assign bandwidth shares such that no stream can starve another.\r\n\r\n### 3. App CC + QUIC CC\r\n\r\n* a) For only RTP, this could be a potential fallback if 1a) and 2a) are not possible, e.g. because QUIC CC cannot do low latency or cannot expose the estimated bandwidth and it cannot be disabled either.\r\n* b) For a shared connection, this could be a potential fallback if 2b) is not possible.\r\n\r\n1a) and 2a) are very similar when we have free choice over which algorithms are used. 2b) seems the best choice for sharing connections. 3a) and 3b) don't seem to have any advantages but might be useful if other options are not available.\r\n\r\nRegarding real-time rate adaptation that is compliant to RFC 8085: I don't know for sure if the algorithms developed in RMCAT are compliant with RFC 8085, but since they were developed for environments that typically use UDP, I would be surprised if they are not. In any case, even if we can't or don't want to reference those algorithms explicitly, I don't think it should stop us from recommending algorithms that are optimized for low latency in general.\r\n",
          "createdAt": "2023-02-06T15:54:58Z",
          "updatedAt": "2023-02-06T15:54:58Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The discussion that @mengelbart and @goelvidhi have been having for this issue clarifies things quite a bit, even if the discussion mentioned \"disabling QUIC CC\" from time to time. The parts that don't assume that need to be inserted into the document as guidance, which is what we said at the [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
          "createdAt": "2023-03-09T17:23:04Z",
          "updatedAt": "2023-03-09T17:23:04Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOFUmh7s5cdSXl",
      "title": "Distinguish clearly between \"congestion control\" and \"rate adaptation\"",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/61",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "@goelvidhi mentioned this in her document review (sent to the mailing list, entered into #53 by @aboba), and I worked on this in #60, but where I ended up, was \r\n\r\n- it's helpful to distinguish between congestion control in general, and rate adaptation for interactive low-latency media, **but**\r\n- a significant number of RTP-centric specifications (for example, [RFC 8888](https://datatracker.ietf.org/doc/html/rfc8888)) use the term \"congestion control\" to describe what we're calling rate adaptation in this specification. \r\n\r\nI note that [RFC 8298](https://datatracker.ietf.org/doc/html/rfc8298) distinguishes between \r\n\r\n- Network Congestion Control, \r\n- Sender Transmission Control, and \r\n- Media Rate Control. \r\n\r\nSomething like that, early in this document, may be helpful. ",
      "createdAt": "2023-01-20T17:03:04Z",
      "updatedAt": "2023-02-20T08:25:14Z",
      "closedAt": "2023-02-20T08:25:14Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart said (in another review) that he agreed with the suggestion to add definitions for these terms early in the document. Perhaps prematurely, I renamed the Congestion Control section to be Congestion Control and Rate Adaptation in an earlier PR. ",
          "createdAt": "2023-01-23T15:59:19Z",
          "updatedAt": "2023-01-23T15:59:19Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOFUmh7s5cdWMv",
      "title": "QUIC congestion control, real-time congestion control, and (potentially) both, for the same QUIC connection",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/62",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "@goelvidhi had several questions about this interaction in her document review (sent to the mailing list, entered into #53 by @aboba), and it's worth mentioning this in a separate issue. \r\n\r\n- What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n- Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n- If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nThis is related to, but not the same as, #59 (if you don't want your media treated like H3 payloads, how do you tell the other endpoint that it's real-time media?). ",
      "createdAt": "2023-01-20T17:14:30Z",
      "updatedAt": "2023-03-09T19:38:16Z",
      "closedAt": "2023-03-09T17:13:59Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> * What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\r\nSince we are running RTP on top of QUIC and one of our goals is not to change or extend QUIC if possible, I would argue that RFC 9002 is at least one of the specs that a congestion controller should comply with. RFC 9002 says:\r\n\r\n> A sender can unilaterally choose a different algorithm to use, such as CUBIC [[RFC8312](https://www.rfc-editor.org/rfc/rfc9002.html#RFC8312)].\r\n>\r\n> If a sender uses a different controller than that specified in this document, the chosen controller MUST conform to the congestion control guidelines specified in [Section 3.1](https://www.rfc-editor.org/rfc/rfc8085#section-3.1) of [[RFC8085](https://www.rfc-editor.org/rfc/rfc9002.html#RFC8085)].\r\n\r\nwhich is reflected in the current draft in section 8. The section references RTP congestion control mechanisms but doesn't define any requirements. I would suggest adding [RFC 8836 (Congestion Control Requirements for Interactive Real-Time Media)](https://datatracker.ietf.org/doc/rfc8836/) here.\r\n \r\n> * Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\r\nI don't think there is anything that a media codec needs from a congestion controller. Calculating a bandwidth estimation helps because it allows the codec to produce media at a rate close to the maximum rate at which data can be transmitted to the receiver in real time. There may be more detailed signals available to improve the experience at the receiver, e.g., by changing the resolution or generating a new key fream, but I don't think this is the responsibility of congestion control.\r\n\r\n\r\n> * If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nIf a congestion controller does not comply with 1., it would be violating the QUIC specification. I think it is important that a sender complies with RFC 9002/RFC 8085 and RFC 8836 for real-time data, and using both congestion controllers might be a solution, although it might not be the best thing to do.\r\n\r\nShould we add some text to state more clearly, that a sender is expected to comply to the mentioned specifications?",
          "createdAt": "2023-02-01T12:38:28Z",
          "updatedAt": "2023-02-01T12:38:28Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Adding the specs to comply isn't a problem, its just that if QUIC CC is disabled, we have to make sure that it is feasible for the real time rate adaptation algorithm to comply to 8085. Does any of the current algorithms (Scream, NADA) reference 8085?",
          "createdAt": "2023-02-03T19:43:50Z",
          "updatedAt": "2023-02-03T19:43:50Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @goelvidhi - My understanding of the comments for this issue is that they all revolve around what we do if QUIC CC is disabled, and the guidance we have from the [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore) is **\"don't do that\"**. I think we can close this one. ",
          "createdAt": "2023-03-09T17:13:59Z",
          "updatedAt": "2023-03-09T17:13:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree with \"don't do that\", if \"QUIC CC is disabled\" means no congestion control is being done.\r\n\r\nIt might be helpful to have some definitions of terms like \"QUIC CC\", \"RTP CC\", \"Real-time CC\", etc. I tried to do that in https://github.com/mengelbart/rtp-over-quic-draft/issues/59#issuecomment-1419312129, because I think a lot of confusion comes from the different interpretations of these terms. \"QUIC CC\" might be used as \"the congestion controller running in the QUIC implementation\" or as \"the reno-like algorithm defined in RFC 9002\". Similarly, \"Real-time CC\" could mean \"congestion controller implemented in an application sending RTP\" or it might be used to reference a specific algorithm like SCReAM, NADA, or BBR.",
          "createdAt": "2023-03-09T17:38:25Z",
          "updatedAt": "2023-03-09T17:38:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree with \"don't do that\", if \"QUIC CC is disabled\" means no congestion control is being done.\r\n> \r\n> It might be helpful to have some definitions of terms like \"QUIC CC\", \"RTP CC\", \"Real-time CC\", etc. I tried to do that in [#59 (comment)](https://github.com/mengelbart/rtp-over-quic-draft/issues/59#issuecomment-1419312129), because I think a lot of confusion comes from the different interpretations of these terms. \"QUIC CC\" might be used as \"the congestion controller running in the QUIC implementation\" or as \"the reno-like algorithm defined in RFC 9002\". Similarly, \"Real-time CC\" could mean \"congestion controller implemented in an application sending RTP\" or it might be used to reference a specific algorithm like SCReAM, NADA, or BBR.\r\n\r\n@mengelbart - this is a super helpful suggestion. I created #70 to capture it.",
          "createdAt": "2023-03-09T19:38:15Z",
          "updatedAt": "2023-03-09T19:38:15Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOFUmh7s5eVZIM",
      "title": "Describe how RTP and non-RTP traffic sharing multiple QUIC connections on a single 5-tuple would work",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/65",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "We're starting with the idea that these types of traffic might not be using the same model for congestion control, but there's likely much more.",
      "createdAt": "2023-02-13T16:25:04Z",
      "updatedAt": "2023-10-23T15:43:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "When bulk transfer is enabled along with media, often the desire is for the bulk transfer not to interfere with the media.  To prevent that, the bulk transfer uses delay-based congestion control, same as for the media.  The bulk transfer will go slower, but that's often what the user wants. ",
          "createdAt": "2023-02-23T23:24:30Z",
          "updatedAt": "2023-02-23T23:24:30Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - now that we're focusing on \"providing guidance\" about congestion control and rate adaptation, I think that saying what you said in your comment is the right thing to say in the document. ",
          "createdAt": "2023-03-09T17:17:42Z",
          "updatedAt": "2023-03-09T17:17:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We may want a clear description of the many levels of multiplexing we can be doing (at the same time).  It's turtles all the way down. ",
          "createdAt": "2023-05-17T16:55:02Z",
          "updatedAt": "2023-05-17T16:55:31Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "This is a slight tangent to the topic at hand, but I have thought a few times about this myself, and I keep coming back to the idea that multiplexing multiple application protocols within a single QUIC connection is better solved in a distinct standard as it has applicability beyond facilitating bulk data transfer alongside streaming media.\r\n\r\nFor example, I can see a use case where you could have streaming media, live chat and file sharing all in a single connection. I really don't want to negotiate a connection with an `rq` ALPN on a simple device, only to have to add all the edge cases where a peer could start trying to bundle bulk transfer in the same connection. Instead, I'm thinking about a QUIC protocol extension which on a connection negotiated with ALPN _a_, then says I'd like to also send application protocol _b_. There's then some extension (or replacement for) the `STREAM` frame that stipulates which application protocol the contents of a given stream are destined for. I think connection-level flow control will still be tricky, but I'd imagine such an extension would contain provisions for flow control on each stream dependent on which application protocol it is assigned to (this definitely needs more thought).\r\n\r\nI am surprised an ID for something like this hasn't cropped up yet and I don't know if anyone would be interested in writing one beyond myself. There's always the \"you can do it in WebTransport\" argument but not everything is a conversation between a web browser and a web server.",
          "createdAt": "2023-06-08T13:51:09Z",
          "updatedAt": "2023-06-08T13:51:09Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Sorry, hit comment early... \r\n\r\nSo the current draft says \r\n\r\n> If a receiver cannot associate a flow identifier with any RTP/RTCP or non-RTP stream, it MAY drop the data stream.\r\n\r\nIf that is not ideal, we could define another ALPN that only allows media streams, but that would make things more complicated. When we discussed multiplexing, one of the requirements was to enable use cases where one would like to send non-RTP data on the same connection.\r\n\r\n> There's then some extension (or replacement for) the STREAM frame that stipulates which application protocol the contents of a given stream are destined for.\r\n\r\nThat sounds like what we do with the flow identifier, but without using a QUIC extension or a new frame.\r\n\r\nI don't know if an extension that allows to change the application protocol would be useful. If I understand you correctly, you would then need some other way of negotiating the new protocols on top.\r\n\r\nWe could use a STREAM frame extension (or some other form of indicating what a stream contains) that allows multiplexing different application protocols, but I would consider that a different issue from the ALPN negotiation. ",
          "createdAt": "2023-06-12T17:21:17Z",
          "updatedAt": "2023-06-12T17:21:17Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Not sure why the RTP over QUIC spec should have normative statements relating to non-RTP/RTCP data.  This would be like RFC 3550 attempting to define the behavior of WebRTC data channel.  Yes, WebRTC data channel can be multiplexed with RTP/RTCP, but unless something has done wrong, WebRTC data channel packets will never be forwarded to the RTP/RTCP stack. \r\n\r\nIt's the same here. RTP/RTCP is an application running over the P2P QUIC transport, which takes care of delivering RTP/RTCP data to the RTP stack.   If data is being sent, P2P QUIC multiplexing makes sure that it is not delivered to RTP/RTCP.   \r\n\r\nAlso, there is no need for multiple ALPNs.  Just as WebRTC only defines one ALPN, in P2P QUIC there is only one ALPN. \r\n\r\n",
          "createdAt": "2023-06-12T18:56:45Z",
          "updatedAt": "2023-06-12T18:56:45Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think I agree mostly with what you're saying, but I am a bit lost about the P2P QUIC part. \r\n\r\nWe decided to define multiplexing using the flow identifier and the `rtp-mux-quic` ALPN because, as far as I know, there was nothing like P2P QUIC defined that would do these things for us. If that changed or will change, should we consider dropping multiplexing with non-RTP/RTCP data and relying on the P2P QUIC multiplexing and ALPN instead?",
          "createdAt": "2023-06-12T20:18:35Z",
          "updatedAt": "2023-06-12T20:18:35Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @mengelbart - I do think we have an semi-infinitely large number of levels of  multiplexing in RoC, and anything that we don't have to specify is going to help us focus on what we absolutely DO need to specify.",
          "createdAt": "2023-07-27T22:38:24Z",
          "updatedAt": "2023-10-23T15:43:01Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOFUmh7s5gazP1",
      "title": "CC/RA: Phrase discussion about congestion control/rate adaptation in terms of guidance, not normative should/musts",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/67",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
      "createdAt": "2023-03-09T17:02:11Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOFUmh7s5gaz0U",
      "title": "CC/RA: Remove mentions about \"disabling QUIC congestion control\", etc. ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/68",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
      "createdAt": "2023-03-09T17:03:42Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Sorry, I saw this too late: Maybe https://github.com/mengelbart/rtp-over-quic-draft/issues/62#issuecomment-1462480865 should have been posted here. I think a definition of \"QUIC CC\" would be helpful, and removing \"disabling QUIC congestion control\" sounds good because it sounds confusing. But it should be allowed to use SCReAM/NADA/... without also having to run a loss-based algorithm like Reno.",
          "createdAt": "2023-03-09T17:44:38Z",
          "updatedAt": "2023-03-09T17:44:38Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOFUmh7s5ga8Tv",
      "title": "CC/RA: Explain why we aren't making BCP recommendations for rate adaptation algorithms in this document",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/69",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).\r\n\r\nWe should be describing considerations for people choosing congestion control and rate adaptation algorithms, of course. ",
      "createdAt": "2023-03-09T17:26:37Z",
      "updatedAt": "2023-05-11T07:49:34Z",
      "closedAt": "2023-05-11T07:49:34Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Rate Control is often application and codec-specific.  For example, in WebRTC an application can indicate that it prefers to maintain resolution or framerate in the event of congestion. There are also rate control algorithms that adjust quantization in response to congestion, but this is not always a good idea (e.g. if you are sharing text where maintaining readability is important).  So the RTP specifications and even RTP payload specs don't say much about rate control. \r\n\r\nCurrently, the RMCAT congestion control algorithms are Experimental, so that's a good reason to avoid making a recommendation, ",
          "createdAt": "2023-04-14T15:44:21Z",
          "updatedAt": "2023-04-14T15:44:21Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOFUmh7s5gbvdq",
      "title": "CC/RA: More clearly define what we mean by \"QUIC CC\", real-time media rate adaptation, etc. in this document.",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/70",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Suggested by @mengelbart in a #62 [comment](https://github.com/mengelbart/rtp-over-quic-draft/issues/62#issuecomment-1462480865). ",
      "createdAt": "2023-03-09T19:36:53Z",
      "updatedAt": "2023-04-14T12:25:00Z",
      "closedAt": "2023-04-14T12:25:00Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "*Congestion Control* and *Rate Adaptation* are already defined in the terminology section. I would suggest adding the following definitions:\r\n\r\n* **Loss-based congestion control algorithm**: A congestion control algorithm that uses packet loss as a signal for congestion. Loss-based congestion control algorithms allow senders to send data on a path until packets are dropped by intermediary network elements, which the algorithm treats as a signal of congestion.\r\n* **Delay-based or Low-latency congestion control algorithm**: A congestion control algorithm that aims at keeping queues, and thus the latency, at intermediary network elements as short as possible. Delay-based congestion control algorithms use, for example, an increasing one-way delay as a signal of congestion.\r\n* **QUIC congestion controller**: A software component of a QUIC implementation that implements a congestion control algorithm.\r\n* **RTP congestion controller**: A software component of an RTP implementation that implements a congestion control algorithm.",
          "createdAt": "2023-03-20T12:06:13Z",
          "updatedAt": "2023-03-20T12:06:13Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - thanks for this proposed text. I have two suggestions, which I'll put in my PR, but what you said was super helpful. \r\n\r\n> Loss-based congestion control algorithm: A congestion control algorithm that uses packet loss as a signal for congestion. Loss-based congestion control algorithms allow senders to send data on a path until packets are dropped by intermediary network elements, which the algorithm treats as a signal of congestion.\r\n\r\nI'm being pedantic, but I would also include networks that provide ECN, which is typically treated as data loss (although Scalable Congestion Controllers treat ECN(1) differently\r\n\r\nAnd, actually I'd also include networks that support ECN(1) under \"Delay-based or Low-latency congestion control algorithm\". So, I guess that's two and a half suggestions? \r\n\r\n> RTP congestion controller: A software component of an RTP implementation that implements a congestion control algorithm.\r\n\r\nI THINK that this can also happen in an application using an RTP implementation, can't it? ",
          "createdAt": "2023-03-25T11:19:19Z",
          "updatedAt": "2023-03-25T11:19:19Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Including ECN sounds good to me. Do you suggest including them under loss-based, delay-based, or both?\r\n\r\n> I THINK that this can also happen in an application using an RTP implementation, can't it?\r\n\r\nYes, I think this is possible, but maybe it just depends on where you draw the line between the RTP implementation and the application?",
          "createdAt": "2023-03-27T02:35:55Z",
          "updatedAt": "2023-03-27T02:35:55Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I THINK that this can also happen in an application using an RTP implementation, can't it?\r\n> \r\n> Yes, I think this is possible, but maybe it just depends on where you draw the line between the RTP implementation and the application?\r\n\r\n@mengelbart - on thinking more (and more clearly), I don't think we need to address this here. ",
          "createdAt": "2023-03-27T08:01:20Z",
          "updatedAt": "2023-03-27T08:01:20Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOFUmh7s5h22qf",
      "title": "PLEASE choose an acronym for \"RTP over QUIC\"!!!",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/74",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "joerg-ott"
      ],
      "labels": [],
      "body": "If we had a reasonable acronym for \"RTP-over-QUIC\", our specification would be more than a little bit easier to read. \r\n\r\nI'm not suggesting one - I think @mengelbart and @joerg-ott should have the honor of painting that bikeshed - but I think we need one badly, and I expect marketing types outside the IETF, or even participants in other SDOs, to pick one if we don't. \r\n\r\n:upside_down_face:",
      "createdAt": "2023-03-27T09:46:26Z",
      "updatedAt": "2023-04-27T07:14:15Z",
      "closedAt": "2023-04-27T07:14:15Z",
      "comments": [
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "Might I suggest [QRT](https://datatracker.ietf.org/doc/html/draft-hurst-quic-rtp-tunnelling)? \ud83d\ude07\r\n\r\nAlternatively, maybe just \"rq\", in the same way that HTTP-over-QUIC was originally \"hq\"?",
          "createdAt": "2023-03-27T09:55:31Z",
          "updatedAt": "2023-03-27T09:55:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "The obvious one is one syllable - RoQ. Why not?",
          "createdAt": "2023-03-28T05:27:16Z",
          "updatedAt": "2023-03-28T05:27:16Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "RoQ - I like it!",
          "createdAt": "2023-04-14T15:45:15Z",
          "updatedAt": "2023-04-14T15:45:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think RoQ makes sense as it also aligns with MoQ and DoQ. I also just talked to @joerg-ott and we agreed on using RoQ.  I'll open a PR.",
          "createdAt": "2023-04-14T16:00:50Z",
          "updatedAt": "2023-04-14T16:00:50Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOFUmh7s5h8XdB",
      "title": "Improve consideration for multi-hop topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/75",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF118",
        "Discussion required"
      ],
      "body": "So the QUIC connection carrying RTP will for now be point to point. However, as RTP has notion of RTP middleboxes that are used to create multiparty topologies there need to be better consideration for when one can do optimizations like reducing the rate of RTCP because the RTCP receiver related statistics will be known by QUIC sender. So if one can reduce the rate or even skip some RTCP reports is all dependent if the RTP middlebox that interconnects has full autonomy and can act on all aspects on the transport feedback. However, if the original sender in a system would monitor all receivers and actually adapt its general rates in a simulcast for example and the middlebox just selects between the simulcast versions then one would have to maintain RTCP reports that does cross reporting over the whole RTP session. \r\n\r\nSo I think you need to clarify for example in Section 6.1 that the system needs to decided on its need and use signalling to both configure the reports the system needs as well as the frequency of the RTCP reporting.  ",
      "createdAt": "2023-03-28T05:14:28Z",
      "updatedAt": "2023-09-25T16:17:23Z",
      "closedAt": "2023-09-25T16:17:23Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I would also note that if a RTP session member does not send any RTCP receiver reports it might be classify it as not longer part of the session. RFC 3550 does only require one to send RTP/RTCP packets the last 5 reporting interval. However, I have feeling that many implementation will us SR or RR as equivalent to sending RTCP as they have been the base line. ",
          "createdAt": "2023-03-28T05:21:50Z",
          "updatedAt": "2023-03-28T05:21:50Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "[the second comment](https://github.com/mengelbart/rtp-over-quic-draft/issues/75#issuecomment-1486234250) is Related to #117, but this issue requires us to provide a reasonably complete set of mappings between RTCP feedback and QUIC feedback for any middlebox that bridges between legacy RTP and RoQ. We should probably do #117 first, and then start work on the set of mappings. \r\n\r\nOne other alternative is to signal RoQ endpoints saying \"this RoQ session is being bridged to legacy RTP, and I'm NOT mapping between QUIC feedback and RTCP reports, so you should probably be using RTCP\". More thought required ... ",
          "createdAt": "2023-09-01T15:18:44Z",
          "updatedAt": "2023-09-01T15:26:56Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOFUmh7s5h8bFA",
      "title": "Important: define error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/76",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "Related to #13 but also applicable to the rest of the specification.\r\n\r\nRTP over QUIC is an application layer mapping for RTP applications. \r\n\r\nWhen using STOP_SENDING or RESET_STREAM, the code has to be an application-layer error code, and you don't have one. Without that, people will just pick random numbers (or worse, send 0 for everything). \r\n\r\nDefining codes isn't too hard, we should put some thought into gradeful or abrupt conditions that can be communicated via error codes",
      "createdAt": "2023-03-28T05:30:40Z",
      "updatedAt": "2023-10-23T14:09:55Z",
      "closedAt": "2023-10-23T14:09:55Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue - do you plan to provide text for this issue by the next AVTCORE interim? ",
          "createdAt": "2023-09-15T15:22:48Z",
          "updatedAt": "2023-09-15T15:22:48Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOFUmh7s5iK0bf",
      "title": "Add motivations for RoQ adoption",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/77",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF117"
      ],
      "body": "Add motivations for RQ work and adoption\r\n\r\nTransport-level encryption with RQ.\r\n\r\nUsing QUIC as it evolves (connection migration, and especially multipath QUIC).\r\n\r\nThinking about policy aspects of connection migration between interfaces (cheap WiFi vs expensive cellular).\r\n\r\nPotential connection sharing with other protocols over QUIC.\r\n\r\nQUIC path MTU discovery, especially in multiparty environments (today conference server has no option except using the lowest path MTU for all conference participants). \r\n\r\nACK piggybacking in QUIC if there are any QUIC frames going the other direction versus ACKs decreasing the available MTU for media. \r\n\r\nBeing clear about how RQ congestion control and flow control work.\r\n\r\nPossible advantage if audio is piggybacking on video in RQ - packaging multiple frames into a packet. \r\n\r\nThink about how multiple media quality variants would work - is there an advantage here?\r\n\r\nMultiplexing real-time and non-real-time flows. \r\n\r\nInteraction between QUIC congestion control and media congestion control. ",
      "createdAt": "2023-03-30T06:35:41Z",
      "updatedAt": "2023-07-23T21:35:46Z",
      "closedAt": "2023-07-23T21:35:46Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated motivations issues \r\n\r\nm-Transport-level encryption with RQ.\r\n\r\nm-Using QUIC as it evolves (connection migration, and especially multipath QUIC).\r\n\r\nm-Potential connection sharing with other protocols over QUIC.\r\n\r\nm-QUIC path MTU discovery, especially in multiparty environments (today conference server has no option except using the lowest path MTU for all conference participants).\r\n\r\nm-ACK piggybacking in QUIC if there are any QUIC frames going the other direction versus ACKs decreasing the available MTU for media. #85 \r\n\r\nm-Possible advantage if audio is piggybacking on video in RQ - packaging multiple frames into a packet.\r\n\r\nm-Multiplexing real-time and non-real-time flows.",
          "createdAt": "2023-05-17T16:33:41Z",
          "updatedAt": "2023-05-17T16:33:41Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The initial list for this issue are from discussions with with @gchandok at IETF 116. ",
          "createdAt": "2023-06-16T15:55:45Z",
          "updatedAt": "2023-06-16T16:27:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins requested this one be assigned to him, because he is likely responsible for similar text in the [MOQ Requirements draft](https://github.com/moq-wg/moq-requirements). ",
          "createdAt": "2023-06-16T16:29:32Z",
          "updatedAt": "2023-06-16T16:29:32Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOFUmh7s5kglq1",
      "title": "Add RTCP messages from draft-ietf-avtcore-rtcp-green-metadata",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/79",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "draft-ietf-avtcore-rtcp-green-metadata is not yet included in the list of feedback types",
      "createdAt": "2023-04-27T07:19:06Z",
      "updatedAt": "2023-07-23T20:44:50Z",
      "closedAt": "2023-07-23T20:44:50Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @JonathanLennox, **this is a process question** - do the chairs think draft-ietf-avtcore-rtcp-green-metadata is ready for us to include it in the RTP over QUIC discussion about mapping QUIC to RTCP feedback? \r\n\r\ndraft-ietf-avtcore-rtcp-green-metadata has been adopted as a working group draft, but it's the first I-D we're including in the QUIC-to-RTCP discussion - everything else has been an approved RFC. So I thought I should ask for guidance. ",
          "createdAt": "2023-04-27T15:21:34Z",
          "updatedAt": "2023-04-27T15:21:34Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @JonathanLennox, we haven't heard a response about our process question, and we are assuming that adding the rtcp-green-metadata is the Right Thing To Do, and will add it to our draft. Please tell us if this is wrong. ",
          "createdAt": "2023-06-16T15:10:08Z",
          "updatedAt": "2023-06-16T15:10:08Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOFUmh7s5kgnOk",
      "title": "Reference RTCP subsections from tables",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/80",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "The tables in sections [6.5](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.5) - [6.8](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.8) contain a lot of information which is also explained in more detail in section [6.3](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.3). I think we can reference the relevant subsections from the tables instead.",
      "createdAt": "2023-04-27T07:23:55Z",
      "updatedAt": "2023-09-22T07:46:09Z",
      "closedAt": "2023-09-22T07:46:09Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I agree that putting all of the material relating to a specific feedback mechanism in one place, and referring to it rather than adding text elsewhere makes sense. Here's what I was thinking about while working on PR #71.\r\n\r\n- some material is duplicated (in text and in tables), \r\n- some material is split (between text in tables), \r\n\r\nThat's roughly this issue. But, in addition, \r\n\r\n- It makes sense to me that we would have a list of what can be mapped between approved QUIC (RFC 9000 + RFC 9221) and RTCP, and a separate list of what could be mapped if we had one of the timestamps drafts (to help people understand why we need one of those drafts). Does that make sense to you? \r\n- I made the (not necessarily correct) decision to list everything that we looked at, whether it can be mapped between QUIC and RTCP or not, so we have a lot of table entries that say \"no\", even if some entries in the same table say \"yes\", and that's begging for us to also document why we think the answer is \"no\" (again, should we be adding that?)\r\n\r\nIt might make sense to move this second group of possible changes into its own, but (especially if we decide that spending a lot of effort on \"no\" entries isn't worth doing), we might be making to changes to text/tables/rows that we'll end up deleting from the document. \r\n\r\nDo you have thoughts about that? Should we have a short Slackathon to discuss?",
          "createdAt": "2023-04-27T15:02:26Z",
          "updatedAt": "2023-04-27T15:02:26Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> It makes sense to me that we would have a list of what can be mapped between approved QUIC (RFC 9000 + RFC 9221) and RTCP, and a separate list of what could be mapped if we had one of the timestamps drafts (to help people understand why we need one of those drafts). Does that make sense to you?\r\n\r\nI agree that having a list of what could be mapped with or without a timestamp extension would be helpful. I am not sure if that should be a separate table or if it would be enough to have an extra column for that.\r\n\r\n> I made the (not necessarily correct) decision to list everything that we looked at, whether it can be mapped between QUIC and RTCP or not, so we have a lot of table entries that say \"no\", even if some entries in the same table say \"yes\", and that's begging for us to also document why we think the answer is \"no\" (again, should we be adding that?)\r\n\r\nThat sounds good, too. I assume that the explanation would be the same for many of the fields so maybe we can do something similar to what you did in the topologies section, so we can reference the explanation/notes/subsection from all rows in the table to which it applies?\r\n",
          "createdAt": "2023-05-02T08:24:10Z",
          "updatedAt": "2023-05-02T08:24:45Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We may want to move some of these sections into an appendix (\"we looked at these and don't think they're useful, so other people don't have to wonder if we looked at them\").",
          "createdAt": "2023-05-17T17:05:42Z",
          "updatedAt": "2023-05-17T17:05:42Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "I_kwDOFUmh7s5lJPAz",
      "title": "Should we describe congestion control BEFORE we describe mapping QUIC feedback onto RTCP?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/82",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "I note that there is some material in the current Section 6 (\"Replacing RTCP and RTP Header Extensions with QUIC Feedback\") that \"prestates\" (it would be restating, but it comes before) the current Section 7 (\"Congestion Control and Rate Adaptation\"), but Step One would be to swap the two sections, and then review for clarity and continuity. \r\n\r\nFor example, [I-D.draft-smith-quic-receive-ts] and [I-D.draft-huitema-quic-ts] are mentioned more than once in each section, and it would be better if we explained what's going on once, on first use, and then just used references. ",
      "createdAt": "2023-05-05T02:32:39Z",
      "updatedAt": "2023-05-18T18:33:30Z",
      "closedAt": "2023-05-18T18:33:30Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Start with the section swap, and then edit looking for redundancies. ",
          "createdAt": "2023-05-17T17:07:07Z",
          "updatedAt": "2023-05-17T17:07:07Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOFUmh7s5ltjik",
      "title": "Add more detail to section 7.3 on congestion control when sharing connections with non-RTP streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/84",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "question",
        "Review outside AVTCORE needed",
        "Not Yet"
      ],
      "body": "[Section 5.1](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#section-5.1) explains in detail how multiplexing RTP with other protocols would work and [section 7.3](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#section-7.3) is supposed to explain how to do congestion control for that. But the only sentence about this is rather vague:\r\n\r\n> Applications multiplexing multiple streams in one connection SHOULD implement some form of stream prioritization or bandwidth allocation.\r\n\r\nThis also came up in discussion with Gurtej and is slightly related to the discussion we had here: https://github.com/mengelbart/rtp-over-quic-draft/pull/83#discussion_r1191585178",
      "createdAt": "2023-05-11T19:45:15Z",
      "updatedAt": "2023-11-08T10:18:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We need informed opinions about the maturity of NADA/SCReAM competing with congestion controllers like BBR - probably a good question for CCWG (former [CONGRESS](https://datatracker.ietf.org/doc/charter-ietf-congress/)) when they are chartered. One way or another, this issue relies on expertise that is outside the core competence of many AVTCORE participants, even if some participants have that core competence. ",
          "createdAt": "2023-05-17T17:16:10Z",
          "updatedAt": "2023-06-16T16:15:34Z"
        },
        {
          "author": "pthatcher",
          "authorAssociation": "NONE",
          "body": "One could, of course, just let the QUIC and non-QUIC do their own congestion control that compete with one another.  That's how SCTP and RTP work together in WebRTC.   One could theoretically have the two protocols coordinate with one congestion controller, but that's complex enough work that no one (that I know of) has attempted it.  \r\n\r\nI would suggest just leaving this an implementation detail.   If implementations want to try and do the complex work of coordinating the congestion control across different protocols, they can.  If they want to keep it simple and let them compete, they can.   ",
          "createdAt": "2023-11-08T09:24:08Z",
          "updatedAt": "2023-11-08T10:18:59Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> Oen could, of course, just let the QUIC and non-QUIC do their own congestion control that compete with one another. That's how SCTP and RTP work together in WebRTC. One could theoretically have the two protocols coordinate with one congestion controller, but that's complex enough work that no one (that I know of) has attempted it.\r\n> \r\n> I would suggest just leaving this an implementation detail. If implementations want to try and do the complex work of coordinating the congestion control across different protocols, they can. If they want to keep it simple and let them compete, they can.\r\n\r\n@pthatcher - I agree, and that seems like helpful guidance that isn't going to be **too** helpful. :laughing:",
          "createdAt": "2023-11-08T09:53:22Z",
          "updatedAt": "2023-11-08T09:53:22Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOFUmh7s5ltkx1",
      "title": "Add MTU vs. extra packet considerations for Acknowledgements when using datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/85",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "QUIC acknowledgment frames can be sent in the same packet as stream or datagram frames, which adds overhead and reduces the maximum size of datagram frames. If a packetizer is configured to produce packets at a fixed maximum MTU, the sender may need to send many extra QUIC packets for acknowledgments. It may be helpful to reference the acknowledgment frequency draft, which could help to reduce the overhead somewhat.\r\n\r\nMaybe relevant: https://www.rfc-editor.org/rfc/rfc9000#section-13\r\n",
      "createdAt": "2023-05-11T19:49:29Z",
      "updatedAt": "2023-07-10T16:29:52Z",
      "closedAt": "2023-07-10T16:29:52Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The fundamental problem this issue is pointing to, is that the RTP sender (and receiver) does not have visibility to non-data frames that a QUIC sender may include in an outgoing QUIC packet. So, not just QUIC ACKs. We can provide a description of the trade-offs in the document now, but we probably can't make specific recommendations (\"do this, not that\") in the document, at least not yet. ",
          "createdAt": "2023-06-16T16:08:25Z",
          "updatedAt": "2023-06-16T16:08:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "If we find that we are able to make specific recommendations, these recommendations may be added under a follow-up issue. ",
          "createdAt": "2023-06-16T16:18:14Z",
          "updatedAt": "2023-06-16T16:18:14Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "I_kwDOFUmh7s5ltlUH",
      "title": "Coalescing RTP packets in single QUIC packet",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/86",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "Over UDP, every RTP packet gets sent in a UDP datagram. In QUIC, one could batch multiple small RTP packets together in a QUIC packet. This will probably happen automatically for streams but may depend on some scheduling for datagrams. That scheduling should take real-time requirements into account, i.e., try to optimize by batching, but also not delay packets too much.\r\n\r\nMaybe relevant: https://www.rfc-editor.org/rfc/rfc9000#section-13\r\n",
      "createdAt": "2023-05-11T19:51:13Z",
      "updatedAt": "2023-10-23T15:39:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Batching RTP packets is something that QUIC implementations can do, and @mengelbart and @SpencerDawkins think this is worth noting in the document, but it seems more useful to wait until we have some experience that tells us whether this will matter (assuming a conforming QUIC implementation) before we add text about recommendations implementers of RTP senders should consider. . ",
          "createdAt": "2023-06-16T15:59:56Z",
          "updatedAt": "2023-06-16T15:59:56Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOFUmh7s5ltnbS",
      "title": "Are real-time congestion controllers tied to RTP or usable in QUIC stacks?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/87",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "question",
        "Review outside AVTCORE needed"
      ],
      "body": "SCReAM, NADA, and GCC were specifically designed with RTP/RTCP in mind. Is it feasible to use one of these in the QUIC stack itself, or are there other alternatives that could be implemented directly in a QUIC stack to follow the recommendations given in [section 7.1](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-7.1)? One requirement that all of the RMCAT algorithms have is that they need timestamps, which could be provided by one of the QUIC timestamp extension drafts.\r\n\r\nThis came up in discussion with Gurtej and again in https://github.com/mengelbart/rtp-over-quic-draft/pull/83#discussion_r1190525045\r\n",
      "createdAt": "2023-05-11T19:57:00Z",
      "updatedAt": "2023-11-08T09:47:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "IMO, it would be ideal to implement a real time rate adaptation algorithm in the QUIC stack and then expose an API for bitrate estimation to the application/framework that uses that to call into encoder. I can take this issue but do we need a PoC before making this text change?",
          "createdAt": "2023-06-10T01:01:03Z",
          "updatedAt": "2023-06-10T01:01:03Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree with that. I think a PoC and some experiments exploring such an implementation would be nice. I had this on my list for some time now but didn't get to implement it yet. I don't know if we need it before changing any text, but it might give some insights that could be useful to document.",
          "createdAt": "2023-06-12T17:26:34Z",
          "updatedAt": "2023-06-12T17:26:34Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I said I would send this out to @lpardue and @pthatcher as a question, and failed. I **promise, promise, promise** ...",
          "createdAt": "2023-07-27T22:53:39Z",
          "updatedAt": "2023-07-27T22:53:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm not sure what the question is - what can I help with?",
          "createdAt": "2023-07-27T23:13:54Z",
          "updatedAt": "2023-07-27T23:13:54Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi - on this:\r\n\r\n> IMO, it would be ideal to implement a real time rate adaptation algorithm in the QUIC stack and then expose an API for bitrate estimation to the application/framework that uses that to call into encoder. I can take this issue but do we need a PoC before making this text change?\r\n\r\nI think a POC is a fine idea, but if we have a new congestion controller, that probably starts in [ICCRG](https://datatracker.ietf.org/rg/iccrg/about/), doesn't it?",
          "createdAt": "2023-07-27T23:14:12Z",
          "updatedAt": "2023-07-27T23:14:12Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @SpencerDawkins think that asking @LPardue and @pthatcher for clues is still the right thing to do, but not until we merge PR #134, because we're still changing the text that we want to ask about. :roll_eyes:",
          "createdAt": "2023-10-16T15:21:36Z",
          "updatedAt": "2023-10-16T15:23:39Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We have now merged PR #134, and @SpencerDawkins thinks that we need to uplevel to talk about how we expect QUIC stacks, especially at the other end of a RoQ connection, to Do The Right Thing for media. We have had many ideas, and none have achieved consensus.\r\n\r\n- \"turn off QUIC congestion control and do everything in RTP\" - this was rejected for excellent reasons\r\n- \"allow RoQ to configure QUIC congestion control\" - at a high level, not like picking algorithms\r\n- \"use a different ALPN that says \"this is RoQ, so Do The Right Thing\" - this is [in the draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an) now\r\n- \"assume that QUIC implementations that attempt to prevent increasing one-way delays for any QUIC traffic will work for media, that wants that, too\" - if that's a plan, we should probably check with the QUIC working group if that's what they think, too\r\n\r\n@SpencerDawkins thinks leaving this vaguely specified is a problem. I'm tagging this For Discussion, with IETF 118 coming up in a couple of weeks, to see whether we can make progress. ",
          "createdAt": "2023-10-23T15:38:15Z",
          "updatedAt": "2023-10-23T15:38:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> We have now merged PR #134, and @SpencerDawkins thinks that we need to uplevel to talk about how we expect QUIC stacks, especially at the other end of a RoQ connection, to Do The Right Thing for media. We have had many ideas, and none have achieved consensus.\r\n\r\nI don't think we necessarily need the other end to cooperate on this much. If the other end is receiving media, it needs to give the correct feedback so that the sending end can do the right thing. The feedback may require timestamps, but that would be negotiated via transport parameters. Either timestamps are available or not. No need to negotiate beyond what a potential timestamp extension would specify, anyway.\r\n\r\n>     * \"allow RoQ to configure QUIC congestion control\" - at a high level, not like picking algorithms\r\n\r\nI think RoQ application developers need to choose the right QUIC implementation and congestion controller to use for _sending_ media.\r\n\r\n>     * \"use a different ALPN that says \"this is RoQ, so Do The Right Thing\" - this is [in the draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an) now\r\n\r\nThe ALPN section is there for a different reason, it is not required for congestion control, but because QUIC requires application protocols to use ALPN (or equivalent mechanisms, see [Section 7 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#name-cryptographic-and-transport) and [Section 8.1 of RFC 9001](https://www.rfc-editor.org/rfc/rfc9001.html#name-protocol-negotiation)).\r\n\r\n>     * \"assume that QUIC implementations that attempt to prevent increasing one-way delays for any QUIC traffic will work for media, that wants that, too\" - if that's a plan, we should probably check with the QUIC working group if that's what they think, too\r\n\r\nI think this is what the draft assumes, but I agree that it is probably a good idea to get more input on this (maybe from the QUIC WG, CCWG, or even ICCRG?).",
          "createdAt": "2023-10-24T13:04:52Z",
          "updatedAt": "2023-10-24T13:04:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - on this ...\r\n\r\n> I don't think we necessarily need the other end to cooperate on this much. If the other end is receiving media, it needs to give the correct feedback so that the sending end can do the right thing. The feedback may require timestamps, but that would be negotiated via transport parameters. Either timestamps are available or not. No need to negotiate beyond what a potential timestamp extension would specify, anyway.\r\n\r\nI agree on this (so far, modulo the sending end knowing what the right thing to do is), but keep reading. ",
          "createdAt": "2023-11-01T23:06:42Z",
          "updatedAt": "2023-11-01T23:06:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart -\r\n\r\n> I think **RoQ application developers need to choose the right** QUIC implementation and **congestion controller** to use for sending media.\r\n\r\nThat's the challenge - especially if the QUIC implementation isn't tightly coupled with the application. Maybe we can say that RoQ application developers need to watch for this carefully? ",
          "createdAt": "2023-11-01T23:10:29Z",
          "updatedAt": "2023-11-01T23:10:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> The ALPN section is there for a different reason, it is not required for congestion control, but because QUIC requires application protocols to use ALPN (or equivalent mechanisms, see [Section 7 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#name-cryptographic-and-transport) and [Section 8.1 of RFC 9001](https://www.rfc-editor.org/rfc/rfc9001.html#name-protocol-negotiation)).\r\n\r\nUnderstood. The problem is that we've been thinking that we needed to do something other than just trusting the QUIC implementation to Do The Right Thing for media, and if we are using a different APLN for media, it's easy for people to conflate choosing an application instance for media with choosing an application instance that will Do The Right Thing for media. \r\n\r\nI suspect the best way for us to handle this is actually saying something like \r\n\r\n> This document relies on the assumption that QUIC implementations will attempt to prevent increasing one-way delays when sending **any** QUIC traffic, and this will meet the needs of RTP over QUIC\".\r\n\r\nDoes that make sense?",
          "createdAt": "2023-11-01T23:22:52Z",
          "updatedAt": "2023-11-01T23:22:52Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm late here , sorry, and still playing catchup. I don't think I have all of the context of RoQ paged in but from this ticket, there's something about the discussion of expectations (or setting of expectations) on QUIC implementations that doesn't quite sit right with me. \r\n\r\nThis ticket is titled \"Are real-time congestion controllers tied to RTP or usable in QUIC stacks?\" yet Spencer asks some different questions. That feels, to me, a bit like \"are electric hybrids tied to gasoline or usable in 3 phase? we need to uplevel to conversations about how efficiently divers lift and coast\"\r\n\r\nI need some more time to digest but endevour to provide a better response than this one.",
          "createdAt": "2023-11-02T00:42:51Z",
          "updatedAt": "2023-11-02T00:42:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @LPardue - \r\n\r\nThanks for popping in here. \r\n\r\n> I'm late here , sorry, and still playing catchup. I don't think I have all of the context of RoQ paged in but from this ticket, there's something about the discussion of expectations (or setting of expectations) on QUIC implementations that doesn't quite sit right with me.\r\n\r\nYou are not alone. :thinking: I feel your pain (and confusion). \r\n\r\n> This ticket is titled \"Are real-time congestion controllers tied to RTP or usable in QUIC stacks?\" yet Spencer asks some different questions. That feels, to me, a bit like \"are electric hybrids tied to gasoline or usable in 3 phase? we need to uplevel to conversations about how efficiently divers lift and coast\"\r\n\r\nMy apologies for incoherence when when adding my most recent comments in the issue. AVTCORE/RoQ has moved a LONG way from early discussions, where people who talked to us were expecting RoQ endpoints to disable QUIC congestion control (**\"whut?\"** :raised_eyebrow: :roll_eyes:) and require specific congestion controllers in the spec. \r\n\r\nMy list upthread (which @mengelbart was responding to) was trying to capture the various places we've been, and make sure that we're all in one place now. \r\n\r\nI **THINK** we're now here: \r\n\r\n> This document relies on the assumption that QUIC implementations will attempt to prevent increasing one-way delays when sending any QUIC traffic, and this will meet the needs of RTP over QUIC\"\r\n\r\nand I **THINK** @mengelbart agrees with that, so let's focus on that point, for now. BUT ...\r\n\r\n> I need some more time to digest but endevour to provide a better response than this one.\r\n\r\n... please don't endeavor too hard **right now** - @mengelbart and I have been around and around on this topic, and we're still working on the questions we are going to ask the working group during the AVTCORE session on Wednesday. Can you hold off a bit, while we finalize our slides, and then I'll update the issue and see if **I** can do better?",
          "createdAt": "2023-11-02T16:03:46Z",
          "updatedAt": "2023-11-02T16:04:51Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are low latency CC algorithms currently integrated into QUIC stacks, including: \r\n\r\n1. COPA:  See:  https://engineering.fb.com/2019/11/17/video-engineering/copa/\r\n2. L4S. See: https://developer.apple.com/documentation/network/testing_and_debugging_l4s_in_your_app\r\n\r\n\r\n\r\n",
          "createdAt": "2023-11-06T07:10:27Z",
          "updatedAt": "2023-11-06T07:10:27Z"
        },
        {
          "author": "pthatcher",
          "authorAssociation": "NONE",
          "body": "Another impl of COPA: https://github.com/Tencent/tquic/blob/develop/src/congestion_control/copa/copa.rs",
          "createdAt": "2023-11-08T09:27:06Z",
          "updatedAt": "2023-11-08T09:27:06Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @pthatcher - thank you both for the helpful information!",
          "createdAt": "2023-11-08T09:47:20Z",
          "updatedAt": "2023-11-08T09:47:20Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOFUmh7s5mDuup",
      "title": "List all QUIC extensions documents that might be useful for RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/92",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF117"
      ],
      "body": "RoQ does not require any QUIC extensions, but there are a few extension documents referenced in the document, and it would be helpful to have a complete list of extensions that might be useful for RoQ. The list should include the timestamp draft(s) and the ENOUGH frame and maybe more.",
      "createdAt": "2023-05-16T15:26:17Z",
      "updatedAt": "2023-07-23T20:53:13Z",
      "closedAt": "2023-07-23T20:53:13Z",
      "comments": []
    },
    {
      "number": 93,
      "id": "I_kwDOFUmh7s5mLgfc",
      "title": "Using streams, datagrams, and per-RTP-frame streams with RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/93",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "We may need a short section explaining the ROQ-specific tradeoffs",
      "createdAt": "2023-05-17T16:52:12Z",
      "updatedAt": "2023-09-15T15:07:17Z",
      "closedAt": "2023-09-15T15:07:17Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba asked if a sender had any restrictions on using streams, per-frame streams, and datagrams. I agree and think we should explicitly say something (\"silence is permission\"), and also consider interactions.",
          "createdAt": "2023-07-27T22:47:14Z",
          "updatedAt": "2023-07-27T22:47:14Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I asked the question in the context of Peter's SDP negotiation slide, in which it wasn't clear what UDP/QUIC/RTP/AVPF meant exactly. For example, would an Answerer receiving this in the Offer interpret it to mean that it needs to be willing receive RTP over streams, datagrams and some mixture of both? Or is there a way for an Offerer to indicate that only requires the Answerer to support a subset of all potential transport modes (e.g. reliable streams OR datagrams).\n\nNote that in the same discussion we also talked about multiplexing, specifically whether \"a=mid\" referred to the SDES/MID RTP header extension or to a QUIC multiplexing-ID. I think raises the question about what BUNDLE over QUIC looks like. ",
          "createdAt": "2023-07-28T00:46:47Z",
          "updatedAt": "2023-07-28T00:49:46Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - so, I think the last time we had a meaningful conversation about SDP for RoQ in AVTCORE was at IETF 115, and I used slides in the [combined slide deck](https://datatracker.ietf.org/meeting/115/materials/slides-115-avtcore-ietf-115-avtcore-wg-03). Check out slide 53, but we definitely talked about \r\n\r\n> \u201cstream/\u201d, \u201cdgram/\u201d and \u201c/shared\u201d prepended to UDP/QUIC/RTP/AVPF\r\n\r\nSo, yes, it isn't clear what UDP/QUIC/RTP/AVPF meant exactly. :wink: :innocent:\r\n\r\nI got sufficiently strong pushback on trying to maintain the SDP draft while we were still figuring out how RoQ would work, that I dropped that draft to work with @mengelbart and @joerg-ott on the RoQ draft, so that I wasn't just annoying the working group with requests for unnecessary adoption polls. \r\n\r\nI'm fine to pick up that work when you and @JonathanLennox think RoQ is stable enough to allow a successful adoption poll for an SDP draft, but in the meantime, you might want to remind presenters who include SDP in their slides, that which AVP profiles will be registered was still an active question in the working group, the last time we talked about that. ",
          "createdAt": "2023-09-01T11:52:20Z",
          "updatedAt": "2023-09-01T11:52:20Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "While working on a PR for this issue, I noticed the following text in [Section 3 of RFC 9221](https://datatracker.ietf.org/doc/html/rfc9221#name-transport-parameter):\r\n\r\n> Application protocols that use datagrams **MUST** define how they react to the absence of the max_datagram_frame_size transport parameter. If datagram support is integral to the application, the application protocol can fail the handshake if the max_datagram_frame_size transport parameter is not present.\r\n\r\nI don't think this belongs in a subsection of Section 3 in the RoQ draft, but we do need to do it, and we should talk about what the behavior should be before we add this to the draft (probably in [Section 4 of the draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an). I'm adding issue #122 so we don't forget. ",
          "createdAt": "2023-09-01T14:46:47Z",
          "updatedAt": "2023-09-01T14:46:47Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDOFUmh7s5mUaiC",
      "title": "Add header extensions to RTCP analysis",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/95",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "In #71 we added a section about header extensions to the RTCP analysis, but it does not include a table of all header extensions we considered. I think it makes sense to add one, just like we did for the RTCP packets, too.",
      "createdAt": "2023-05-19T05:17:31Z",
      "updatedAt": "2023-07-23T23:03:44Z",
      "closedAt": "2023-07-23T23:03:44Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "I_kwDOFUmh7s5q87Zq",
      "title": "Reference new CLOSE_STREAM draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/103",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-07T21:10:36Z",
      "updatedAt": "2023-07-23T23:01:18Z",
      "closedAt": "2023-07-23T23:01:18Z",
      "comments": []
    },
    {
      "number": 104,
      "id": "I_kwDOFUmh7s5rGQIx",
      "title": "Add @spencerdawkins as co-author",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/104",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T13:35:33Z",
      "updatedAt": "2023-07-10T19:42:09Z",
      "closedAt": "2023-07-10T19:42:09Z",
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDOFUmh7s5r5MRf",
      "title": "Clean up introduction of \"RTP over QUIC\" and \"RoQ\" terms in the draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/107",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "ISTM that \"RTP over QUIC\" and \"RoQ\" should appear in the Abstract and Introduction, but neither does, and we don't actually say that we're going to be referring to \"RTP over QUIC\" as \"RoQ\" in the document. ",
      "createdAt": "2023-07-18T15:21:14Z",
      "updatedAt": "2023-07-23T21:01:52Z",
      "closedAt": "2023-07-23T21:01:51Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "We have the following in the introduction:\r\n\r\n> The mapping described in this document is called RTP over QUIC (RoQ).\r\n\r\nBut adding it to the abstract might be good, too.",
          "createdAt": "2023-07-18T16:04:08Z",
          "updatedAt": "2023-07-18T16:04:08Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDOFUmh7s5sTJgO",
      "title": "Check SHOULD requirements for ROQ receivers ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/111",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "This is probably premature, but I noticed \r\n\r\n> To send RTP/RTCP packets over QUIC streams, a sender MUST open a\r\n> new unidirectional QUIC stream. Streams are unidirectional because there is no\r\n> synchronous relationship between sent and received RTP/RTCP packets. A peer that\r\n> receives a bidirectional stream with a flow identifier that is associated with\r\n> an RTP or RTCP stream, **SHOULD** stop reading from the stream and send a\r\n> STOP\\_SENDING frame with the application protocol error code set to\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR.\r\n\r\nAs I noted in comments on PR #91, that's a fundamental violation of the protocol (\"MUST open a new unidirectional QUIC stream\"). If that's a MUST, ISTM that we need to either make detecting bidirectional ROQ connections a MUST, or explain what would be likely to happen if the receiver just decides to read from the stream and - what - never write to it? or start writing to it, in spite of the stream violating the protocol? \r\n\r\nBut this is actually just a reminder that we need to look at SHOULDs for receivers, and make sure that it makes sense for a receiver to ignore the SHOULD action, and explain at least some of the likely consequences if the receiver does so. \r\n\r\nAs long as we're still writing significant normative text, it may make sense to wait and check all the SHOULDs at once, later in the process. As long as we don't forget. ",
      "createdAt": "2023-07-23T02:14:16Z",
      "updatedAt": "2023-10-23T15:17:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 112,
      "id": "I_kwDOFUmh7s5szNHB",
      "title": "RESET_STREAM and media dependencies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/112",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "wontfix",
        "NextInterim",
        "Discussion required"
      ],
      "body": "STOP_SENDING/RESET_STREAM currently does not allow sending media frames on a new QUIC stream if they were previously sent on a QUIC stream that received STOP_SENDING/RESET_STREAM. We need to figure out if that is a problem if there are dependencies between those media frames.",
      "createdAt": "2023-07-27T23:20:10Z",
      "updatedAt": "2023-10-16T14:50:49Z",
      "closedAt": "2023-10-16T14:50:49Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Consider the following scenario: A sender sends a group of pictures consisting of media frames A, B and C, where A is a keyframe, B depends on A, and C depends on B:\r\n\r\n`A <- B <- C`\r\n\r\nThe sender starts sending frames A and B on QUIC stream 1 but receives STOP_SENDING before it can send frame C. According to the draft (and RFC 9000), it now has to send RESET_STREAM on QUIC stream 1 and continue to send frame C on a different QUIC stream. Additionally, it MUST NOT retransmit frames A or B on *any* QUIC stream. If A or B was lost, sending frame C does not make sense since the receiver cannot decode it.\r\n\r\nSome options are:\r\n\r\n* Drop C and continue with the next frame that is decodable independently from A and B (and C)\r\n  * Problem: may unnecessarily drop frames\r\n* Send C as an independently decodable frame\r\n  * may not always be possible because it depends on interaction with the encoder.\r\n* Allow dependencies to be retransmitted on different streams\r\n  * Problem: Potentially results in situations where the receiver asks to stop, but the sender continues sending the same frames anyway, just on different QUIC streams.\r\n\r\n*Side note:* The real problem here is the receiver sending STOP_SENDING without knowing what trouble it is causing the sender. Maybe receivers should not try to be smart about what they read from streams and where to stop.\r\n\r\n*Comments on CLOSE_STREAM and ENOUGH:* These would enable the sender and receiver to agree on where exactly the receiver can stop reading from the current QUIC stream. We could then allow the sender to send everything following that offset on a different QUIC stream. However, we still have to solve the problem regarding STOP_SENDING.\r\n",
          "createdAt": "2023-09-15T10:37:17Z",
          "updatedAt": "2023-09-15T10:37:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "As of this moment, [Reliable QUIC Stream Resets](https://datatracker.ietf.org/doc/draft-ietf-quic-reliable-stream-reset/) is an adopted QUIC WG draft, and [Signaling That a QUIC Receiver Has Enough Stream Data](https://datatracker.ietf.org/doc/draft-thomson-quic-enough/) is still individual, but our understanding from @marten-seemann is that ENOUGH may be included in [Reliable QUIC Stream Resets](https://datatracker.ietf.org/doc/draft-ietf-quic-reliable-stream-reset/).",
          "createdAt": "2023-09-15T15:19:11Z",
          "updatedAt": "2023-09-15T15:19:11Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "@SpencerDawkins' understanding is correct, in fact, we have a PR that adds ENOUGH: https://github.com/quicwg/reliable-stream-reset/pull/26.\r\n\r\nHowever, at this point, it's not decided yet if this PR will get merged. I just sent an email to the QUIC and AVT mailing list, and it would be useful to discuss potential use cases for the frame there.",
          "createdAt": "2023-10-10T06:13:59Z",
          "updatedAt": "2023-10-10T06:13:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "A related issue for the CLOSE_STREAM/ENOUGH discussion is #113 . \r\n\r\nAs commented on the AVTCORE in QUIC mailing lists yesterday, I don't expect ENOUGH to be useful for RoQ, because it only allows a receiver to keep reading old frames while dropping newer ones, which doesn't seem useful in a real-time streaming application.\r\n\r\nAs discussed in the last interim meeting, it is the application's responsibility to figure out what to do in case a dependency of a frame is dropped with STOP_SENDING. I suggest labeling this issue as won't fix and closing it. ",
          "createdAt": "2023-10-11T09:28:08Z",
          "updatedAt": "2023-10-11T09:28:08Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins agrees with @mengelbart, that these mechanisms make great sense for reliable application streams (where you want to retransmit as little as possible, but with no gaps), but less sense for unreliable applications like RTP (where you want to see the newest media frames, and don't care about gaps). We can close this as \"wontfix\". ",
          "createdAt": "2023-10-16T14:50:49Z",
          "updatedAt": "2023-10-16T14:50:49Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "I_kwDOFUmh7s5szWt-",
      "title": "Given that we are doing STOP\\_SENDING, do we need CLOSE\\_STREAM?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/113",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "wontfix",
        "Not Yet",
        "external doc",
        "Discussion required"
      ],
      "body": "Assuming that CLOSE|_STREAM moves forward ...",
      "createdAt": "2023-07-27T23:56:46Z",
      "updatedAt": "2023-10-11T14:02:42Z",
      "closedAt": "2023-10-11T14:02:41Z",
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDOFUmh7s5szXzF",
      "title": "Reality check on RoQ DATAGRAM use, especially for RoQ over WebTransport",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/114",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "question",
        "Discussion required"
      ],
      "body": "@SpencerDawkins and @mengelbart sait through some really interesting discussion at WEBTRAN about pooled connections ...",
      "createdAt": "2023-07-28T00:00:44Z",
      "updatedAt": "2023-10-23T17:02:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The slides for that discussion are [here](https://datatracker.ietf.org/meeting/117/materials/slides-117-webtrans-ietf-117-webtrans-wg-slides-02), starting with slide 9. ",
          "createdAt": "2023-09-01T15:49:43Z",
          "updatedAt": "2023-09-01T15:49:43Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins thinks we moved automatically to supporting both QUIC streams and QUIC datagrams in RoQ, and he isn't sure whether support for QUIC datagrams is necessary, given the amount of complexity this introduces in the specification. We should be asking (on the mailing list and at IETF 118) whether support for QUIC datagrams as transport is useful, and whether it would allow application developers to do something they can't do with QUIC streams. \r\n\r\nIMO, of course ... :yum:",
          "createdAt": "2023-10-16T15:10:09Z",
          "updatedAt": "2023-10-16T15:10:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The questions we have for the working group are\r\n\r\n1. Do we know that people are planning to use RoQ with QUIC DATAGRAMs? \r\n2. (With @aboba in the room) Do we know that people are **hoping** to use RoQ with QUIC DATAGRAMs in WebTransport? ",
          "createdAt": "2023-10-23T15:14:27Z",
          "updatedAt": "2023-10-23T15:14:27Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "We (BBC) have an ambition to support transparent tunnelling of existing UDP RTP flows via a RoQ-supporting RTP Mixers/Translators to extend existing RTP workflows, and I'm envisioning doing this over DATAGRAMs to give the smallest possible processing overhead. I'm actually gearing up to do some practical work to try and measure whether there's any practical differences in the approaches, but I don't envision having results by IETF 118 (and I can't make the meeting anyway).\r\n\r\nThis is all not using WebTransport, as it'll be on embedded devices without a browser.",
          "createdAt": "2023-10-23T15:54:01Z",
          "updatedAt": "2023-10-23T15:54:01Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @samhurst,\r\n\r\nThank you for the feedback on this!\r\n\r\n> We (BBC) have an ambition to support transparent tunnelling of existing UDP RTP flows via a RoQ-supporting RTP Mixers/Translators to extend existing RTP workflows, and I'm envisioning doing this over DATAGRAMs to give the smallest possible processing overhead.\r\n\r\nThis is very useful - I think there are at least a few other people who are considering this at a high level, for the reasons you mention. That said, \r\n\r\n> I'm actually gearing up to do some practical work to try and measure whether there's any practical differences in the approaches, \r\n\r\nThis is exactly (IMO) what we need to know - whether the conceptual advantages of using DATAGRAMs provides actual benefits over using QUIC streams, especially in some of the creative ways that we're trying to describe in [Section 3.1](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-rtp-with-quic-streams-quic-)  of the current editor's version. \r\n\r\n> but I don't envision having results by IETF 118 (and I can't make the meeting anyway).\r\n\r\n@mengelbart and I just labeled this issue Discussion Required, which means that we'll have a slide about it at IETF 118, but we're doing that to make progress, which in this case probably means that we're asking people with (informed) opinions, like yours, to say something, so we know how much the draft needs to say about RoQ with QUIC DATAGRAMs. \r\n\r\nIf other people have results, especially results they can share, explain, and answer questions about, I'll be pleased and impressed, but we wouldn't expect anyone to be able to provide results in the IETF 118 timeframe. \r\n\r\nBecause we'll have a slide on this, would you like for us to say this is something you're pursuing, and invite other people who are also pursuing this work with you? That could speed things up, or slow them down, but I wanted whether we ask the question to be helpful for you. \r\n\r\n> This is all not using WebTransport, as it'll be on embedded devices without a browser.\r\n\r\nThat's also good to know. Again, thank you for popping up - it's always helpful!",
          "createdAt": "2023-10-23T17:02:04Z",
          "updatedAt": "2023-10-23T17:02:29Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "I_kwDOFUmh7s5tz1Ty",
      "title": "Motivation: Exploiting Multiple Connections",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/115",
      "state": "OPEN",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim",
        "Current Focus"
      ],
      "body": "Pasting the original text with some suggestions inline: \r\n\r\n1.2.6.  Exploiting Multiple Connections **[Migrating between multiple paths. Mention paths and not connections]**\t \t\t\r\n \t\t\r\n   Although there is much interest in multiplexing flows on a single\t \t\t\r\n   QUIC connection as described in Section 1.2.5, QUIC also provides the\t \t\t\r\n   capability of establishing and validating multiple paths for a single\t \t\t\r\n   QUIC connection [RFC9000].  Once multiple paths have been validated,\t \t\t\r\n   a sender can migrate from one path to another with no additional\t \t\t\r\n   signaling, allowing an endpoint to move from one endpoint address to\t \t\t\r\n   another without interruption, as long as only a single path is in\t \t\t\r\n   active use at any point in time.\t \t\t\r\n \t\t\r\n   Connection migration may be desireable for a number of reasons, but\t \t\t\r\n   to give one example, this allows a sender to distinguish between more\t \t\t\r\n   costly cellular paths and less costly WiFi paths, with no action\t \t\t\r\n   required from the application. **[RTP applications do need to know about path used being expensive/not since the application  may want to use a lower bitrate cap for an expensive path like cellular. So some action will be required from the application possibly at connection setup time to specify the caps in wants to use for each interface type]** ",
      "createdAt": "2023-08-09T01:18:02Z",
      "updatedAt": "2023-10-23T15:04:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We think this is a useful comment, but we want to make sure that the new text doesn't contradict other text that says the application doesn't need to do anything. \r\n\r\n@SpencerDawkins thinks this comment is opening up at least two interesting areas that we need to think about: \r\n\r\n- policy for path selection, and \r\n- API for RTP over QUIC. \r\n\r\nFor the policy question, we need to think about how the use case @gchandok describes maps onto QUIC connection migration and multipath QUIC. \r\n\r\nFor the API, @mengelbart was testing with QUIC-GO, which at that time didn't support connection migration. Current implementations seem to give applications more control over connection handling, so we need to investigate further. \r\n\r\nWe will keep these ideas here for now, but may need to open new issues in the (near) future. ",
          "createdAt": "2023-08-11T15:32:28Z",
          "updatedAt": "2023-08-11T15:32:28Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDOFUmh7s5tz2Xx",
      "title": "Reasoning for not mandating a rate adaptation algorithm",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/116",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "\r\n\r\nA rate adaptation algorithm can be plugged in to adapt the media\r\n    bitrate to the available bandwidth.  This document does not mandate\r\n|   any specific rate adaptation algorithm, _because the desired response\r\n|   to congestion can be application and codec-specific.  For example,\r\n|   adjusting quantization in response to congestion may work well in\r\n|   many cases, but if what's being shared is video that includes text,\r\n|   maintaining readability is important._\r\n|\r\n|   As of this writing, the IETF has produced two Experimental-track rate\r\n|   adaptation specifications, Network-Assisted Dynamic Adaptation (NADA)\r\n|   [RFC8698] and Self-Clocked Rate Adaptation for Multimedia (SCReAM)\r\n|   [RFC8298]. \r\n\r\n\r\n**Rate adaptation mechanisms like NADA/SCREAM don\u2019t necessarily mandate how the encoder handles the rate changes. That handling may be codec specific so makes sense to leave it out. So the argument and example (in italics) don\u2019t seem appropriate in this section. Rate adaptation mechanism RFCs you mention above talk about how the sending rate should be computed, what feedback is needed and how traffic should be paced / shaped which are not codec specific. You can just say that application may pick a rate adaptation mechanism of its choice and this document does not mandate it. That should be sufficient**",
      "createdAt": "2023-08-09T01:24:54Z",
      "updatedAt": "2023-09-15T15:08:44Z",
      "closedAt": "2023-09-15T15:08:44Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@gchandok - let me take a look at this. I think it's useful to say something about why we wouldn't mandate ANY rate adaptation algorithm, but if I can't come up with better text, I agree that confusing text as currently isn't useful ... ",
          "createdAt": "2023-08-11T15:14:11Z",
          "updatedAt": "2023-08-11T15:14:11Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@gchandok - I've now taken a look at this, and I think our problem is that I am conflating two things that need to be described separately - the response that an application takes to adjust the encoded media stream it sends, and the mechanism that an application uses to decide how to send it. I think both of these are important to mention, but they are two different things, and need to be explained in a way that clearly distinguishes between them. \r\n\r\nI'm working on a PR for this ... ",
          "createdAt": "2023-09-01T10:21:06Z",
          "updatedAt": "2023-09-01T10:21:06Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDOFUmh7s5tz2lx",
      "title": "Suppressing QUIC signaling in favor of RTCP signaling",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/117",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "Because QUIC relies on certain frames being sent, it is\r\n   not possible to supress QUIC signaling in favor of RTCP signaling,\r\n\r\n**In Datagram mode, QUIC flow control and retransmissions are disabled. Also, this draft allows for congestion control to live in the application. So in this situation we should consider disabling ACK frames in the QUIC layer. What function do they provide? Those are probably the most common non-data frames that will be sent at quic layer**",
      "createdAt": "2023-08-09T01:26:16Z",
      "updatedAt": "2023-09-25T16:22:37Z",
      "closedAt": "2023-09-25T16:22:37Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins and @mengelbart are thinking about this, but we THINK there is some level of QUIC signaling that is required in order to look like a working QUIC connection. \r\n\r\n@SpencerDawkins is also remembering that there is a minimal level of RTCP RR reporting that is required for an RTP application to know that the (stateless) RTP session is still active. \r\n\r\nWhat we NEED to do, is make text about disabling/suppressing/whatever QUIC acks/congestion control and RTCP RR reporting match these two realities. \r\n\r\n@gchandok's observation about congestion control living in the application is important. We should also make sure that the implications that we describe are accurate. ",
          "createdAt": "2023-08-11T15:40:32Z",
          "updatedAt": "2023-08-11T15:40:32Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm talking about this issue with @mengelbart, and we think what's needed is a lot more nuanced than \"turning RTCP feedback off\" or \"turning QUIC feedback and related flow control/congestion control off\", but we don't think this is a lot of work. We can target the September virtual interim for PR text. ",
          "createdAt": "2023-09-01T15:13:59Z",
          "updatedAt": "2023-09-01T15:13:59Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "While the application can control rate, congestion control is handled by QUIC and can't be safely turned off.",
          "createdAt": "2023-09-03T11:20:18Z",
          "updatedAt": "2023-09-03T11:20:18Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDOFUmh7s5tz2uh",
      "title": "Carrying SR NTP Timestamps at QUIC layer",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/118",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "_SR_ NTP timestamps: We cannot send NTP timestamps in the same\r\n      format the SRs use, but couldn't a QUIC timestamp extension\r\n      provide the same information?\r\n\r\n**SR really carries an RTP timestamp to NTP time mapping that is required for lip sync. This cannot solely be provided at the QUIC layer since it does not know about RTP timestamps**",
      "createdAt": "2023-08-09T01:27:07Z",
      "updatedAt": "2023-09-22T07:46:10Z",
      "closedAt": "2023-09-22T07:46:10Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We think the action here is to remove the editor's note and clarify that QUIC signaling can't replace this, even with a timestamp extension. ",
          "createdAt": "2023-08-11T15:16:42Z",
          "updatedAt": "2023-08-11T15:16:42Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "I_kwDOFUmh7s5v6VrN",
      "title": "Define how RoQ reacts to the absence of max_datagram_frame_size transport parameter",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/122",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF118",
        "Current Focus"
      ],
      "body": "While working on a PR for Issue #93 I noticed the following text in [Section 3 of RFC 9221](https://datatracker.ietf.org/doc/html/rfc9221#name-transport-parameter):\r\n\r\n> Application protocols that use datagrams **MUST** define how they react to the absence of the max_datagram_frame_size transport parameter. If datagram support is integral to the application, the application protocol can fail the handshake if the max_datagram_frame_size transport parameter is not present.\r\n\r\nI don't think this belongs in a subsection of [Section 3 in the RoQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-protocol-overview), but we do need to do it, and we should talk about what the behavior should be before we add this to the draft (probably in [Section 4 of the ROQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an).",
      "createdAt": "2023-09-01T14:45:59Z",
      "updatedAt": "2023-10-23T14:27:50Z",
      "closedAt": "2023-10-23T14:27:50Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #13 ",
          "createdAt": "2023-09-01T15:29:59Z",
          "updatedAt": "2023-09-01T15:29:59Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart reminds me that including the max_datagram_frame_size transport parameter is how QUIC negotiates support for datagrams, so this issue is even more closely related to #13 than @SpencerDawkins thought ... :zany_face:\r\n\r\nWhat we are thinking is that we can't fail connection establishment because the max_datagram_frame_size transport parameter isn't specified, unless we know from signaling that the application intends to use datagrams, so we need to say that clearly in the draft, and then we have met the MUST defined in [Section 3 of RFC 9221](https://datatracker.ietf.org/doc/html/rfc9221#name-transport-parameter).",
          "createdAt": "2023-09-01T15:41:40Z",
          "updatedAt": "2023-09-01T15:41:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We note that the description of the decisions a RoQ receiver must make goes in [Section 3 in the RoQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-protocol-overview), but the errors if datagrams are signaled but not negotiated goes in [Section 4 of the ROQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an) ",
          "createdAt": "2023-09-01T16:04:25Z",
          "updatedAt": "2023-09-01T16:04:25Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This is actually already explained in [section 5.3](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-5.3). We could also add it to the connection establishment section, although I'm not sure if that is really necessary. I don't think we need to add this detail to the protocol overview in section 3.",
          "createdAt": "2023-10-11T12:48:31Z",
          "updatedAt": "2023-10-11T12:48:31Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins notes that this is close enough to #13 that it could have been a duplicate. Even if it's not a duplicate, we can probably close both with one PR. ",
          "createdAt": "2023-10-16T14:55:17Z",
          "updatedAt": "2023-10-16T14:55:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins notes that he has apparently gotten lost on the original point for this (non- #13) point:\r\n\r\n> **Application protocols that use datagrams MUST define how they react** to the absence of the max_datagram_frame_size transport parameter. If datagram support is integral to the application, the application protocol can fail the handshake if the max_datagram_frame_size transport parameter is not present.\r\n\r\nThat is to say, it would be helpful to \r\n\r\n- point out that you can \"hope\" to use datagrams,\r\n- and even offer/answer that you want to use datagrams, \r\n- but if you don't negotiate the use of datagrams in the QUIC handshake, you've got some choices to make. \r\n\r\nWe do give a hint about this, in the current text:\r\n\r\n> If the use of an extension was signaled using a signaling protocol, but the extension was not negotiated during the QUIC handshake, a peer MAY close the connection with the ROQ_EXPECTATION_UNMET error code.\r\n\r\nBut then there's the question, what might the peer do **next**? \r\n\r\nI'll work on a PR for **that**. ",
          "createdAt": "2023-10-19T00:02:45Z",
          "updatedAt": "2023-10-19T00:08:52Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOFUmh7s5xyb2x",
      "title": "Review Appendix B for completeness",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/126",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim",
        "Discussion required"
      ],
      "body": "We have a lot of information in [Appendix B.  Considered RTCP Packet Types and RTP Header Extensions](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-list-of-optional-quic-exten), and it looks like we might have some missing table entry details, such as \r\n\r\n> Texas Instruments Extended VoIP Quality Block | | | |\r\n\r\nI see that one has a reference in the IANA registry that returns a 404, but we might want to say that in the table, just so readers know we didn't miss anything they need to know. And @joerg-ott is the designated expert for that registry - we should probably ask him how to report the 404, in case he has a better idea where to look than the current reference! :grin:\r\n\r\nAlso, it would be good for us to point to relevant IANA registries at the beginning of each section (for example, [RTP Control Protocol Extended Reports (RTCP XR) Block Type Registry](https://www.iana.org/assignments/rtcp-xr-block-types/rtcp-xr-block-types.xhtml).\r\n\r\n[B.5.1. Compact Header Extensions](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-sdes-compact-header-extensi) has several \"probably not(?)\" entries. Is this just because we haven't looked closely at the 3GPP specifications yet? We should probably look at that - RTP over QUIC should be relevant to 3GPP in the next 5G release or two. ",
      "createdAt": "2023-09-22T14:44:18Z",
      "updatedAt": "2023-10-23T15:04:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 127,
      "id": "I_kwDOFUmh7s5x3YVR",
      "title": "Normative References",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/127",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "From the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/WH8OTXO7LT8IQzxPh2QwfeGVcF0/\r\n\r\nWith the QUIC specifications still evolving, this specification is put in a difficult position.  Beyond the basic QUIC specifications, there are extensions which could be of potential benefit.  However, some of the extensions are not yet WG work items, or are not widely deployed, or may take some time to be published as RFCs, or may never be published as RFCs.\r\n\r\nCurrently, the document has an Appendix A: List of Optional QUIC extensions, which states \"The following is a list of QUIC protocol extensions that might be beneficial for RoQ, but are not required by RoQ.\" Putting discussion of non-RFC QUIC extensions into a (non-normative) Appendix seems like a good idea, if it could allow the main specification to focus on the core QUIC functionality and avoid normative references to documents which may or may not ever be published as RFCs.\r\n\r\nHowever, the problem is that discussion of the extensions is not limited to the (non-normative) Appendix, but is contained in other sections, including Sections 7, 7.3.4 and 8.1.\r\n\r\nThis results in normative references to [I-D.draft-huitema-quic-ts], [I-D.draft-ietf-quic-ack-frequency] and [I-D.draft-smith-quic-receive-ts]. \u00b6\r\n\r\nI would like to suggest that the RTP over QUIC specification be restructured so as to only normatively reference documents which have been published as RFCs.\r\n\r\nFor this to work, material in Sections 6, 7 and 8 may need to be moved to Appendix A, which would presumably avoid normative references.",
      "createdAt": "2023-09-24T19:00:32Z",
      "updatedAt": "2023-10-23T14:12:44Z",
      "closedAt": "2023-10-23T14:12:43Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - I have what I hope is a friendly amendment to this proposal:\r\n\r\n> I would like to suggest that the RTP over QUIC specification be restructured so as to only normatively reference documents which have been published as RFCs.\r\n\r\nI don't think limiting ourselves to published RFCs is quite right, but it's a step in the right direction. \r\n\r\nI think moving helpful commentary about things that might be done into appendices is a step in the right direction. This would include the observations we make about timestamps, etc. \r\n\r\nI think we might have exceptions to \"only published RFCs\" for drafts that are \r\n\r\n- adopted by QUIC or a similar WG, or \r\n- adopted and considered mature enough to wait for, or\r\n- past WGLC and somewhere in the publication requested/approved state machine. \r\n\r\nDoes that make sense?\r\n\r\nAssuming so, Mathis will propose a linked PR that moves what we think needs to be moved into appendices, and we'll talk, OK?",
          "createdAt": "2023-10-09T14:49:29Z",
          "updatedAt": "2023-10-09T14:49:29Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "I_kwDOFUmh7s5x3kLt",
      "title": "Congestion Control and Rate Control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/128",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "From the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/7IFLBJAmFbB3f1_OgkoPyN0lhT8/\r\n\r\nLooking over the coverage of Congestion Control and Rate Control, the two\r\ntopics appear to be conflated in places and also there appear to be some issues that\r\nhave not been fully considered.\r\n\r\nSection 1.2.2\r\n\r\nWhile the effect of QUIC's response to congestion means that some RTP\r\npackets will arrive at the receiver later than a user of the RTP flow might\r\nprefer, it is still preferable to \"ceasing transmission\" completely until\r\nthe RTP sender has a reason to believe that restarting the flow will not\r\nresult in congestion.\u00b6\r\n\r\n[BA] In contrast to circuit breakers, which do not restrict the ability to\r\nsend RTCP feedback, QUIC congestion control affects RTCP feedback, not just\r\nRTP.  So saying QUIC congestion control is \"preferable\" seems questionable.\r\n\r\nMoreover, when a single QUIC connection is used to multiplex both RTP-RTCP\r\nand non-RTP packets as described in Section 1.2.5\r\nthe QUIC connection will still be Internet-safe, with no coordination\r\nrequired.\r\n\r\n[BA] While it may be \"Internet-safe\", delays in RTCP feedback are likely to\r\ndestabilize rate control as well as resulting in challenges to A/V sync.\r\nSo not sure that \"Internet-safe\" is the only important metric here.\r\n\r\nSection 1.2.3\r\n\r\nOne word of caution is in order - RTP implementations may rely on at least\r\nsome minimal periodic RTCP feedback, in order to determine that an RTP flow\r\nis still active, and is not causing sustained congestion (as described in\r\nRFC8083, but since this \"periodicity\" is measured in seconds, the impact of this \"duplicate\"\r\nfeedback on path bandwidth utilization is likely close to zero.\r\n\r\n[BA] Under congestion, RTCP feedback can potentially be delayed\r\nsubstantially. Here the issue is not \"bandwidth utilization\" but whether\r\nRTCP receives the transport treatment required for control traffic.  Note\r\nalso that similar considerations apply to treatment of audio vs. video.\r\nSerious problems with a/v sync are possible (or even likely) under\r\ncongestion.\r\n\r\nSection 1.2.4\r\n\r\nThis is especially useful in certain conferencing topologies, where\r\notherwise senders have no choice but to use the lowest path MTU for all\r\nconference participants, but even in point-to-point RTP sessions, this also\r\nallows senders to piggyback audio media in the same UDP packet as video\r\nmedia, for example, and also allows QUIC receivers to piggyback QUIC ACK\r\nframes on any QUIC frames being transmitted in the other direction.\u00b6\r\n\r\n[BA] The draft does not talk much about piggybacking of audio and video\r\nmedia, but we have seen some implementations experimenting with this to\r\navoid audio/video sync issues without having to resort to other techniques\r\nsuch as prioritization.  Is this something that deserves more discussion?\r\n\r\nSection 2\r\n\r\nRate control:\r\n\r\nA congestion control mechanism that helps a sender determine and adjust its\r\nsending rate, in order to maximize the amount of information that is sent\r\nto a receiver, without causing queues to build beyond a reasonable amount,\r\ncausing \"buffer bloat\" and \"jitter\". Rate adapation is one way to\r\naccomplish congestion control for real-time media, especially when a sender\r\nhas multiple media streams to the receiver, because the sum of all sending\r\nrates for media streams must not be high enough to cause congestion on the\r\npath these media streams share between sender and receiver.\u00b6\r\n\r\n[BA] Rate control and congestion control are distinct. So the definition\r\nhere doesn't seem right, particularly for RoQ where congestion control is\r\nbuilt into QUIC while rate adaptation is application and even\r\ncodec-specific as you state later in the document. \r\n\r\nElsewhere in the document, the relationship is stated more clearly.  QUIC congestion\r\ncontrol limits the amount that can be sent. Since realtime applications\r\nseek to achieve low latency, they will typically prefer to respond to\r\nbandwidth limitations by controlling rate, rather than experiencing\r\nqueueing delays or increased loss.\r\n\r\nBut since congestion control and rate control are distinct and are handled\r\nat different layers, rate control is not \"one way to accomplish congestion\r\ncontrol\" but rather \"one way to respond to send rate limitations imposed by\r\ncongestion control algorithms\".\r\n\r\nSection 3\r\n\r\nA rate adaptation algorithm can be plugged in to adapt the media bitrate to\r\nthe available bandwidth. This document does not mandate any specific rate\r\nadaptation algorithm, because the desired response to congestion can be\r\napplication and codec-specific. For example, adjusting quantization in\r\nresponse to congestion may work well in many cases, but if what's being\r\nshared is video that includes text, maintaining readability is important.\r\n\r\n[BA] This text is good. I believe it should be placed earlier in the\r\ndocument (perhaps in the scope section).\r\n\r\nAs of this writing, the IETF has produced two Experimental-track rate\r\nadaptation specifications, Network-Assisted Dynamic Adaptation (NADA) [\r\nRFC8698 <https://www.rfc-editor.org/rfc/rfc8698>] and Self-Clocked Rate\r\nAdaptation for Multimedia (SCReAM) [RFC8298\r\n<https://www.rfc-editor.org/rfc/rfc8298>]. These rate adaptation algorithms\r\nrequire some feedback about the network's performance to calculate target\r\nbitrates. Traditionally this feedback is generated at the receiver and sent\r\nback to the sender via RTCP.\r\n\r\n[BA] Within the context of the previous paragraph is it correct to\r\ncharacterize these specifications as \"rate adaptation algorithms\"?  The\r\nprevious paragraph mentions QP-based rate control which is indeed codec and\r\napplication specific. NADA, SCReAM, gcc, etc. were developed as congestion\r\ncontrol algorithms and therefore they do not provide application and\r\ncodec-specific rate control mechanisms. Elswhere you characterize NADA\r\nand SCReAM as \"congestion control algorithms\", which seems correct.\r\n\r\nSection 6\r\n\r\nLike any other application on the internet, RoQ applications need a\r\nmechanism to perform congestion control to avoid overloading the network.\r\nWhile any generic congestion controller can protect the network, this\r\ndocument takes advantage of the opportunity to use rate adaptation\r\nmechanisms that are designed to provide superior user experiences for\r\nreal-time media applications.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6-1>\r\n\r\n[BA] This paragraph appears to conflate congestion control and rate\r\ncontrol. Congestion control is built into QUIC, and RoQ therefore inherits\r\nit. So RoQ applications have a mechanism for congestion control.\r\n\r\nSince earlier it was stated that there is no normative guidance on rate\r\ncontrol, how can \"this document take advantage of the opportunity to use\r\nrate adaptation mechanisms that are designed to provide superior user\r\nexperiences\"?\r\n\r\nA wide variety of rate adaptation algorithms for real-time media have been\r\ndeveloped (for example, \"Google Congestion Controller\" [\r\nI-D.draft-ietf-rmcat-gcc\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-rmcat-gcc-02>]). The IETF\r\nhas defined two algorithms in two Experimental RFCs (e.g. SCReAM [RFC8298\r\n<https://www.rfc-editor.org/rfc/rfc8298>] and NADA [RFC8698\r\n<https://www.rfc-editor.org/rfc/rfc8698>]). These rate adaptation\r\nalgorithms for RTP are specifically tailored for real-time transmissions at\r\nlow latencies, but this section would apply to any rate adaptation\r\nalgorithm that meets the requirements described in \"Congestion Control\r\nRequirements for Interactive Real-Time Media\" [RFC8836\r\n<https://www.rfc-editor.org/rfc/rfc8836>].\r\n\r\n[BA] As noted earlier, NADA, etc. are not rate control algorithms (e.g.\r\nper-frame QP), they are congestion control algorithms and should be\r\nreferred to as such. \r\n\r\nThis document defines two architectures for congestion control and\r\nbandwidth estimation for RoQ, depending on whether most rate adaptation is\r\nperformed within a QUIC implementation at the transport layer, as described\r\nin Section 6.1\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-quic-layer>,\r\nor within an RTP application layer, as described in Section 6.2\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-application-layer>,\r\nbut this document does not mandate any specific congestion control or rate\r\nadaptation algorithm for either QUIC or RTP.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6-3>\r\n\r\n[BA] QUIC implementations cannot implement rate control, because as you\r\nstate earlier, that is application and/or codec-specific. So again you seem\r\nto be conflating congestion control and rate control.\r\n\r\nIt is assumed that the congestion controller in use provides a pacing\r\nmechanism to determine when a packet can be sent to avoid bursts. The\r\ncurrently proposed congestion control algorithms for real-time\r\ncommunications (e.g. SCReAM and NADA) provide such pacing mechanisms. The\r\nuse of congestion controllers which don't provide a pacing mechanism is out\r\nof scope of this document.\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6-6>\r\n\r\n[BA] In this paragraph you correctly refer to SCReaM and NADA as congestion\r\ncontrol algorithms. Please use this terminology consistently.\r\n\r\nSection 6.1\r\n\r\nIf a QUIC implementation is to perform rate adaptation in a way that\r\naccommodates real-time media, one way for the implementation to recognize\r\nthat it is carrying real-time media is to be explicitly told that this is\r\nthe case. This document defines a new \"TLS Application-Layer Protocol\r\nNegotiation (ALPN) Protocol ID\", as described in Section 4\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#alpn>,\r\nthat a QUIC implementation can use as a signal to choose a real-time\r\nmedia-centric rate controller, but this is not required for ROQ deployments.\r\n\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.1-2>\r\n\r\n[BA] Again, QUIC implementations do not perform rate adaptation. That is an\r\napplication layer function. I think you mean \"perform congestion control\"\r\nhere.\r\n\r\nCongestion control is orthogonal to the use of an ALPN, so mixing\r\nthese two concepts is problematic. \r\n\r\nIf congestion control is to be applied at the transport layer, it is\r\nRECOMMENDED that the QUIC Implementation uses a congestion controller that\r\nkeeps queueing delays short to keep the transmission latency for RTP and\r\nRTCP packets as low as possible, such as the IETF-defined SCReAM [RFC8298\r\n<https://www.rfc-editor.org/rfc/rfc8298>] and NADA [RFC8698\r\n<https://www.rfc-editor.org/rfc/rfc8698>] algorithms.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.1-3>\r\n\r\n[BA] You might also mention L4S here. This seems more likely to be\r\nsupported as a built-in QUIC CC mechanism than the other low latency\r\nalgorithms you mention in the draft.\r\n\r\nIf congestion control is done by the QUIC implementation, the application\r\nneeds a mechanism to query the currently available bandwidth to adapt media\r\ncodec configurations. The employed congestion controller of the QUIC\r\nconnection SHOULD expose such an API to the application. If a current\r\nbandwidth estimate is not available from the QUIC congestion controller,\r\nthe sender can either implement an alternative bandwidth estimation at the\r\napplication layer as described in Section 6.2\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-application-layer>\r\n or a receiver can feedback the observed bandwidth through RTCP, e.g., using\r\n [I-D.draft-alvestrand-rmcat-remb\r\n<https://datatracker.ietf.org/doc/html/draft-alvestrand-rmcat-remb-03>].\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.1-5>\r\n\r\n[BA] This paragraph is good, since it describes how the QUIC implementation\r\nprovides info to the application, to be used in rate control. I think you\r\nneed to be more clear about the relationship throughout the document. \r\n\r\nHowever, normative language is problematic because this document cannot have\r\nnormative API dependencies. Also, you need to be careful with references to\r\ndrafts which will not be published as RFCs, particularly REMB which has\r\nbeen deprecated in favor of transport CC.\r\n\r\nSection 6.2\r\n\r\nThe rate adaptation algorithms for RTP are specifically tailored for\r\nreal-time transmissions at low latencies, as described in Section 6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#congestion-control>.\r\nThe available rate adaptation algorithms expose a target_bitrate that can\r\nbe used to dynamically reconfigure media codecs to produce media at a rate\r\nthat can be sent in real-time under the observed network conditions.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.2-2>\r\n\r\n[BA] Again, there is a conflation of rate adaptation and congestion\r\ncontrol. In this paragraph \"congestion control algorithms\" should be used\r\ninstead of \"rate control algorithms\".\r\n\r\nSection 6.3\r\n\r\nBecause QUIC is a congestion-controlled transport, as described in Section\r\n6.1\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-quic-layer>,\r\nand RTP applications can also perform congestion control and rate\r\nadaptation,\r\n\r\n[BA] Since congestion control is built into QUIC, RoQ applications can only\r\ndo rate control, not congestion control.\r\n\r\n   - Application-limited Media Flows - if an application chooses RTP as its\r\n   transport mechanism, the goal will be maximizing the user experience, not\r\n   maximizing path bandwidth utilization. If the application is, in fact,\r\n   transmitting media that does not saturate path bandwidth, and paces its\r\n   transmission, more heavy-handed congestion control mechanisms (drastic\r\n   reductions in the sending rate when loss is detected, with much slower\r\n   increases when losses are no longer detected) should rarely come into play.\r\n   If the application chooses ROQ as its transport, sends enough media to\r\n   saturate the path bandwidth, and does not adapt its own sending rate,\r\n   drastic measures will be required in order to avoid sustained or\r\n   oscillating congestion along the path.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.3-2.1>\r\n\r\n[BA] This document probably isn't the right place to discuss this, but it\r\nis a very big issue that has limited the deployment of the algorithms\r\nproduced by RMCAT, because probing was supported by gcc and not in the\r\nNADA, SCreAM, etc. In practice, fixing this problem requires probing\r\ncontrolled by the CC algorithm at the QUIC layer. So far I'm not aware of\r\nany QUIC implementations which support this kind of probing.\r\n",
      "createdAt": "2023-09-24T21:51:24Z",
      "updatedAt": "2023-10-23T16:40:17Z",
      "closedAt": "2023-10-23T14:26:29Z",
      "comments": [
        {
          "author": "fideltian",
          "authorAssociation": "NONE",
          "body": "Very interesting record. Is congestion control a must for RTP over Quic? why not let application layer to do congest control and bitrate control? Then it will have broad usage, especially on real time data or low latency data.\r\n\r\nAnother idea is  Why not raw UDP alike solution(such as Direct Sockets( https://wicg.github.io/direct-sockets/).) or limited \"congest control\" for \"RTP over Quic\".  \"Limited\" means satisfy the minimum requirement of security if really need.\r\n",
          "createdAt": "2023-10-09T10:26:15Z",
          "updatedAt": "2023-10-09T10:26:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened PR #134 to address some of these issues. See some comments below:\r\n\r\n> From the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/7IFLBJAmFbB3f1_OgkoPyN0lhT8/\r\n> \r\n> Looking over the coverage of Congestion Control and Rate Control, the two topics appear to be conflated in places and also there appear to be some issues that have not been fully considered.\r\n> \r\n> Section 1.2.2\r\n> \r\n> While the effect of QUIC's response to congestion means that some RTP packets will arrive at the receiver later than a user of the RTP flow might prefer, it is still preferable to \"ceasing transmission\" completely until the RTP sender has a reason to believe that restarting the flow will not result in congestion.\u00b6\r\n> \r\n> [BA] In contrast to circuit breakers, which do not restrict the ability to send RTCP feedback, QUIC congestion control affects RTCP feedback, not just RTP. So saying QUIC congestion control is \"preferable\" seems questionable.\r\n> \r\n> Moreover, when a single QUIC connection is used to multiplex both RTP-RTCP and non-RTP packets as described in Section 1.2.5 the QUIC connection will still be Internet-safe, with no coordination required.\r\n> \r\n> [BA] While it may be \"Internet-safe\", delays in RTCP feedback are likely to destabilize rate control as well as resulting in challenges to A/V sync. So not sure that \"Internet-safe\" is the only important metric here.\r\n> \r\n> Section 1.2.3\r\n> \r\n> One word of caution is in order - RTP implementations may rely on at least some minimal periodic RTCP feedback, in order to determine that an RTP flow is still active, and is not causing sustained congestion (as described in RFC8083, but since this \"periodicity\" is measured in seconds, the impact of this \"duplicate\" feedback on path bandwidth utilization is likely close to zero.\r\n> \r\n> [BA] Under congestion, RTCP feedback can potentially be delayed substantially. Here the issue is not \"bandwidth utilization\" but whether RTCP receives the transport treatment required for control traffic. Note also that similar considerations apply to treatment of audio vs. video. Serious problems with a/v sync are possible (or even likely) under congestion.\r\n\r\nI think these are good points, but since #134 is already quite large, I will create a new issue to address these separately.\r\n\r\n> Section 1.2.4\r\n> \r\n> This is especially useful in certain conferencing topologies, where otherwise senders have no choice but to use the lowest path MTU for all conference participants, but even in point-to-point RTP sessions, this also allows senders to piggyback audio media in the same UDP packet as video media, for example, and also allows QUIC receivers to piggyback QUIC ACK frames on any QUIC frames being transmitted in the other direction.\u00b6\r\n> \r\n> [BA] The draft does not talk much about piggybacking of audio and video media, but we have seen some implementations experimenting with this to avoid audio/video sync issues without having to resort to other techniques such as prioritization. Is this something that deserves more discussion?\r\n\r\nI think this could be addressed in #86.\r\n\r\n> Section 2\r\n> \r\n> Rate control:\r\n> \r\n> A congestion control mechanism that helps a sender determine and adjust its sending rate, in order to maximize the amount of information that is sent to a receiver, without causing queues to build beyond a reasonable amount, causing \"buffer bloat\" and \"jitter\". Rate adapation is one way to accomplish congestion control for real-time media, especially when a sender has multiple media streams to the receiver, because the sum of all sending rates for media streams must not be high enough to cause congestion on the path these media streams share between sender and receiver.\u00b6\r\n> \r\n> [BA] Rate control and congestion control are distinct. So the definition here doesn't seem right, particularly for RoQ where congestion control is built into QUIC while rate adaptation is application and even codec-specific as you state later in the document.\r\n\r\nI tried to fix this in #134. I added another definition for bandwidth estimation, because I think that was also conflated with the other terms. In my understanding, congestion control is what the transport layer does to avoid transmitting too much data in-flight and overloading the network. Bandwidth estimation is necessary to calculate a bitrate and rate adaptation is how a sender decides what to send while being limited to the estimated bandwidth. Congestion control should happen at QUIC layer and rate adaptation at the application, but bandwidth estimation can be done by both and depends on the APIs provided by QUIC.\r\n\r\nPlease let me know what you think about the changes I made. \r\n\r\n> Elsewhere in the document, the relationship is stated more clearly. QUIC congestion control limits the amount that can be sent. Since realtime applications seek to achieve low latency, they will typically prefer to respond to bandwidth limitations by controlling rate, rather than experiencing queueing delays or increased loss.\r\n> \r\n> But since congestion control and rate control are distinct and are handled at different layers, rate control is not \"one way to accomplish congestion control\" but rather \"one way to respond to send rate limitations imposed by congestion control algorithms\".\r\n> \r\n> Section 3\r\n> \r\n> A rate adaptation algorithm can be plugged in to adapt the media bitrate to the available bandwidth. This document does not mandate any specific rate adaptation algorithm, because the desired response to congestion can be application and codec-specific. For example, adjusting quantization in response to congestion may work well in many cases, but if what's being shared is video that includes text, maintaining readability is important.\r\n> \r\n> [BA] This text is good. I believe it should be placed earlier in the document (perhaps in the scope section).\r\n\r\nI will open another issue/pull request for this.\r\n\r\n> As of this writing, the IETF has produced two Experimental-track rate adaptation specifications, Network-Assisted Dynamic Adaptation (NADA) [ RFC8698 https://www.rfc-editor.org/rfc/rfc8698] and Self-Clocked Rate Adaptation for Multimedia (SCReAM) [RFC8298 https://www.rfc-editor.org/rfc/rfc8298]. These rate adaptation algorithms require some feedback about the network's performance to calculate target bitrates. Traditionally this feedback is generated at the receiver and sent back to the sender via RTCP.\r\n> \r\n> [BA] Within the context of the previous paragraph is it correct to characterize these specifications as \"rate adaptation algorithms\"? The previous paragraph mentions QP-based rate control which is indeed codec and application specific. NADA, SCReAM, gcc, etc. were developed as congestion control algorithms and therefore they do not provide application and codec-specific rate control mechanisms. Elswhere you characterize NADA and SCReAM as \"congestion control algorithms\", which seems correct.\r\n\r\nDo we need the reference to these algorithms in the overview section at all? As explained in the updated section 7, they can only be used when QUIC timestamp extensions are available and that is discussed in detail in section 7. I suggest removing this paragraph.\r\n\r\n> Section 6.3\r\n> \r\n> Because QUIC is a congestion-controlled transport, as described in Section 6.1 https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-quic-layer, and RTP applications can also perform congestion control and rate adaptation,\r\n> \r\n> [BA] Since congestion control is built into QUIC, RoQ applications can only do rate control, not congestion control.\r\n\r\nI tried to shorten and merge this section into the previous one. Please let me know if you think we should keep it as a separate section.\r\n\r\n",
          "createdAt": "2023-10-10T14:11:08Z",
          "updatedAt": "2023-10-10T14:11:08Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @fideltian ,\r\n\r\nThanks for the comments! \r\n\r\n> Very interesting record. Is congestion control a must for RTP over Quic? why not let application layer to do congest control and bitrate control? Then it will have broad usage, especially on real time data or low latency data.\r\n\r\n@mengelbart and I have done multiple PRs about this, trying to get the explanation right in the editor's version, especially in [Section 1.2.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-always-on-internet-safe-con) and [Section 7](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-congestion-control-and-rate)\r\n\r\nThe part that we didn't actually write down was that we haven't talked to anyone who thinks that adding a mechanism for an (untrusted) application to disable QUIC-level congestion control is a good idea. We would have to force a draft about this through the QUIC working group, and that seemed like a problem if we wanted to deploy RoQ in a timely way. \r\n\r\nWhat we tried to say in  [Section 1.2.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-always-on-internet-safe-con) is that \r\n\r\n- QUIC will always be ready to do QUIC connection-level congestion control if it needs to do that, but \r\n- RoQ applications can do stream-level rate adaptation, and this ought to prevent or minimize packet loss that QUIC would detect and try to recover (retransmission, coarse adjustment of sending rate for the entire QUIC connection, etc.) \r\n\r\nPlease let us know if that's not clear from the (just merged about an hour ago) text. \r\n\r\n> Another idea is Why not raw UDP alike solution(such as Direct Sockets( https://wicg.github.io/direct-sockets/).) or limited \"congest control\" for \"RTP over Quic\". \"Limited\" means satisfy the minimum requirement of security if really need.\r\n\r\nThank you for pointing me to https://wicg.github.io/direct-sockets/ - I had not seen this previously. Apparently I lead a sheltered life. :upside_down_face:\r\n\r\nThis is actually a better question for @aboba and JonathanLennox, as AVTCORE chairs - speaking only for me, I'm not sure if this would be in scope for RoQ, and perhaps not in scope for AVTCORE. But I do have a couple of thoughts about this:\r\n\r\n- It would be helpful to have at least a high-level slide or two explaining what the API would allow application developers to do, that is difficult or impossible using existing/chartered IETF protocols, and whether this would require any work on the QUIC protocol, or on the RoQ protocol (so, this proposal would be for more than \"encapsulating RTP messages in UDP using the [UDPsocketinterface](https://wicg.github.io/direct-sockets/#udpsocket-interface)\".\r\n- - https://wicg.github.io/direct-sockets/ is (as I understand it) a W3C incubator community group for pre-standardization discussion, so that might be \"too soon\" for the IETF to charter protocol work that would support that API.\r\n- That's not to say it's too soon for people to talk about this possibility in the IETF, of course. \r\n\r\nIf this sounds like something you'd like to pursue, I'd suggest that you start by talking with the AVTCORE chairs, and being ready to talk to the DISPATCH chairs, in case the AVTCORE chairs don't think this idea would be in scope for them. \r\n\r\nBest wishes, of course!",
          "createdAt": "2023-10-23T16:40:17Z",
          "updatedAt": "2023-10-23T16:40:17Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "I_kwDOFUmh7s5x9c0R",
      "title": "CONNECTION_CLOSE does have an error phrase",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/129",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "[Section 8.4.4](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-8.4.4) claims that QUIC's CONNECTION_CLOSE cannot carry an error reason as a string, but that is not true, see [Section 19.19 of RFC9000](https://www.rfc-editor.org/rfc/rfc9000.html#section-19.19).",
      "createdAt": "2023-09-25T16:58:59Z",
      "updatedAt": "2023-10-16T13:33:23Z",
      "closedAt": "2023-10-16T13:33:23Z",
      "comments": []
    },
    {
      "number": 131,
      "id": "I_kwDOFUmh7s5yWVw3",
      "title": "Section 8.4.1: Mapping QUIC Feedback to RTCP Receiver Reports (\"RR\")",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/131",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/o6in-c7jAZ2mo0z8JKZdOEn5ZyA/\r\n\r\nRoQ section 10.1 \"Information to be exported from QUIC says:\r\n\r\n   - *Datagram Acknowledgment and Loss*: Section 5.2\r\n   <https://rfc-editor.org/rfc/rfc9221#section-5.2> of [RFC9221\r\n   <https://www.rfc-editor.org/rfc/rfc9221>] allows QUIC implementations to\r\n   notify the application that a QUIC Datagram was acknowledged or that it\r\n   believes a datagram was lost. The exposed information SHOULD include enough\r\n   information to allow the application to maintain a mapping between the\r\n   datagram that was acknowledged/lost and the RTP packet that was sent in\r\n   that datagram.\u00b6\r\n\r\nSince this only refers to Datagram Acknowledgment and Loss, this lead me to wonder  about the implications for other transport modes (e.g. frame/stream), particularly in scenarios where multiple SSRCs are sent over the same QUIC connection.\r\n\r\nRFC 3550 Section 6.4.2 defines the RTCP Receiver Report. \r\n\r\nAs noted in Section 8.4.1, an RTCP RR packet can provide information relating to multiple sources, each identified by their own SSRCs.   It is possible for multiple SSRCs to be sent over the same QUIC connection.\r\n\r\nSection 8.4.1 says:\r\n\r\nConsiderations for mapping QUIC feedback into *Receiver Reports* (PT=201,\r\nName=RR, [RFC3550 <https://www.rfc-editor.org/rfc/rfc3550>]) are:\u00b6\r\n\r\n   - *Fraction lost*: When RTP packets are carried in QUIC datagrams, the\r\n   fraction of lost packets can be directly inferred from QUIC's\r\n   acknowledgments. The calculation SHOULD include all packets up to the\r\n   acknowledged RTP packet with the highest RTP sequence number. Later packets\r\n   SHOULD be ignored, since they may still be in flight, unless other QUIC\r\n   packets that were sent after the RTP packet, were already acknowledged.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic/#section-8.4.1-2.1>\r\n\r\n   - *Cumulative lost*: Similar to the fraction of lost packets, the\r\n   cumulative loss can be inferred from QUIC's acknowledgments including all\r\n   packets up to the latest acknowledged packet.\r\n\r\n   - *Highest Sequence Number received*: In RTCP, this field is a 32-bit\r\n   field that contains the highest sequence number a receiver received in an\r\n   RTP packet and the count of sequence number cycles the receiver has\r\n   observed. A sender sends RTP packets in QUIC packets and receives\r\n   acknowledgments for the QUIC packets. By keeping a mapping from a QUIC\r\n   packet to the RTP packets encapsulated in that QUIC packet, the sender can\r\n   infer the highest sequence number and number of cycles seen by the receiver\r\n   from QUIC acknowledgments.\r\n\r\n[BA] As you note, for the sender to compute the info in the RTCP RR (including Fraction Lost, Cumulative Lost, Highest Sequence Number received, etc.) it is necessary for the sender to keep a mapping of QUIC packets to RTP packet info (e.g. SSRC, sequence number).\r\n\r\nSince Section 10.1 only mentions datagrams, is it envisaged that such a mapping will be maintained for frame/stream transport? Does the existing RoQ implementation support the mapping of QUIC ACKs to RTP info for frame/stream transport?\r\n\r\n   - *Interarrival jitter*: If QUIC acknowledgments carry timestamps as\r\n   described in [I-D.draft-smith-quic-receive-ts\r\n   <https://datatracker.ietf.org/doc/html/draft-smith-quic-receive-ts-00>],\r\n   senders can infer the interarrival jitter from the arrival timestamps in\r\n   QUIC acknowledgments.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic/#section-8.4.1-2.4>\r\n   - *Last SR*: Similar to lost packets, the NTP timestamp of the last\r\n   received sender report can be inferred from QUIC acknowledgments.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic/#section-8.4.1-2.5>\r\n   - *Delay since last SR*: This field is not required when the receiver\r\n   reports are entirely replaced by QUIC feedback.\r\n\r\n[BA] Given that Section 10.1 only mentions datagrams, is there an assumption that RTCP RRs/SRs are sent using QUIC datagrams? In some QUIC implementations, datagrams are prioritized over reliable streams, which might help ensure that RTCP traffic isn't subject to excess delays or starvation.\r\n",
      "createdAt": "2023-09-29T01:14:05Z",
      "updatedAt": "2023-10-23T14:59:38Z",
      "closedAt": "2023-10-23T14:59:38Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba, \r\n\r\nI think the key problem you're pointing out is here: \r\n\r\n> [BA] Given that **Section 10.1 only mentions datagrams**, is there an assumption that RTCP RRs/SRs are sent using QUIC datagrams? \r\n\r\nMy suggestion is to make sure section 10.1 contains equivalent guidance for streams. \r\n\r\nDoes that make sense?",
          "createdAt": "2023-10-09T14:56:48Z",
          "updatedAt": "2023-10-09T14:56:48Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "I_kwDOFUmh7s5zXNuk",
      "title": "Congestion and rate control in motivation section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/135",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF118",
        "Current Focus"
      ],
      "body": "From @aboba in https://github.com/mengelbart/rtp-over-quic-draft/issues/128:\r\n\r\n> \r\n> Looking over the coverage of Congestion Control and Rate Control, the two\r\n> topics appear to be conflated in places and also there appear to be some issues that\r\n> have not been fully considered.\r\n> \r\n> Section 1.2.2\r\n> \r\n> While the effect of QUIC's response to congestion means that some RTP\r\n> packets will arrive at the receiver later than a user of the RTP flow might\r\n> prefer, it is still preferable to \"ceasing transmission\" completely until\r\n> the RTP sender has a reason to believe that restarting the flow will not\r\n> result in congestion.\u00b6\r\n> \r\n> [BA] In contrast to circuit breakers, which do not restrict the ability to\r\n> send RTCP feedback, QUIC congestion control affects RTCP feedback, not just\r\n> RTP. So saying QUIC congestion control is \"preferable\" seems questionable.\r\n> \r\n> Moreover, when a single QUIC connection is used to multiplex both RTP-RTCP\r\n> and non-RTP packets as described in Section 1.2.5\r\n> the QUIC connection will still be Internet-safe, with no coordination\r\n> required.\r\n> \r\n> [BA] While it may be \"Internet-safe\", delays in RTCP feedback are likely to\r\n> destabilize rate control as well as resulting in challenges to A/V sync.\r\n> So not sure that \"Internet-safe\" is the only important metric here.\r\n> \r\n> Section 1.2.3\r\n> \r\n> One word of caution is in order - RTP implementations may rely on at least\r\n> some minimal periodic RTCP feedback, in order to determine that an RTP flow\r\n> is still active, and is not causing sustained congestion (as described in\r\n> RFC8083, but since this \"periodicity\" is measured in seconds, the impact of this \"duplicate\"\r\n> feedback on path bandwidth utilization is likely close to zero.\r\n> \r\n> [BA] Under congestion, RTCP feedback can potentially be delayed\r\n> substantially. Here the issue is not \"bandwidth utilization\" but whether\r\n> RTCP receives the transport treatment required for control traffic. Note\r\n> also that similar considerations apply to treatment of audio vs. video.\r\n> Serious problems with a/v sync are possible (or even likely) under\r\n> congestion.",
      "createdAt": "2023-10-10T14:12:19Z",
      "updatedAt": "2023-10-23T14:42:45Z",
      "closedAt": "2023-10-23T14:42:45Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looking over the coverage of Congestion Control and Rate Control, the two\r\ntopics appear to be conflated in places and also there appear to be some issues that\r\nhave not been fully considered.\r\n\r\n@SpencerDawkins notes that the subtle definitions of congestion control and rate adaptation have morphed in the decades since Van Jacobson introduced slow start, congestion avoidance, etc. One of the most obvious differences is that even the mechanisms that focus on \"defending the network\" are now likely to include some form of \"chirping\", to avoid bufferbloat, etc. \r\n\r\nIt would be useful to actually point this out in the RoQ document, point to the definitions we have included in the terminology section, and say that guessing what we mean without looking at the definitions will probably be confusing at best. ",
          "createdAt": "2023-10-16T15:05:13Z",
          "updatedAt": "2023-10-19T14:58:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba, thank you for the pushback. I wrote much of the text you are commenting on, and I appreciate feedback representing the endpoint's point of view, and not just the network's point of view. \r\n\r\nI'm working on a PR for this now. I'll ask you to look it over, when it's in the repo. ",
          "createdAt": "2023-10-19T13:03:29Z",
          "updatedAt": "2023-10-19T13:03:29Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "I_kwDOFUmh7s5zeKVp",
      "title": "Allow to continue sending media on QUIC datagrams after receiving STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/136",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "> When a RoQ sender receives a STOP\\_SENDING frame for the last open stream available to send RTP/RTCP-data, the RoQ sender MUST open one or more new QUIC streams before sending new media frames. \r\n\r\nAlternatively, it could also continue to send media frames in QUIC datagrams. I think the important bit here is, that the receiver MUST continue to send media of the same media stream.",
      "createdAt": "2023-10-11T09:19:20Z",
      "updatedAt": "2023-10-16T14:04:26Z",
      "closedAt": "2023-10-16T14:04:26Z",
      "comments": []
    },
    {
      "number": 141,
      "id": "I_kwDOFUmh7s5z9-7C",
      "title": "Move CC paragraph to scope section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/141",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF118",
        "Current Focus"
      ],
      "body": "From @aboba in #128:\r\n\r\n> Section 3\r\n> \r\n> A rate adaptation algorithm can be plugged in to adapt the media bitrate to\r\n> the available bandwidth. This document does not mandate any specific rate\r\n> adaptation algorithm, because the desired response to congestion can be\r\n> application and codec-specific. For example, adjusting quantization in\r\n> response to congestion may work well in many cases, but if what's being\r\n> shared is video that includes text, maintaining readability is important.\r\n> \r\n> [BA] This text is good. I believe it should be placed earlier in the\r\n> document (perhaps in the scope section).\r\n\r\n",
      "createdAt": "2023-10-16T16:20:09Z",
      "updatedAt": "2023-10-23T14:08:43Z",
      "closedAt": "2023-10-23T14:08:43Z",
      "comments": []
    },
    {
      "number": 142,
      "id": "I_kwDOFUmh7s50RBVf",
      "title": "Add text for configuring unidirectional RoQ streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/142",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF118",
        "Current Focus"
      ],
      "body": "A LONG time ago, in [an issue far, far away](https://github.com/mengelbart/rtp-over-quic-draft/issues/13#issuecomment-1172980290), @LPardue said\r\n\r\nYou're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance.\r\n\r\nThat's gotten a bit lost, up until now, and it doesn't have anything to do with datagrams. I'm moving that to its own issue (here)",
      "createdAt": "2023-10-18T20:43:06Z",
      "updatedAt": "2023-10-23T14:23:24Z",
      "closedAt": "2023-10-23T14:23:24Z",
      "comments": []
    },
    {
      "number": 147,
      "id": "I_kwDOFUmh7s50qu03",
      "title": "Make sure \"QUIC datagram\" (the UDP payload) and \"QUIC DATAGRAM\" (the frame type) are used consistently",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/147",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "documentation",
        "NextInterim"
      ],
      "body": "We say that \"datagram\" has two meanings in the terminology section, and say that \"datagram\" without qualification refers to [QUIC DATAGRAM frames](https://www.rfc-editor.org/rfc/rfc9221), but if we always qualify the term, that would be easier for the reader. ",
      "createdAt": "2023-10-23T14:49:47Z",
      "updatedAt": "2023-10-23T15:17:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 149,
      "id": "I_kwDOFUmh7s52YtoN",
      "title": "Incorrect use of term \"rate adaptation\" instead of congestion control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/149",
      "state": "OPEN",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "\"A wide variety of congestion control algorithms for real-time media\r\n   have been developed (for example, \"Google Congestion Controller\"\r\n   [I-D.draft-ietf-rmcat-gcc]).  The IETF has defined two algorithms in\r\n   two Experimental RFCs (SCReAM [RFC8298] and NADA [RFC8698]).  These\r\n   algorithms for RTP are specifically tailored for real-time\r\n   transmissions at low latencies, but this section would apply to any\r\n   **rate adaptation algorithm** that meets the requirements described in\r\n   \"Congestion Control Requirements for Interactive Real-Time Media\"\r\n   [RFC8836].\"\r\n\r\nPlease replace   **rate adaptation algorithm** with congestion control algorithm since the algorithms being discussed are congestion control algorithms",
      "createdAt": "2023-11-09T18:32:08Z",
      "updatedAt": "2023-11-10T06:35:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@gchandok - I agree with this, and I can prepare a PR for it. \r\n\r\nJust as background - both @mengelbart and I have made passes over this draft trying to get the usages of \"rate adaptation\" and \"congestion control\" right. Mathis made the most recent pass for issue [128](https://github.com/mengelbart/rtp-over-quic-draft/issues/128) from @aboba, so it's my turn now. \t:yum:",
          "createdAt": "2023-11-10T06:35:52Z",
          "updatedAt": "2023-11-10T06:35:52Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI4OTU5NzUz",
      "title": "Draft section about used RTP/RTCP packets and restrictions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/1",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-03T09:13:51Z",
      "updatedAt": "2021-05-17T10:29:16Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "15dfd07af0ac380d51b42c952e096d2ee41e3c7e",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtcp-restrictions",
      "headRefOid": "e691a73184a513899fe992c574057897fa342577",
      "closedAt": "2021-05-08T15:47:21Z",
      "mergedAt": "2021-05-08T15:47:21Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "c416b71a37b9ff8891c9ba62af876c9e9c25334c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ1NzY5NzY2",
      "title": "Add identifiers to the cc interface",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/2",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-17T11:08:02Z",
      "updatedAt": "2021-05-17T16:53:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "386a04a2a6985f77ba9e9e4b4d46f8ba3b890ac8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "add-interface-identifiers",
      "headRefOid": "cb6e602846ddc421cad78b5dae14d2f065b7e35a",
      "closedAt": "2021-05-17T16:31:42Z",
      "mergedAt": "2021-05-17T16:31:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3fdbd66070a57196e538e1c4eaa389d262d47ebe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY2MDA0MzA4",
      "title": "Update draft-engelbart-rtp-over-quic.md",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/3",
      "state": "MERGED",
      "author": "joerg-ott",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Mathis, some thoughts on SDP signalling and a concrete example are in now. The detailed protocol procedures would likely be quite lengthy, so for an initial draft to see what people think, this might be good enough.",
      "createdAt": "2021-06-09T15:06:48Z",
      "updatedAt": "2021-06-09T16:53:49Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "79e265cabab1ee3f33e7cf696ba733bd871ab467",
      "headRepository": "joerg-ott/rtp-over-quic-draft",
      "headRefName": "patch-1",
      "headRefOid": "93749c47fdcc372668de6d4e81cdb6f3626688c8",
      "closedAt": "2021-06-09T16:53:49Z",
      "mergedAt": "2021-06-09T16:53:49Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "cb8fdaa379c3f9dea77140481c7f1649fabe0049"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgwNjgxMjk1",
      "title": "Fix typos and clarify some terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/4",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-30T09:18:32Z",
      "updatedAt": "2022-03-04T09:35:59Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f7bd274edc900fb100e7a6cd749a98f457831150",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "terminology",
      "headRefOid": "137b2a4313d2445adfffa77e6fdf60c92eca8b5e",
      "closedAt": "2021-07-11T16:59:30Z",
      "mergedAt": "2021-07-11T16:59:30Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3f76be963765d4267472d6fbbfa863c040303266"
      },
      "comments": [
        {
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Quick note: in a few places, we may need to speak of \"RTP and RTCP packets\" instead of just \"RTP packets\".\r\nAnd I noticed: \"A RTP packet\" -> \"An RTP packet\"",
          "createdAt": "2021-07-11T16:34:15Z",
          "updatedAt": "2021-07-11T16:34:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> Quick note: in a few places, we may need to speak of \"RTP and RTCP packets\" instead of just \"RTP packets\".\r\n> And I noticed: \"A RTP packet\" -> \"An RTP packet\"\r\n\r\nMakes sense. I'll merge this PR first and then create another one for these changes. ",
          "createdAt": "2021-07-11T16:59:24Z",
          "updatedAt": "2021-07-11T16:59:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzNjA1MDM4",
          "commit": {
            "abbreviatedOid": "137b2a4"
          },
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-11T16:33:06Z",
          "updatedAt": "2021-07-11T16:33:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzNjA1MzE1",
          "commit": {
            "abbreviatedOid": "137b2a4"
          },
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-11T16:37:01Z",
          "updatedAt": "2021-07-11T16:37:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3MzgwNzA3",
      "title": "Always name both, RTP and RTCP where applicable",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/5",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-11T18:57:12Z",
      "updatedAt": "2022-03-04T09:35:56Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f76be963765d4267472d6fbbfa863c040303266",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "always-name-rtp-and-rtcp",
      "headRefOid": "fff6f1b82db8b5e6844fcc5bf79002e96f0ac908",
      "closedAt": "2021-07-12T10:22:18Z",
      "mergedAt": "2021-07-12T10:22:18Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "4f0fea14d24c04f29aa3fcafe0e4f79c5400c042"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzODQxNTgy",
          "commit": {
            "abbreviatedOid": "fff6f1b"
          },
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T08:20:58Z",
          "updatedAt": "2021-07-12T08:20:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NjU4MzI0",
      "title": "Update outdated Draft/RFC references",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/6",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-12T09:15:38Z",
      "updatedAt": "2022-03-04T09:35:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f76be963765d4267472d6fbbfa863c040303266",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-references",
      "headRefOid": "15f11672d191f67668d8f0fb76be4d4a5eaf4f71",
      "closedAt": "2021-07-12T10:25:39Z",
      "mergedAt": "2021-07-12T10:25:39Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "e3a010e93ca98f3728f88125b02dc24567d59720"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOFUmh7s40AhbR",
      "title": "Restructure to focus on possible CC schemes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/7",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-06T22:25:47Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f6d8759952dd0467d94a90af3cdb242047ac2d48",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "restructure",
      "headRefOid": "f579bd940804a8ff627aba79e9080845ee43e5be",
      "closedAt": "2022-03-07T17:22:13Z",
      "mergedAt": "2022-03-07T17:22:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f579bd940804a8ff627aba79e9080845ee43e5be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOFUmh7s43e6Ao",
      "title": "Update congestion control and RTCP sections",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/8",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-09T08:01:31Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0fc59ccb6beec441751e338c93cf6f00b22ad8bc",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "03-updates",
      "headRefOid": "1f2fbc66d74f92fc40536a9be6b1ce93220c7715",
      "closedAt": "2022-05-12T06:46:45Z",
      "mergedAt": "2022-05-12T06:46:45Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2f9992fd4237f1ecfed20eeeee3332019344e989"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOFUmh7s43oL2r",
      "title": "Rtp over quic streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/9",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-11T07:45:02Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2f9992fd4237f1ecfed20eeeee3332019344e989",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtp-over-quic-streams",
      "headRefOid": "a4a771f55a825fe6d7a51b7d8ba550b27f66c2c3",
      "closedAt": "2022-05-12T06:49:02Z",
      "mergedAt": "2022-05-12T06:49:02Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5566b2ff06e22076423b0a8299c02a793826f805"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOFUmh7s44LJBs",
      "title": "Remove SDP section and fix some small issues",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/10",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-20T08:42:44Z",
      "updatedAt": "2022-07-19T07:32:34Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "5566b2ff06e22076423b0a8299c02a793826f805",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "04-updates",
      "headRefOid": "146a67e11b0daf16dc076f382d3ffe359885cdfd",
      "closedAt": "2022-06-24T07:30:05Z",
      "mergedAt": "2022-06-24T07:30:05Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "22e9908ca3a81b5d070c5215e720392e408e5bee"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOFUmh7s46QnSp",
      "title": "Update draft-engelbart-rtp-over-quic.md",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/12",
      "state": "MERGED",
      "author": "joerg-ott",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Various extensions: Scope, ALPN, Connection sharing, Discussion, various bits.",
      "createdAt": "2022-06-23T17:13:27Z",
      "updatedAt": "2022-06-24T07:20:10Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "04-updates",
      "baseRefOid": "2822ebc362f1c780cf5ec6a628048f4297b4f52b",
      "headRepository": "joerg-ott/rtp-over-quic-draft",
      "headRefName": "patch-3",
      "headRefOid": "c2277e23e182749891134a20f39fb3adf8009653",
      "closedAt": "2022-06-24T07:20:10Z",
      "mergedAt": "2022-06-24T07:20:09Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "66b788f2a38b4b5665947ed48cf3bc1b0551570f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOFUmh7s46avDw",
      "title": "Clarify stream types and explain stream closing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/17",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR clarifies which stream types are used (#14) and adds an explicit requirement to close streams once a packet was completely sent. Maybe we can also add considerations about stream concurrency (#15) here?",
      "createdAt": "2022-06-27T13:43:48Z",
      "updatedAt": "2022-09-23T07:22:48Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clarify-stream-usage",
      "headRefOid": "cda9b732f0efbc9cb80f3d5a0dd271cbd491055e",
      "closedAt": "2022-09-23T07:18:16Z",
      "mergedAt": "2022-09-23T07:18:16Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3dc40e5272c11761dadf086c4aa09ccac3e9fdda"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOFUmh7s47ZFKY",
      "title": "Update adopted name",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/18",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-14T09:23:11Z",
      "updatedAt": "2022-09-12T13:52:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "22e9908ca3a81b5d070c5215e720392e408e5bee",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-adopted-name",
      "headRefOid": "6274d14609a982be97c5f8749be2ef82929a577c",
      "closedAt": "2022-07-19T07:36:44Z",
      "mergedAt": "2022-07-19T07:36:44Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d556493e4c9539aa8613f81599e9f200e68a3d75"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOFUmh7s48NSGD",
      "title": "Clarify which flow id to use for retransmissions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/19",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #16 ",
      "createdAt": "2022-07-27T20:53:15Z",
      "updatedAt": "2022-09-23T07:22:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clarify-retransmission-flow-id",
      "headRefOid": "33019b0e75bbaea289c40182e2b2ee5baad27e2a",
      "closedAt": "2022-09-12T13:54:22Z",
      "mergedAt": "2022-09-12T13:54:22Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8b1c3e1a4dd08c56d933e79fbbecf30eb4ffa088"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOFUmh7s48jk1c",
      "title": "Remove TODO because it was done by adding sec. 8.3",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/28",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #20 ",
      "createdAt": "2022-08-03T07:49:30Z",
      "updatedAt": "2022-09-12T13:52:02Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "remove-shared-connection-todo",
      "headRefOid": "bda42b73707548953173646721be3925a7e9c5b1",
      "closedAt": "2022-09-12T13:45:26Z",
      "mergedAt": "2022-09-12T13:45:26Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "53acd6ef5e4f0247c4ee50eab0de921d4c8388c7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOFUmh7s48okeT",
      "title": "Remove note about possible use of RTCP in QUIC CC",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/30",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23 ",
      "createdAt": "2022-08-04T09:21:08Z",
      "updatedAt": "2022-09-12T13:51:48Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "delete-rtcp-quic-cc-note",
      "headRefOid": "77aff38d80ee441c98455424d1e5e3fd5c0f3828",
      "closedAt": "2022-09-12T13:46:33Z",
      "mergedAt": "2022-09-12T13:46:33Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2c8f9243df75eecdd180e79544cf294990fbd396"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Also fixes #11 ",
          "createdAt": "2022-08-04T09:22:43Z",
          "updatedAt": "2022-08-04T09:22:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOFUmh7s48qrHe",
      "title": "Delete note because it won't be a problem",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/32",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "closes #22 ",
      "createdAt": "2022-08-04T17:10:24Z",
      "updatedAt": "2022-09-12T13:51:46Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2c8f9243df75eecdd180e79544cf294990fbd396",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "delete-delay-based-cc-note",
      "headRefOid": "04ba7637bfd1e38f8ea439b2831fd79d1ec45352",
      "closedAt": "2022-09-12T13:51:06Z",
      "mergedAt": "2022-09-12T13:51:06Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "710f7cf91c079d10da8819655f47711687aade15"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOFUmh7s4-w8lx",
      "title": "Clarify what *adequate congestion control* means",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/33",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Reference RFC 9002 and 8085 to clarify what adequate congestion control means. closes #26 ",
      "createdAt": "2022-09-12T09:17:13Z",
      "updatedAt": "2022-09-23T07:22:40Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "cite-cc-requirements",
      "headRefOid": "a6eaa3ffe0b7e3890a0b3270c1748f8cb3637f64",
      "closedAt": "2022-09-23T07:19:09Z",
      "mergedAt": "2022-09-23T07:19:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOFUmh7s4-yJAB",
      "title": "Stream concurrency considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/34",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-12T13:17:02Z",
      "updatedAt": "2022-10-24T14:28:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "stream-concurrency-considerations",
      "headRefOid": "1bfbfdfb99bd9db7734530440fc7a6eef12b7fdc",
      "closedAt": "2022-10-24T14:28:41Z",
      "mergedAt": "2022-10-24T14:28:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "413d581274edc938e14112cbb917c7557091cf48"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOFUmh7s4-y4Ln",
      "title": "State requirements instead of certain algorithms",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/36",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-12T15:37:16Z",
      "updatedAt": "2022-10-24T14:41:47Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "cc-requirements",
      "headRefOid": "95797c0a352853695d88558a36135ed0f863c8fa",
      "closedAt": "2022-10-24T14:41:46Z",
      "mergedAt": "2022-10-24T14:41:46Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "651d67471b525e2343e7a2d9e9fa08fc35070e97"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 37,
      "id": "PR_kwDOFUmh7s4_Ls2d",
      "title": "Add recommendation to expose estimated bandwidth",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/37",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #35 ",
      "createdAt": "2022-09-19T09:10:17Z",
      "updatedAt": "2022-09-23T07:22:31Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8b1c3e1a4dd08c56d933e79fbbecf30eb4ffa088",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "add-bandwidth-estiation-api",
      "headRefOid": "f10ba95ccd7b7eda4b32ac155f1e853d7451e688",
      "closedAt": "2022-09-22T08:50:13Z",
      "mergedAt": "2022-09-22T08:50:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f1afdd8ff421a4d143a238427d0c5730c3b4cb21"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "PR_kwDOFUmh7s4_LtF9",
      "title": "Relax CC API configuration requirement",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/38",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "resolve #27 ",
      "createdAt": "2022-09-19T09:11:12Z",
      "updatedAt": "2022-10-24T15:00:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "api-for-congestion-controller-configuration",
      "headRefOid": "7527d2080b19e5d4587019e33df1bf0e20b197f4",
      "closedAt": "2022-10-24T15:00:34Z",
      "mergedAt": "2022-10-24T15:00:34Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8e4b8d8cca656b8faa2881aa8de87d0c507bc9ea"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "PR_kwDOFUmh7s4_eh7c",
      "title": "Add topology subsection",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/40",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-23T07:11:45Z",
      "updatedAt": "2022-10-24T15:26:29Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d562b3b4786f7cf566efab3afa98bc27156dd2a7",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtp-topology-considerations",
      "headRefOid": "ff1e84968415e0dac3c289d5e028ff8e126ac385",
      "closedAt": "2022-10-24T15:26:28Z",
      "mergedAt": "2022-10-24T15:26:28Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "a1326e571e772fb6bad0924ab54fe4f7151500df"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks!\r\n\r\nI added another commit with the changes you suggested. I added a sentence about forwarding RESET_STREAM frames to section 6.1 because I think it might be confusing to reference the concept of closing streams via RESET_STREAM frames early in the document (even before the mapping to streams is introduced).\r\nAlternatively, we could move the topology considerations section to the back of the document.",
          "createdAt": "2022-09-29T10:20:59Z",
          "updatedAt": "2022-09-29T10:20:59Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "\"Once the RTP packet has been completely transmitted, the sender MUST gracefully close the stream.\"\r\n\r\n[BA] How does the translator know that the RTP packet has been completely transmitted?  It could know if it receives a FIN, or alternatively if there is a length field at the beginning of the packet. But what happens if it never receives the full length (or a RESET_STREAM)?\r\n\r\nIf the translator implements \"cut through\" behavior, rather than \"store and forward\", sending what it receives (including a FIN or a RESET_STREAM) it would seem that the above text isn't necessary.  The translator could function, even in situations where it wouldn't know if the RTP packet has been completely transmitted. ",
          "createdAt": "2022-09-29T14:10:00Z",
          "updatedAt": "2022-09-29T14:13:37Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I am not sure I understand your question. I added the sentence in https://github.com/mengelbart/rtp-over-quic-draft/pull/17 to make sure a sender closes the stream after each packet so that a receiver knows when the packet was completely received. We may delete it again if we decide to add a length field, but I'd like to keep it for now. If a translator never receives the full length there will be a RESET_STREAM, which it then has to forward:\r\n\r\n> A translators that translates between two endpoints, which are both connected via QUIC, MUST forward RESET\\_STREAM frames received from one end to the other end, unless it is forwarding the RTP packets on QUIC datagrams.\r\n",
          "createdAt": "2022-09-30T07:51:16Z",
          "updatedAt": "2022-09-30T07:51:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Ct9xS",
          "commit": {
            "abbreviatedOid": "ae86df3"
          },
          "author": "aboba",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "\"the translator either may need to rewrite\"\r\n\r\n[BA] Can we delete the \"either\"?  Also, you might want to clarify that you are referring to a \"transport translator\" that could need codec-specific knowledge to do the packetization from frame/stream to datagram transport. \r\n\r\nWhat happens if a translator receives a RESET_STREAM frame?  Is it still required to do a graceful close?  Maybe just require the translator to echo the behavior that it sees (e.g. if it receives a graceful close, then send one, if it receives a RESET_STREAM, then send that along, unless it is forwarding datagrams). \r\n\r\n",
          "createdAt": "2022-09-24T21:54:03Z",
          "updatedAt": "2022-09-24T21:55:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOFUmh7s5A6nIu",
      "title": "Add length field and allow multiple packets per stream",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/43",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-17T10:15:36Z",
      "updatedAt": "2022-10-24T15:03:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "651d67471b525e2343e7a2d9e9fa08fc35070e97",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "length-field",
      "headRefOid": "410ae215371184370dc8a719a7a21e9540857640",
      "closedAt": "2022-10-24T15:03:43Z",
      "mergedAt": "2022-10-24T15:03:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d562b3b4786f7cf566efab3afa98bc27156dd2a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "PR_kwDOFUmh7s5A6v0x",
      "title": "Allow mixing of streams and datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/44",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-17T10:43:59Z",
      "updatedAt": "2022-10-24T14:30:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "mix-streams-and-datagrams",
      "headRefOid": "8202836850710f6992d18848f678b2bc50cfe22e",
      "closedAt": "2022-10-24T14:30:03Z",
      "mergedAt": "2022-10-24T14:30:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "dd403df25b65ac476b981d57210909f21205be70"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 46,
      "id": "PR_kwDOFUmh7s5CIK_j",
      "title": "WIP: Rely on WebTransport for multiplexing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/46",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR is a first draft to integrate WebTransport as an abstraction layer on top of QUIC to provide multiplexing.",
      "createdAt": "2022-11-03T11:13:02Z",
      "updatedAt": "2023-05-11T16:09:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/webtransport-multiplexing",
      "headRefOid": "5c2551fc826b227e7a0c3be5e3a87907b7763209",
      "closedAt": "2022-12-21T15:28:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOFUmh7s5F96PE",
      "title": "Add new multiplexing subsection using flow IDs",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/54",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-21T15:28:28Z",
      "updatedAt": "2023-01-17T09:58:26Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/flow-id-multiplexing",
      "headRefOid": "b24f20edd9f04e668ee0a6c43f47b2c680f0dcdf",
      "closedAt": "2023-01-17T09:58:25Z",
      "mergedAt": "2023-01-17T09:58:25Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "99a1494c2c913bd234bb77016e89d30e09e35aa2"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Has been proposed on mailing list. Question from @aboba, discussed with @mengelbart. OK to merge. ",
          "createdAt": "2023-01-13T16:08:31Z",
          "updatedAt": "2023-01-13T16:08:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOFUmh7s5HT6_A",
      "title": "Clarify highest sequence number mapping",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/56",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-13T09:04:45Z",
      "updatedAt": "2023-05-11T16:09:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/highest-sequence-nr",
      "headRefOid": "842c0164f9ec95191056e4ff2a9c9098b6b64e86",
      "closedAt": "2023-01-23T15:19:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Included in #60 ",
          "createdAt": "2023-01-23T15:19:31Z",
          "updatedAt": "2023-01-23T15:19:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOFUmh7s5HT7Kg",
      "title": "Generalize which packets should be included",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/57",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "RTP packets can now also be sent in streams, thus it makes sense to say RTP packet (which could be in a datagram or stream) instead of datagram frame here.",
      "createdAt": "2023-01-13T09:05:24Z",
      "updatedAt": "2023-05-11T16:09:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/fraction-lost",
      "headRefOid": "d0e586ee6465509d6b42aa5081d3fc073c556502",
      "closedAt": "2023-01-17T09:39:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Will be solved in #60 ",
          "createdAt": "2023-01-17T09:39:57Z",
          "updatedAt": "2023-01-17T09:39:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOFUmh7s5HgED1",
      "title": "Address many/most of comments from @goelvidhi",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/60",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This should be worth reviewing now, while I work on larger topics. \r\n\r\nComments and corrections are graciously welcomed. \r\n\r\nfixes #53 ",
      "createdAt": "2023-01-16T23:11:21Z",
      "updatedAt": "2023-01-23T15:51:33Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "99a1494c2c913bd234bb77016e89d30e09e35aa2",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "53-comments",
      "headRefOid": "d5f3d0f52256b01f836aee3fc21876e0ffc22c28",
      "closedAt": "2023-01-23T15:51:32Z",
      "mergedAt": "2023-01-23T15:51:32Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "3aae64deaee45942de470598192db9a44e8b063a"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I have a couple of open questions in the comments on this PR for you - do you think this PR is ready to commit, so we can focus on more specific issues (some of which I've opened in the last day or two)?",
          "createdAt": "2023-01-20T17:22:53Z",
          "updatedAt": "2023-01-20T17:22:53Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, @SpencerDawkins! I think I replied to all questions, and I think we can discuss the congestion control vs. rate adaptation question in #61, and we can merge this PR.",
          "createdAt": "2023-01-23T15:25:22Z",
          "updatedAt": "2023-01-23T15:25:22Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I found one typo, and corrected it. I'm merging now. ",
          "createdAt": "2023-01-23T15:51:05Z",
          "updatedAt": "2023-01-23T15:51:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5KkxGZ",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-17T09:03:46Z",
          "updatedAt": "2023-01-17T09:38:38Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "additional",
              "createdAt": "2023-01-17T09:03:46Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 134,
              "body": "Should we also reference [Section 6 of RFC 9002](https://www.rfc-editor.org/rfc/rfc9002.html#section-6) here?\r\n```suggestion\r\n    but can detect lost packets based on the Gap numbers contained in QUIC ACK frames {{Section 6 of !RFC9002}}.\r\n```",
              "createdAt": "2023-01-17T09:20:20Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nfor QUIC is an alogrithm similar to TCP NewReno {{!RFC9002}}, but senders are free to choose\r\n```\r\n`!` makes it a normative reference, `?` for informative.",
              "createdAt": "2023-01-17T09:22:16Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 108,
              "body": "```suggestion\r\n    packets that were sent after the RTP packet, were already acknowledged.\r\n```\r\n\r\nIn streams, the RTP packet can be spread over many frames.",
              "createdAt": "2023-01-17T09:29:01Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 116,
              "body": "In another PR I added some more text to explain what the highest sequence number is in RTP:\r\n```\r\n  * Highest Sequence Number received*: In RTCP, this field is a 32-bit field\r\n    that contains the highest sequence number a receiver received in an RTP\r\n    packet and the count of sequence number cycles the receiver has observed. A\r\n    sender sends RTP packets in QUIC packets and receives acknowledgments for\r\n    the QUIC packets. By keeping a mapping from a QUIC packet to the RTP packets\r\n    encapsulated in that QUIC packet, the sender can infer the highest sequence\r\n    number and number of cycles seen by the receiver from QUIC acknowledgments.\r\n```\r\n\r\nDoes it make sense to add this explanation, and if yes, should we add it to this PR?",
              "createdAt": "2023-01-17T09:38:21Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5KqgK3",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:28:43Z",
          "updatedAt": "2023-01-18T00:28:44Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I think we should add this explanation. (Whether it is done here or in a separate PR, authors can decide that.)",
              "createdAt": "2023-01-18T00:28:43Z",
              "updatedAt": "2023-01-18T00:28:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Kqgf6",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:30:51Z",
          "updatedAt": "2023-01-18T00:30:51Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "This reference and text is confusing. The text says TCP Reno but then it refers to QUIC Reno. I would just change this to, `The default congestion control specified for QUIC is Reno {{!RFC 9002}}`",
              "createdAt": "2023-01-18T00:30:51Z",
              "updatedAt": "2023-01-18T00:30:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5KqgnW",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:31:35Z",
          "updatedAt": "2023-01-18T00:31:35Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "replace congestion control with rate adaptation?",
              "createdAt": "2023-01-18T00:31:35Z",
              "updatedAt": "2023-01-18T00:31:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LN3NV",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T14:32:20Z",
          "updatedAt": "2023-01-19T14:32:20Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Corrected.",
              "createdAt": "2023-01-19T14:32:20Z",
              "updatedAt": "2023-01-19T14:32:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOIUL",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:07:43Z",
          "updatedAt": "2023-01-19T15:07:43Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "@goelvidhi is right - this text/reference **is** scrambled. My thoughts are\r\n\r\n- TCP NewReno is [RFC6582]\r\n- the default QUIC congestion controller is [RFC9002] \r\n- [RFC9002] says \r\n> This document specifies a sender-side congestion controller for QUIC similar to TCP NewReno [RFC6582].\r\n\r\nSo, putting all this together, I get \r\n\r\n> The default congestion control specified for QUIC in {{RFC9002}} is similar to TCP NewReno {{RFC6582}}\r\n\r\nwhich (IIUC) gives the references for QUIC's default congestion controller and TCP NewReno correctly. \r\n\r\nPlease let me know if this is a Really Bad Idea.",
              "createdAt": "2023-01-19T15:07:43Z",
              "updatedAt": "2023-01-19T15:07:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOJbh",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:10:08Z",
          "updatedAt": "2023-01-19T15:10:08Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "Fixed. ",
              "createdAt": "2023-01-19T15:10:08Z",
              "updatedAt": "2023-01-19T15:10:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOPJC",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:22:17Z",
          "updatedAt": "2023-01-19T15:22:18Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "@mengelbart, I agree with @goelvidhi about adding this text. I put it in #60, so if it's also in another PR (which I haven't looked for yet), that should also be fine. ",
              "createdAt": "2023-01-19T15:22:18Z",
              "updatedAt": "2023-01-19T15:22:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LVlVc",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-20T16:21:26Z",
          "updatedAt": "2023-01-20T16:21:27Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "This is, of course, going to be maximally confusing to the reader, because RFC 8888 **says** it's enabling congestion control, but I think this is a good change to make for consistency in RTP-over-QUIC. \r\n\r\nLooking more closely at this text, RFC 8888 isn't technically part of \"RTP\", because it doesn't update any other RFC, so I think this is more accurate: \r\n\r\n> RTP itself does not specify a congestion control algorithm, but {{!RFC8888}} defines an RTCP\r\n> feedback message intended to enable rate adaptation for interactive real-time traffic using RTP,\r\n> and successful rate adaptation will accomoplish congestion control as well.\r\n> Various rate adaptation algorithms for real-time media are defined in separate RFCs\r\n> (e.g. SCReAM {{!RFC8298}} and NADA {{!RFC8698}}).\r\n\r\nAnd, looking more closely at the Abstract and Introduction, I think I should be naming both congestion control and rate adaptation in both places, and then favoring the use of rate adaptation thereafter. \r\n\r\nPlease let me know if this seems wrong or unhelpful. ",
              "createdAt": "2023-01-20T16:21:26Z",
              "updatedAt": "2023-01-20T16:21:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LckYt",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:11:11Z",
          "updatedAt": "2023-01-23T15:11:11Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Sounds good to me.",
              "createdAt": "2023-01-23T15:11:11Z",
              "updatedAt": "2023-01-23T15:11:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Lcn1Z",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:18:46Z",
          "updatedAt": "2023-01-23T15:18:46Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Sounds mostly fine to me, but I wonder if we need the part \"and successful rate adaptation will accomoplish congestion control as well.\"? I think it might bring up the question of how exactly we define both and what the difference is.",
              "createdAt": "2023-01-23T15:18:46Z",
              "updatedAt": "2023-01-23T15:18:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LcpEK",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:21:24Z",
          "updatedAt": "2023-01-23T15:21:24Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Oh, I just saw #61 is about this question. If we have some text early in the document that defines both terms, the question might have been answered already.",
              "createdAt": "2023-01-23T15:21:24Z",
              "updatedAt": "2023-01-23T15:21:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOFUmh7s5JzKQ7",
      "title": "Add Scoping description for Abstract and Introduction",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/63",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "First draft of updated Abstract and Introduction sections.\r\n\r\nObviously a close read from reviewers will be useful, but I'd especially call attention to whether the abstract and first part of the Introduction correctly summarize the document (my impression is that the scope of the document has increased over time, but the abstract and Introduction might not have captured the new scope). \r\n\r\nCloses #58.",
      "createdAt": "2023-02-12T19:38:03Z",
      "updatedAt": "2023-02-20T08:46:25Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2853821a8d8d121809381041786178157c36863e",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-58",
      "headRefOid": "503d7fea280f75eddf319589da78ac46f1742e83",
      "closedAt": "2023-02-20T08:46:24Z",
      "mergedAt": "2023-02-20T08:46:24Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "157005404bf8dcf5b7cfd0305e8379454bdadd24"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5NMohN",
          "commit": {
            "abbreviatedOid": "8a01814"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T08:39:47Z",
          "updatedAt": "2023-02-13T08:42:22Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nThis document does not cover signaling for session setup. SDP for RTP-over-QUIC is defined in separate documents such as {{?I-D.draft-dawkins-avtcore-sdp-rtp-quic}}, and can be carried in any signaling protocol that can carry SDP, including the Session Initiation Protocol (SIP) ({{?RFC3261}}), Real-Time Protocols for Browser-Based Applications (RTCWeb) ({{?RFC8825}}), or WebRTC-HTTP Ingestion Protocol (WHIP) ({{?I-D.draft-ietf-wish-whip}}).\r\n```",
              "createdAt": "2023-02-13T08:39:47Z",
              "updatedAt": "2023-02-13T08:42:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOFUmh7s5Jzl0X",
      "title": "First draft of definitions for congestion control and rate adaptation",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/64",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This is a starting place for several related issues (#61, #62, and #59). \r\n\r\nCloses #61 ",
      "createdAt": "2023-02-13T02:12:34Z",
      "updatedAt": "2023-02-20T08:25:15Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3aae64deaee45942de470598192db9a44e8b063a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-61",
      "headRefOid": "38208ae4366856d8af03d9a25f65763e1936d712",
      "closedAt": "2023-02-20T08:25:13Z",
      "mergedAt": "2023-02-20T08:25:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2853821a8d8d121809381041786178157c36863e"
      },
      "comments": [
        {
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "body": "The above definitions state that rate adaptation is \"distinct\" from congestion control. But the distinction mentioned only covers the case in which one choose across multiple media flows and some aggregate congestion control can be performed. This appears to be a special case. Rate adaptation is generally one way to achieve congestion control, it would seem, and maybe in some cases the only one. Needs more thinking.",
          "createdAt": "2023-02-17T13:11:19Z",
          "updatedAt": "2023-02-17T13:11:19Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> The above definitions state that rate adaptation is \"distinct\" from congestion control. But the distinction mentioned only covers the case in which one choose across multiple media flows and some aggregate congestion control can be performed. This appears to be a special case. Rate adaptation is generally one way to achieve congestion control, it would seem, and maybe in some cases the only one. Needs more thinking.\r\n\r\n@joerg-ott, I agree. I've rephrased this in my latest commit. \r\n\r\nWe will definitely need more thinking here - I see that Christian @Huitema has a [specific proposal for congestion response in MOQ](https://mailarchive.ietf.org/arch/msg/moq/sWDaR6lRu3tBLOvHkth-sipbf4Q/). That may not be directly applicable to RTP-over-QUIC, but it's a good example of the kind of this we should also consider in your draft. \r\n\r\nBut given that we have other issues for adding specific descriptions of rate control and this PR only targeted adding definitions, I think this PR is ready to merge. ",
          "createdAt": "2023-02-19T13:12:17Z",
          "updatedAt": "2023-02-19T13:12:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 66,
      "id": "PR_kwDOFUmh7s5KSPO6",
      "title": "Adding ACKs for Bernard and Sergio",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/66",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-19T13:29:48Z",
      "updatedAt": "2023-02-20T08:24:09Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3aae64deaee45942de470598192db9a44e8b063a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-55",
      "headRefOid": "1f5c8ac696100a566e47b2a7e193111c813309fc",
      "closedAt": "2023-02-20T08:24:08Z",
      "mergedAt": "2023-02-20T08:24:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "05e5c1ba8f73d9d397a8d0b44ffec761690eaa60"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "PR_kwDOFUmh7s5M78fH",
      "title": "Add @mengelbart RTCP analysis",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/71",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "It is likely that these new sections/tables need to be more carefully integrated into the previous text on RTCP. \r\n\r\nclose #48 ",
      "createdAt": "2023-03-27T05:55:49Z",
      "updatedAt": "2023-04-27T07:05:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-48",
      "headRefOid": "426ca2b6c2d9de95f505db7f341063641214d73a",
      "closedAt": "2023-04-27T07:05:40Z",
      "mergedAt": "2023-04-27T07:05:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3624f2fa943fa8b7c8f491d36c908525e0b8ed32"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We should add \"header extensions\" to the section title (@SpencerDawkins agrees). ",
          "createdAt": "2023-04-19T17:04:42Z",
          "updatedAt": "2023-04-19T17:04:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I still need to work on Section 6.3. RTCP Control Packet Types - several of these packet types have \"\"partly\" or \"possibly\" under \"replaced by QUIC\", because they have multiple reports, and the answer to \"replaced by QUIC\" varies among the reports. My plan is to break those cases into one row per report, so the ability to map to/from QUIC is clearer. \r\n\r\nI don't think that will take long, but I think we should wait to merge until I can finish that. ",
          "createdAt": "2023-04-25T00:41:09Z",
          "updatedAt": "2023-04-25T00:41:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I think it's OK for us to merge this PR. There's still more analysis to do, but I'd like to land this PR and work on a couple of issues that I still haven't touched. ",
          "createdAt": "2023-04-26T23:28:11Z",
          "updatedAt": "2023-04-26T23:28:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5SlRpS",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Some of the information in the new tables in sections 6.3 and 6.4 duplicates what is written in sections 6.1 and 6.2. It could be helpful to have subsections for the details of each packet type and then reference the subsection from the tables. That would also make the tables easier to read.",
          "createdAt": "2023-04-14T13:51:44Z",
          "updatedAt": "2023-04-14T16:16:41Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Should we rename the section from just *RTCP* to *RTCP and RTP Header Extensions* if we add the subsection on header extensions?",
              "createdAt": "2023-04-14T13:51:44Z",
              "updatedAt": "2023-04-14T16:16:41Z"
            },
            {
              "originalPosition": 85,
              "body": "This table contains only *no*s and does not add anything that cannot be found in the IANA registry. I think we can replace it with a more general statement that payload-specific feedback types are not suitable to be replaced by the QUIC state.",
              "createdAt": "2023-04-14T13:54:39Z",
              "updatedAt": "2023-04-14T16:16:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TGKMY",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T14:22:54Z",
          "updatedAt": "2023-04-20T14:22:54Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I agree. I'm making this change. ",
              "createdAt": "2023-04-20T14:22:54Z",
              "updatedAt": "2023-04-20T14:22:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TGVb4",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T14:41:54Z",
          "updatedAt": "2023-04-20T14:41:54Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think this is a good suggestion - I added \"Because QUIC is a generic transport protocol, QUIC cannot replace the following Payload-specific RTP Feedback (PSFB) feedback\" at the beginning of the section, but I left the list of feedback types and their documents in the text, just to make what we considered, clear to the reader. \r\n\r\nDoes that make sense?",
              "createdAt": "2023-04-20T14:41:54Z",
              "updatedAt": "2023-04-20T14:41:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TpFvt",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T06:27:27Z",
          "updatedAt": "2023-04-27T06:27:28Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Yes, that sounds good. Thanks!",
              "createdAt": "2023-04-27T06:27:27Z",
              "updatedAt": "2023-04-27T06:27:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOFUmh7s5M8bB2",
      "title": "Add details on supported topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/72",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Note: we have introduced a MUST in this PR, so the guidance isn't entirely \"informational\". \r\n\r\ncloses #47 ",
      "createdAt": "2023-03-27T07:43:47Z",
      "updatedAt": "2023-04-27T06:26:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-47",
      "headRefOid": "e7f6496014e9f0f08c26a187b2be2c8317d96bec",
      "closedAt": "2023-04-27T06:26:03Z",
      "mergedAt": "2023-04-27T06:26:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "7271014e241950bafb3a8982decd7aacb3963c42"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We're assuming that each topology is considered on its own. If (for example) Topo-Media-Translator  is also doing Topo-Trn-Translator, look at both rows in the table. But we note that with Topo-Back-To-Back, all bets are off ... ",
          "createdAt": "2023-04-19T16:33:21Z",
          "updatedAt": "2023-04-19T16:33:21Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I think this PR is ready to merge. ",
          "createdAt": "2023-04-20T14:13:16Z",
          "updatedAt": "2023-04-20T14:13:16Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - this is definitely ready to merge now. ",
          "createdAt": "2023-04-26T23:35:20Z",
          "updatedAt": "2023-04-26T23:35:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5SmTHO",
          "commit": {
            "abbreviatedOid": "a43ccbf"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "In my local rendering, the notes get squeezed into the table with very narrow columns, which makes it hard to read. Is there a better format we could use instead of a table, or maybe we could replace the footnotes with subsections that we can reference from the table?",
          "createdAt": "2023-04-14T16:19:53Z",
          "updatedAt": "2023-04-14T16:22:46Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Should we add this to the security considerations as well?",
              "createdAt": "2023-04-14T16:19:54Z",
              "updatedAt": "2023-04-14T16:22:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Tc41b",
          "commit": {
            "abbreviatedOid": "aa52f1d"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-25T14:40:53Z",
          "updatedAt": "2023-04-25T14:40:54Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I think this was meant to say *Burst Source* instead of *Distribution Source*. But I just re-read the text about SSM in RFC 7667, and I think we can actually drop this last part of the sentence here and also for `Note-UCast-Mcast`. I don't know why I thought *Distribution Source* and *Burst Source* could just be *logical entities*. The text says:\r\n\r\n> These sources send media to a dedicated Distribution Source, which forwards the RTP streams to the multicast group on behalf of the original RTP sources.\r\n\r\nSorry, I didn't catch that earlier!",
              "createdAt": "2023-04-25T14:40:54Z",
              "updatedAt": "2023-04-25T14:40:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOFUmh7s5M8pTo",
      "title": "Add additional congestion control-related terms and definitions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/73",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #70 ",
      "createdAt": "2023-03-27T08:25:04Z",
      "updatedAt": "2023-04-14T12:25:00Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-70",
      "headRefOid": "9b7247c9bc3738b0a363c611f051fef3989db13e",
      "closedAt": "2023-04-14T12:24:58Z",
      "mergedAt": "2023-04-14T12:24:58Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "428885d6e5ea8ed92e2feb21597758813aae42bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Q-zjV",
          "commit": {
            "abbreviatedOid": "9b7247c"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-27T08:51:59Z",
          "updatedAt": "2023-03-27T08:51:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOFUmh7s5OV3Nh",
      "title": "Replace \"RTP over QUIC\" with RoQ acronym",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/78",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #74 ",
      "createdAt": "2023-04-14T16:05:25Z",
      "updatedAt": "2023-04-27T07:14:14Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3624f2fa943fa8b7c8f491d36c908525e0b8ed32",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/acronym-roq",
      "headRefOid": "6db9f03a13d5a47b5091b7026cffc898db1206f4",
      "closedAt": "2023-04-27T07:14:13Z",
      "mergedAt": "2023-04-27T07:14:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "037be428ba688e19be178587a26b5fdce617b11b"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> Definitely - do it!\r\n> \r\n> One question - merging this won't update the text I have in my PRs. Do you think it will be easier to resolve conflicts if you merge this one first? If so, DEFINITELY - do it!\r\n> \r\n> If not, please let me know, and I'll work on rebasing my PRs (or whatever the right answer is).\r\n\r\nMerging the PRs first and now rebasing and updating this one was easier, so no need to change anything in your PRs :) Will merge this now, too.",
          "createdAt": "2023-04-27T07:14:01Z",
          "updatedAt": "2023-04-27T07:14:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5TlcJx",
          "commit": {
            "abbreviatedOid": "312aa0a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Definitely - do it! \r\n\r\nOne question - merging this won't update the text I have in my PRs. Do you think it will be easier to resolve conflicts if you merge this one first? If so, DEFINITELY - do it!\r\n\r\nIf not, please let me know, and I'll work on rebasing my PRs (or whatever the right answer is).",
          "createdAt": "2023-04-26T16:00:23Z",
          "updatedAt": "2023-04-26T16:00:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOFUmh7s5P017x",
      "title": "Explain why we aren't making BCP recommendations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/81",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "@aboba, thank you for the example in your comment on #69. That was helpful. \r\n\r\nclose #69",
      "createdAt": "2023-05-05T02:13:32Z",
      "updatedAt": "2023-05-11T07:49:34Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "037be428ba688e19be178587a26b5fdce617b11b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-69",
      "headRefOid": "7d49c6f61c8242462ca2d721c4725afd39d0af25",
      "closedAt": "2023-05-11T07:49:33Z",
      "mergedAt": "2023-05-11T07:49:33Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5UrQU8",
          "commit": {
            "abbreviatedOid": "7d49c6f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-10T13:17:29Z",
          "updatedAt": "2023-05-10T13:17:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOFUmh7s5P1CSN",
      "title": "Provide guidance for coexisting control loops",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/83",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I want to provide a bit more description of GCC and classic response to packet loss, but I'm happy to get feedback on what I've committed so far. \r\n\r\nclose #59 ",
      "createdAt": "2023-05-05T03:51:40Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ce5bf21aa30f3790040352c3e84942c199bc1780",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-59",
      "headRefOid": "e052610a0d9510c6f5fd2a0e50438f3d8a886649",
      "closedAt": "2023-05-16T20:24:55Z",
      "mergedAt": "2023-05-16T20:24:54Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8dbb4db2bb1c951a00b4bb871ff94d2f809c7022"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @joerg-ott -\r\n\r\n> I want to provide a bit more description of GCC and classic response to packet loss, but I'm happy to get feedback on what I've committed so far.\r\n\r\nI've now done so, and I think this PR is ready for review. ",
          "createdAt": "2023-05-05T17:46:29Z",
          "updatedAt": "2023-05-05T17:46:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I corrected the spelling error and replied to the comment about GCC. If you think we need to discuss the GCC comment for a bit, please let me know, otherwise this PR should be ready to merge. ",
          "createdAt": "2023-05-11T01:11:07Z",
          "updatedAt": "2023-05-11T01:11:07Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @mengelbart - I worked over Section 7.4, but have one question that you're more likely to know the answer to than I am. \r\n\r\nFor the flow identifier described in the multiplexing section, I see \r\n\r\n>Each flow identifier is associated with a _stream of RTP packets_, _RTCP packets_, or a _data stream of a non-RTP protocol_\r\n\r\nIf I am **_using datagrams to carry multiple channels between two RTP endpoints_**, do we ALSO use this flow identifier to disambiguate (say) the datagrams carrying video, left-side audio, and right-side audio over the same QUIC connection?",
          "createdAt": "2023-05-12T15:47:11Z",
          "updatedAt": "2023-05-12T15:47:11Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.",
          "createdAt": "2023-05-12T16:50:42Z",
          "updatedAt": "2023-05-12T16:50:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart, \r\n\r\n> I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.\r\n\r\nIt's multiplexing all the way down, isn't it? Like \"[turtles all the way down](https://en.wikipedia.org/wiki/Turtles_all_the_way_down#:~:text=The%20saying%20alludes%20to%20the,larger%20turtles%20that%20continues%20indefinitely.)\". \r\n\r\n- I do want to check whether there's a list of levels of multiplexing in the draft, because that would be helpful, but \r\n- I want even more to make sure there's a list, where we can put a reference to the World Turtle. :grinning:",
          "createdAt": "2023-05-16T13:02:59Z",
          "updatedAt": "2023-05-16T13:02:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "There is [RFC 8872](https://datatracker.ietf.org/doc/html/rfc8872), which might help. We'd also need to reference the multiplexing section where the flow ID is explained. And maybe we should add a reference to 8872 in that section...",
          "createdAt": "2023-05-16T13:28:12Z",
          "updatedAt": "2023-05-16T13:28:12Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I just noticed this text in 8.2: \r\n\r\n> Disable Congestion Controller: If congestion control is to be implemented at the application layer as described in Section 7.2, and the application layer is trusted to apply adequate congestion control as described in Section 7 of [RFC9002] and Section 3.1 of [RFC8085], **it is RECOMMENDED to allow the application to disable QUIC layer congestion control entirely.**\r\n\r\nI need to remove this mention of disabling QUIC layer congestion control before we merge the PR. ",
          "createdAt": "2023-05-16T15:59:26Z",
          "updatedAt": "2023-05-16T15:59:26Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll add this reference and RFC 8872 in another PR. \r\n\r\n> I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.\r\n\r\n",
          "createdAt": "2023-05-16T16:50:26Z",
          "updatedAt": "2023-05-16T16:50:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5UrUXN",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T13:25:29Z",
          "updatedAt": "2023-05-10T13:28:36Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "If this is a normative reference, would it be helpful to reference NADA or SCReAM instead of the GC draft?",
              "createdAt": "2023-05-10T13:25:29Z",
              "updatedAt": "2023-05-10T13:28:36Z"
            },
            {
              "originalPosition": 92,
              "body": "`mazimizing` -> `maximizing`",
              "createdAt": "2023-05-10T13:28:22Z",
              "updatedAt": "2023-05-10T13:28:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5UuzxQ",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T00:56:07Z",
          "updatedAt": "2023-05-11T00:56:07Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "This is a reasonable question. I think the answer is that GCC targets transport protocols that are not aware that they are carrying media, while NADA and SCReAM target RTP applications that are aware they are performing rate adaptation for media, so the thing to do in this transport protocol section, is to cite GCC.\r\n\r\nDoes that make sense?",
              "createdAt": "2023-05-11T00:56:07Z",
              "updatedAt": "2023-05-11T00:56:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5UwVRV",
          "commit": {
            "abbreviatedOid": "519846f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T07:48:52Z",
          "updatedAt": "2023-05-11T07:48:53Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "To me, all three seem to target RTP applications, and the GCC draft references multiple RTP header extensions and RTCP feedback messages which were explicitly designed for GCC.\r\n\r\nAnother alternative to mention could be BBR. However, I don't know if that is a good recommendation for media. I think it has been mentioned somewhere that BBRs probing phases are problematic for real-time media.\r\n\r\nBBR also (still?) seems to be a draft, so we might not want to use it as a normative reference, either. I think we have this problem with other references, too, but I'd like to avoid adding more normative references to draft documents if possible (at least if the documents are expired and don't seem to be actively developed any longer). Regardless of which algorithm we reference here, does the reference have to be normative?",
              "createdAt": "2023-05-11T07:48:52Z",
              "updatedAt": "2023-05-11T07:48:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5U1UW3",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T19:06:25Z",
          "updatedAt": "2023-05-11T19:06:25Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "@mengelbart - I'm replying here, just to preserve our helpful discussion which was also happening in Slack. Here's what I've got, point by point. \r\n\r\n> To me, all three seem to target RTP applications, and the GCC draft references multiple RTP header extensions and RTCP feedback messages which were explicitly designed for GCC.\r\n\r\nI think we're struggling a bit, because the draft is not internally consistent (yet) - for example, if we are writing a specification that assumes QUIC implementations know that our packets are media (perhaps because the connection uses rtp-mux-quic as its ALPN, rather than h3, or some other non-media ALPN), that's different from assuming that QUIC implementations don't know that our packets are media, and have to use a congestion controller-rate adapter that works for any packets, without special knowledge. \r\n\r\nAs I said in SLACK, if we CAN have real-time and non-real-time packets in the same QUIC connection, that has different implications. So, we need to be looking for inconsistencies. \r\n\r\n> Another alternative to mention could be BBR. However, I don't know if that is a good recommendation for media. I think it has been mentioned somewhere that BBRs probing phases are problematic for real-time media.\r\n\r\nYes, exactly. The idea is that any probing congestion controller probes by sending \"more data than it did the last RTT\", until it detects increasing delay, or actual packet loss. If the media congestion controller doesn't need to probe for bandwidth, or doesn't do that often, the media traffic won't experience increasing delays or packet loss. \r\n\r\n> BBR also (still?) seems to be a draft, so we might not want to use it as a normative reference, either. I think we have this problem with other references, too, but I'd like to avoid adding more normative references to draft documents if possible (at least if the documents are expired and don't seem to be actively developed any longer). Regardless of which algorithm we reference here, does the reference have to be normative?\r\n\r\nRight. So the point for normative references is that people must have access to them, to implement YOUR specification. What I THINK we are doing, is to say \"use a media-centric rate adaptation mechanism, and here are three that could meet your needs\". IMO, all three of these are informational, not normative (because you don't have to read any of them, you just need to understand what makes a rate adaptation mechanism media-centric). \r\n\r\nIf you think it would help, we can add [RFC 8836 Congestion Control Requirements for Interactive Real-Time Media](https://www.rfc-editor.org/rfc/rfc8836.html). I'm still not convinced that would be normative, but it might be helpful to the reader. \r\n\r\nGot any thoughts about any of this? I'll be typing, but I'm happy to be corrected, especially while I haven't merged any of this into Main yet!\r\n",
              "createdAt": "2023-05-11T19:06:25Z",
              "updatedAt": "2023-05-11T19:06:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5U1exg",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T19:38:19Z",
          "updatedAt": "2023-05-11T19:38:19Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "That all makes sense. \r\n\r\n> I think we're struggling a bit, because the draft is not internally consistent (yet) - for example, if we are writing a specification that assumes QUIC implementations know that our packets are media (perhaps because the connection uses rtp-mux-quic as its ALPN, rather than h3, or some other non-media ALPN), that's different from assuming that QUIC implementations don't know that our packets are media, and have to use a congestion controller-rate adapter that works for any packets, without special knowledge.\r\n\r\nI think that's why we use `RECOMMEND` above. We don't know if the QUIC stack is aware of what is being sent over it and if the application has any control over the congestion control used in the QUIC stack. If the app is in control, we know what is being sent and can decide to use real-time CC. We can't do much if neither the app can choose a congestion controller nor the QUIC stack knows about the payload.\r\n\r\n> As I said in SLACK, if we CAN have real-time and non-real-time packets in the same QUIC connection, that has different implications. So, we need to be looking for inconsistencies.\r\n\r\nAgree. I think we should add more clarification to section 7.4 about the implications for congestion control when sharing a connection between real-time and non-real-time streams.\r\n\r\n> IMO, all three of these are informational, not normative (because you don't have to read any of them, you just need to understand what makes a rate adaptation mechanism media-centric).\r\n\r\nHaving an informational reference to any of the three algorithms should be fine, I think :) And adding a reference to RFC 8836 also sounds helpful. ",
              "createdAt": "2023-05-11T19:38:19Z",
              "updatedAt": "2023-05-11T19:38:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOFUmh7s5QXrjy",
      "title": "Add considerations for STOP\\_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/88",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-12T09:31:23Z",
      "updatedAt": "2023-05-18T09:02:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8dbb4db2bb1c951a00b4bb871ff94d2f809c7022",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/45/stop-sending",
      "headRefOid": "47913e23d69c6a1f3a19905ce5ff16ad631fe884",
      "closedAt": "2023-05-18T09:02:52Z",
      "mergedAt": "2023-05-18T09:02:52Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "9890c6fca2fd1ebea225c3f0127381007ccf532a"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "close #45 ",
          "createdAt": "2023-05-12T09:50:56Z",
          "updatedAt": "2023-05-12T09:52:04Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> The sending RTP application SHOULD not interpret the reception of STOP_SENDING as an indication that the receiver lost interest in the media stream as a whole, but rather that a part of the media stream was not received timely and some recovery is probably necessary.\r\n\r\nSounds good. I will change it.\r\n\r\n> I was confused here. Is this saying the (sending RTP application) MUST NOT retransmit media frames on the new stream, or MUST NOT retransmit QUIC frames on the new stream?\r\n\r\nThis should be media frames, I will add it to clarify. \r\n\r\n> Do we have a complete list of QUIC extension RFCs and drafts we think might be useful in ROQ? That would be a fine thing to add.\r\n\r\nThat is a good idea, I opened #92 ",
          "createdAt": "2023-05-16T15:26:44Z",
          "updatedAt": "2023-05-16T15:26:44Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I am not sure I understand your comment here:\r\n\r\n> I think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\".\r\n> \r\n> But that's a question for another issue. On this issue ...\r\n\r\nWould you mind opening that issue?",
          "createdAt": "2023-05-16T15:29:18Z",
          "updatedAt": "2023-05-16T15:29:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Preferring \"RTP sender\", rather than \"sender\". ",
          "createdAt": "2023-05-16T16:19:51Z",
          "updatedAt": "2023-05-16T16:19:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not sure I understand your comment here:\r\n> \r\n>> I think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\".\r\n>>\r\n>> But that's a question for another issue. On this issue ...\r\n>\r\n> Would you mind opening that issue?\r\n\r\nLet's wait to think about this some more, but I'll open an issue for it when it becomes an issue. :grinning:",
          "createdAt": "2023-05-16T16:37:28Z",
          "updatedAt": "2023-05-16T16:37:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5VJ0n0",
          "commit": {
            "abbreviatedOid": "6dd350a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working through the comments about this. \r\n\r\nI think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP\\_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\". \r\n\r\nBut that's a question for another issue. On **this issue** ... \r\n\r\n> QUIC allows an application to abort reading the stream and specify an error code\r\n> {{Section 3.5 of !RFC9000}}. The QUIC transport can signal this to the sending\r\n> side by sending a STOP\\_SENDING frame. The sender SHOULD not interpret the\r\n> reception of STOP\\_SENDING as an indication that the receiver lost interest in\r\n> the media stream as a whole, but rather that a part of the media stream was not\r\n> received timely and some recovery is necessary. \r\n\r\nHmmm. Is this a normative requirement on QUIC, beyond RFC 9000/RFC 9221? I think we might express this better as \r\n\r\nThe **sending RTP application** SHOULD not interpret the reception of STOP\\_SENDING as an indication that the receiver lost interest in the media stream as a whole, but rather that a part of the media stream was not received timely and some recovery **is probably** necessary.\r\n\r\n> The recovery may be supported by\r\n> dropping some parts of the media stream entirely and restarting to send new\r\n> media frames on new QUIC streams. While STOP\\_SENDING includes an error code, it\r\n> does not allow the receiving side to inform the sender where exactly it wishes\r\n> to restart receiving media. A sender that receives STOP\\_SENDING MUST NOT\r\n> transmit any frames already sent on the QUIC stream, on which STOP\\_SENDING was\r\n> received, on a new QUIC stream. \r\n\r\nI was confused here. Is this saying the (sending RTP application) MUST NOT retransmit **media** frames on the new stream, or MUST NOT retransmit QUIC frames on the new stream?\r\n\r\n> A sender SHOULD instead continue to send media\r\n> frames on new QUIC streams starting with the first frame that was not\r\n> transmitted on the stream that received STOP\\_SENDING.\r\n\r\nSkipping down to \r\n\r\n> **Editor's note:** A receiver cannot cancel a certain frame but still receive\r\n> retransmissions for a frame the was following on the same stream using\r\n> STOP\\_SENDING, because STOP\\_SENDING does not include an offset which would\r\n> allow signaling where retransmissions should continue. If this is a required\r\n> feature for RoQ, it could be implemented using an extended STOP\\_SENDING frame\r\n> as, for example, proposed in {{?I-D.draft-thomson-quic-enough-00}}\r\n\r\nDo we have a complete list of QUIC extension RFCs and drafts we think might be useful in ROQ? That would be a fine thing to add. ",
          "createdAt": "2023-05-16T13:51:21Z",
          "updatedAt": "2023-05-16T13:51:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOFUmh7s5QZkdU",
      "title": "Add example for MAX_STREAMS and hint for signaling",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/89",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-12T15:41:55Z",
      "updatedAt": "2023-05-18T09:03:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/49/max-streams",
      "headRefOid": "6d1afac99e3b4ca70a916b5490f7db2f535b3f22",
      "closedAt": "2023-05-18T09:03:03Z",
      "mergedAt": "2023-05-18T09:03:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "6a957b4d1a504a3d647e30cb9948748c4ae37f56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOFUmh7s5Qf_Yy",
      "title": "Remove obsolete discussion about flow IDs",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/90",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Multiplexing was discussed at an interim meeting in december 2022 and on the mailing list and an extended section explaining multiplexing using flow IDs was added in PR #54.",
      "createdAt": "2023-05-15T10:49:36Z",
      "updatedAt": "2023-05-16T16:12:20Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/remove-flow-id-discussion",
      "headRefOid": "0b5c35d96982c643818ba2dc18c161dafa2eee8c",
      "closedAt": "2023-05-16T16:12:19Z",
      "mergedAt": "2023-05-16T16:12:19Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "ce5bf21aa30f3790040352c3e84942c199bc1780"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOFUmh7s5QnZQg",
      "title": "Define error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/91",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Actual codes are still missing to avoid redefining them multiple times if we add more codes.",
      "createdAt": "2023-05-16T13:19:57Z",
      "updatedAt": "2023-07-31T14:29:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "9dc75df5291583c21308ddf97051e7f34144773b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/76/error-codes",
      "headRefOid": "4c555030ab436e1f0a5f2b8a4ff134b041dd97bb",
      "closedAt": "2023-07-31T14:29:42Z",
      "mergedAt": "2023-07-31T14:29:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "17eaa8bf67885375ca62118cfe76d46ba0bdd785"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has a starting point - next steps are \r\n\r\n- present to WG and ask for comments\r\n- add error codes to relevant sections of the draft",
          "createdAt": "2023-05-16T16:57:33Z",
          "updatedAt": "2023-05-16T16:57:33Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I added text to the rest of the draft to explain which error codes should be used. Some error codes are not yet mentioned in the text, and I am not sure if we really need them:\r\n\r\n* ROQ_GENERAL_PROTOCOL_ERROR\r\n* ROQ_INTERNAL_ERROR\r\n* ROQ_PACKET_ERROR\r\n\r\nIt may be enough to have one of them, or it may be helpful to have the option to be more specific.\r\n\r\n(The PR is now based on #98 and should only be merged after that PR is merged, too)",
          "createdAt": "2023-07-03T12:28:48Z",
          "updatedAt": "2023-07-03T12:28:48Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "@LPardue and I agreed on merging this PR first and then defining IANA procedures and real error codes in a follow-up PR.",
          "createdAt": "2023-07-31T14:16:39Z",
          "updatedAt": "2023-07-31T14:16:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5b66HI",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice work! I apologize for the number of comments ...",
          "createdAt": "2023-07-23T00:36:18Z",
          "updatedAt": "2023-07-23T01:58:49Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I know we talked about this before, but I'm now thinking more clearly. \r\n\r\n> When a RoQ sender receives a STOP\\_SENDING frame, the RoQ sender MUST open one \r\n> or more new QUIC streams to send new media frames. \r\n\r\nTo be pedantic, this is probably \r\n\r\n> When a RoQ sender receives a STOP\\_SENDING frame, the RoQ sender MUST open one\r\n> or more new QUIC streams **before sending** new media frames. ",
              "createdAt": "2023-07-23T00:36:18Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 65,
              "body": "Hmmm. RFC 9000 says this:\r\n\r\n> An endpoint MUST treat the receipt of a frame of unknown type as a connection error of type FRAME_ENCODING_ERROR.\r\n\r\nWe just had a conversation about whether a \"frame of known type defined for an extension that has not been negotiated\" would be treated as \"a frame of unknown type\" or some other kind of error, but the high order bit is that I don't think the RTP receiver will ever see that datagram - the QUIC receiver will have already punted it as a connection error. ",
              "createdAt": "2023-07-23T01:08:40Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 81,
              "body": "I think this is \"Either peer MAY close the connection for a variety of reasons.\"",
              "createdAt": "2023-07-23T01:11:18Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 113,
              "body": "> : A receiving endpoint stopped reading a frame from a stream and requests new\r\n> frames be sent on new streams using STOP\\_SENDING \r\n\r\nI think that's technically correct, but if the following is also correct, it might be clearer. \r\n\r\n> : A receiving endpoint is using STOP\\_SENDING on the current stream to request new\r\n> frames be sent on new streams. ",
              "createdAt": "2023-07-23T01:18:15Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 119,
              "body": "Perhaps \r\n\r\n> : An endpoint was unable to handle a flow identifier, e.g., because it was not\r\n> signalled or **because the endpoint** does not support multiplexing using arbitrary flow identifiers.",
              "createdAt": "2023-07-23T01:20:26Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 125,
              "body": ":exploding_head: I'm lost on this one. Does \r\n\r\n> the connection properties that were negotiated when the connection was\r\n> established using transport parameters.\r\n\r\nrefer to QUIC transport parameters? If so, it would be good to say that, but we are using \"parameters\" to refer to ROC parameters, so I'm not sure what's being described. \r\n\r\nPlease advise. ",
              "createdAt": "2023-07-23T01:28:44Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 109,
              "body": "The use of this error code in the document, in \r\n\r\n> To send RTP/RTCP packets over QUIC streams, a sender MUST open a\r\n> new unidirectional QUIC stream. Streams are unidirectional because there is no\r\n> synchronous relationship between sent and received RTP/RTCP packets. A peer that\r\n> receives a bidirectional stream with a flow identifier that is associated with\r\n> an RTP or RTCP stream, SHOULD stop reading from the stream and send a\r\n> STOP\\_SENDING frame with the application protocol error code set to\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR.\r\n\r\ndescribes this situation as a fundamental protocol violation. I read \r\n\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR (0x????):\r\n> : The endpoint detected that its peer created a stream that **it will not accept.**\r\n\r\nas more of a decision by the endpoint, rather than what the endpoint does to conform to the protocol specification. \r\n\r\nMaybe something like \r\n\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR (0x????):\r\n> : The endpoint detected that its peer created a stream that **violates the ROQ protocol.**",
              "createdAt": "2023-07-23T01:54:21Z",
              "updatedAt": "2023-07-23T01:58:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5b68lE",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-23T03:21:26Z",
          "updatedAt": "2023-07-23T03:21:26Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "That makes sense, but I will change this in #106 because it also changes this sentence.",
              "createdAt": "2023-07-23T03:21:26Z",
              "updatedAt": "2023-07-23T03:21:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5b68q8",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-23T03:29:42Z",
          "updatedAt": "2023-07-23T03:29:42Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I think we are talking about two different error cases. One problem is a peer sending a datagram frame in a connection that did not negotiate the use of QUIC datagrams. In that case, I agree that the QUIC receiver will react first, and the RTP receiver will never know about it. The case I intended to cover is that the two peers used some out-of-band signaling before setting up the QUIC connection, and in that signaling, they agreed to use QUIC datagrams, but then during the QUIC handshake, one of the peers does not send the transport parameter to negotiate datagrams. In that QUIC connection, datagrams are not allowed, so the peer that was expecting to be allowed to use datagrams can immediately close the connection. ",
              "createdAt": "2023-07-23T03:29:42Z",
              "updatedAt": "2023-07-23T03:29:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5b68wp",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-23T03:37:54Z",
          "updatedAt": "2023-07-23T03:37:55Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Yes, it refers to QUIC transport parameters. This was meant for the case I mentioned in a comment above, where peers agree on using QUIC datagrams out-of-band, but then one of them does not allow datagrams during the QUIC handshake. In that case, the other peer might like to say: \"Hey, we agreed on using datagrams, but now you don't allow me to use them so I just close the connection with a ROQ_SIGNALING_ERROR\". Does it help to say \"... established using QUIC transport parameters\"?",
              "createdAt": "2023-07-23T03:37:54Z",
              "updatedAt": "2023-07-23T03:37:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5cDpi1",
          "commit": {
            "abbreviatedOid": "9c22bf1"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-25T00:37:53Z",
          "updatedAt": "2023-07-25T00:37:54Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "@mengelbart's explanation makes sense to me",
              "createdAt": "2023-07-25T00:37:53Z",
              "updatedAt": "2023-07-25T00:37:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5cDqIT",
          "commit": {
            "abbreviatedOid": "9c22bf1"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-25T00:42:29Z",
          "updatedAt": "2023-07-25T00:42:29Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "It might help to rename the error to be like \"ROQ_REQUIREMENT_UNMET\" or \"ROQ_EXPECTATION_UNMET\" that would more clearly articulate the intent. I'd then change the text to say something like\r\n\r\n> Expectiations of the QUIC transport set by RoQ out-of-band signalling were not met by the QUIC connection.",
              "createdAt": "2023-07-25T00:42:29Z",
              "updatedAt": "2023-07-25T00:42:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5cDrLo",
          "commit": {
            "abbreviatedOid": "9c22bf1"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "This is all going in the correct direction. However some things need tweaking before you merge:\r\n\r\n* Define a new RoQ Error Code IANA registry e.g. like HTTP/3's https://www.iana.org/assignments/http3-parameters/http3-parameters.xhtml#http3-parameters-error-codes. Note that this will need to have registration procedures and you'll want to consider about greasing the code point space\r\n\r\n* Pick real values for the error codes. This is harder when you're not done and those errors might need to change. One technique is to pick values in the upper code space and then prior to publication switch them to lower values. But that might risk more churn than is really worth it.",
          "createdAt": "2023-07-25T00:50:20Z",
          "updatedAt": "2023-07-25T00:50:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOFUmh7s5Q0CDI",
      "title": "Moving RTCP replacement section below congestion control section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/94",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #82 \r\n\r\nI still wonder about moving the streams and datagrams subsections of what is now Section 7 out - they may have more to do with congestion control than replacing RTCP feedback. But we can merge this one, and then talk about additional editing that may be required. ",
      "createdAt": "2023-05-18T14:33:30Z",
      "updatedAt": "2023-05-18T18:33:30Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "6a957b4d1a504a3d647e30cb9948748c4ae37f56",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-82",
      "headRefOid": "9a457a1684744520fb055b10660f9bda71df20bd",
      "closedAt": "2023-05-18T18:33:29Z",
      "mergedAt": "2023-05-18T18:33:29Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5VbbBM",
          "commit": {
            "abbreviatedOid": "9a457a1"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-18T18:33:24Z",
          "updatedAt": "2023-05-18T18:33:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOFUmh7s5Q_R3C",
      "title": "Fix normative language about STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/96",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T08:12:43Z",
      "updatedAt": "2023-07-18T13:54:33Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/normative-language-stop-sending",
      "headRefOid": "2412b01b874d39560a4a519ae94250def296672c",
      "closedAt": "2023-07-10T16:38:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart is working on PR #98 which should replace this PR when it is merged. \r\n\r\nWe're not working on this PR further, so please look at #98 instead. ",
          "createdAt": "2023-06-16T15:14:35Z",
          "updatedAt": "2023-06-16T15:14:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Vo1eP",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T14:28:50Z",
          "updatedAt": "2023-05-22T15:56:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I know this seems ridiculous, but \"SHOULD\" and \"SHOULD NOT\" are defined terms in BCP14, and \"SHOULD not\" is not. Although \"SHOULD not\" would be clear to many readers, it's not actual requirements language. :innocent:",
              "createdAt": "2023-05-22T14:28:50Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 20,
              "body": "This might be clearer as two sentences: \r\n\r\n\"In\r\nthis case, the late data could also delay **any** following media frames due to\r\nhead-of-line blocking **within a single QUIC stream**. The **RTP** sender can avoid these delays by transmitting new media\r\nframes on new QUIC streams.\" \r\n\r\nI put what seemed like significant changes in bold, so you could spot them more easily. Please let me know if I misunderstand your intended meaning. ",
              "createdAt": "2023-05-22T14:46:02Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 22,
              "body": "I made this more complicated than it needed to be. See if this is easier to understand. \r\n\r\n\"A QUIC sender that receives STOP\\_SENDING on a QUIC stream MUST NOT\r\nretransmit any media frames already sent on that QUIC stream, on any QUIC stream.\"",
              "createdAt": "2023-05-22T15:03:05Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 17,
              "body": "OK, this is super awkward. I think we've gotten confused about the difference between what a **QUIC receiver** thinks it means when it sends \"STOP\\_SENDING\", and what an **RTP receiver** thinks it means. \r\n\r\nFrom [RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-solicited-state-transitions): \r\n\r\n> If the stream is in the \"Recv\" or \"Size Known\" state, the transport SHOULD signal this by sending a STOP_SENDING frame to prompt closure of the stream in the opposite direction. This typically indicates that the receiving application is no longer reading data it receives from the stream, but it is not a guarantee that incoming data will be ignored.\r\n\r\nSo, it looks like the application HAS lost interest - because the media frames are arriving late enough that they are not useful. The application is sending \"STOP\\_SENDING\" to trigger an automatic \"RESET\\_STREAM\".\r\n\r\nWhat's confusing, is that the **RTP receiver** - the application - hasn't lost interest in the **media** - it's lost interest in **getting outdated and unusable media frames.** The RTP receiver wants the RTP sender to start over, with the most current media frames, on a stream that doesn't already hold additional outdated frames. \r\n\r\nDoes that make sense?\r\n\r\nAssuming so, the text in this part of the document should reflect that distinction. ",
              "createdAt": "2023-05-22T15:27:06Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 25,
              "body": "Are we mandating that RTP senders open a new stream and continue sending? \r\n\r\nIf we are, and a RTP receiver really has stopped caring about this RTP stream, how does it \"turn the RTP sender off\"? \r\n\r\nI think we're basically telling a RTP receiver that wants to \"skip forward to usable media frames\", to transmit a \"STOP\\_SENDING\" frame, triggering a \"STREAM_RESET\", and then to carry out another SDP exchange so the RTP sender **knows** that it should continue by sending the newest media frames on a new QUIC stream.\r\n\r\nDo you see another way to ensure that the Right Thing happens?\r\n\r\nDoes that make sense?",
              "createdAt": "2023-05-22T15:55:14Z",
              "updatedAt": "2023-05-22T15:56:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqAdZ",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:08:36Z",
          "updatedAt": "2023-05-22T17:08:37Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yes, that sounds correct.",
              "createdAt": "2023-05-22T17:08:36Z",
              "updatedAt": "2023-05-22T17:08:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqGD6",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:22:02Z",
          "updatedAt": "2023-05-22T17:22:02Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> Are we mandating that RTP senders open a new stream and continue sending?\r\n\r\nYes, I think that is what we should do.\r\n\r\n> If we are, and a RTP receiver really has stopped caring about this RTP stream, how does it \"turn the RTP sender off\"?\r\n\r\nI don't think using STOP_SENDING is the right tool for this. Instead, it would probably require some signaling.\r\n\r\n> I think we're basically telling a RTP receiver that wants to \"skip forward to usable media frames\", to transmit a \"STOP_SENDING\" frame, triggering a \"STREAM_RESET\", and then to carry out another SDP exchange so the RTP sender **knows** that it should continue by sending the newest media frames on a new QUIC stream.\r\n>\r\n> Do you see another way to ensure that the Right Thing happens?\r\n\r\nI don't understand why we would carry out another SDP exchange here. The sender should take STOP_SENDING as a signal that the receiver is still interested in the media stream in general, but wants to start over with new media frames on new QUIC streams.",
              "createdAt": "2023-05-22T17:22:02Z",
              "updatedAt": "2023-05-22T17:22:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqK2b",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:32:42Z",
          "updatedAt": "2023-05-22T17:32:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we don't need any requirements language here, do we?",
              "createdAt": "2023-05-22T17:32:42Z",
              "updatedAt": "2023-05-22T17:32:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqLbd",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:33:19Z",
          "updatedAt": "2023-05-22T17:33:19Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Sounds good!",
              "createdAt": "2023-05-22T17:33:19Z",
              "updatedAt": "2023-05-22T17:33:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOFUmh7s5TMUqU",
      "title": "Fix reference to variable length integer encoding",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/97",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-16T13:36:39Z",
      "updatedAt": "2023-07-10T16:39:01Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/varint-reference",
      "headRefOid": "62f13d83c65a40377f6e525df79ae6e22d52d5a2",
      "closedAt": "2023-07-10T16:39:00Z",
      "mergedAt": "2023-07-10T16:39:00Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f09a2b523932612817fe08821d7cc09dd55e5d67"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDOFUmh7s5TMiWM",
      "title": "Clarify behaviour of STOP_SENDING and RESET_STREAM",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/98",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Second attempt to clarify the behaviour of STOP_SENDING and RESET_STREAM. I hope this is easier to understand than the current text and #96. It also adds subsections to add more structure to the whole subsection.",
      "createdAt": "2023-06-16T14:10:21Z",
      "updatedAt": "2023-07-10T16:29:21Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/stop-sending-2",
      "headRefOid": "4dd4ef703836c64cdfd2769db8c91be6e3111aaf",
      "closedAt": "2023-07-10T16:29:20Z",
      "mergedAt": "2023-07-10T16:29:20Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "800fd223a9fa4daa5048bfa3ae6c1ad45e1817c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5auVUy",
          "commit": {
            "abbreviatedOid": "4dd4ef7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I sent some comments via email, but I think the current text is close enough to merge for IETF 117.",
          "createdAt": "2023-07-10T13:29:31Z",
          "updatedAt": "2023-07-10T13:29:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOFUmh7s5UhgmP",
      "title": "Add green metadata to RTCP considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/99",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "fix #79 ",
      "createdAt": "2023-07-03T12:55:23Z",
      "updatedAt": "2023-07-23T20:44:49Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/79-green-metadata-rtcp",
      "headRefOid": "f610b7cf1e3510204321409a1dd6a857c7f5ef15",
      "closedAt": "2023-07-23T20:44:49Z",
      "mergedAt": "2023-07-23T20:44:49Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5dabd5d69037e6239c2a0d3bd0ca6643f299dbdc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDOFUmh7s5UiUz6",
      "title": "Add a list of considered header extensions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/100",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #95 ",
      "createdAt": "2023-07-03T15:09:41Z",
      "updatedAt": "2023-07-23T23:03:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "aa288626a71f637a3ec8ab7863a3340c6b8578a5",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/95-rtp-header-extensions",
      "headRefOid": "0439b9ed19d00cf9d0f5c4943a3ddea6c66d3ac0",
      "closedAt": "2023-07-23T23:03:43Z",
      "mergedAt": "2023-07-23T23:03:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "9dc75df5291583c21308ddf97051e7f34144773b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 101,
      "id": "PR_kwDOFUmh7s5Uiejl",
      "title": "Add an appendix to list optional QUIC extensions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/101",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #92 ",
      "createdAt": "2023-07-03T15:33:40Z",
      "updatedAt": "2023-07-23T20:53:13Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/92-list-quic-extensions",
      "headRefOid": "253f0f68ad116dcfce8d721b6b2b36b1d19c67bf",
      "closedAt": "2023-07-23T20:53:12Z",
      "mergedAt": "2023-07-23T20:53:12Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "c1b269a91e6e18d27e69aedfaed1c77a9fc72cd6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 102,
      "id": "PR_kwDOFUmh7s5Ul4NN",
      "title": "Add considerations for aggregating frames",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/102",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #85 ",
      "createdAt": "2023-07-04T08:30:32Z",
      "updatedAt": "2023-07-10T16:29:52Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/85-frame-aggregation",
      "headRefOid": "117bf7d0ce7f21b576db5fd71a341bdcdd2ba858",
      "closedAt": "2023-07-10T16:29:51Z",
      "mergedAt": "2023-07-10T16:29:51Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5ee2df7bae1af902318cd3caf76db6b502ba820c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5aMVK8",
          "commit": {
            "abbreviatedOid": "117bf7d"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-04T16:32:10Z",
          "updatedAt": "2023-07-04T16:32:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOFUmh7s5VFxsc",
      "title": "Add @spencerdawkins as third author",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/105",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Just FYI, it's fine with me (and perhaps preferable for @adoba and @JonathanLennox, since WG chairs are responsible for assigning authors/editors to working group drafts) if you wait to merge this PR, and we present it as an open issue at IETF 117. \r\n\r\nBut at least it's in the repo now. \r\n\r\nclose #104 ",
      "createdAt": "2023-07-10T13:51:11Z",
      "updatedAt": "2023-07-10T19:45:59Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-104",
      "headRefOid": "e69f5ffdf1d45f579773262f335567f28085d6d9",
      "closedAt": "2023-07-10T19:42:08Z",
      "mergedAt": "2023-07-10T19:42:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "46c8dc0bfa9f60564a6717977c10c94687337ebd"
      },
      "comments": [
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "As chair, I'm happy to have Spencer be a co-author of this draft.",
          "createdAt": "2023-07-10T17:43:12Z",
          "updatedAt": "2023-07-10T17:43:12Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, @JonathanLennox , I submitted another version, including this PR :)",
          "createdAt": "2023-07-10T19:45:58Z",
          "updatedAt": "2023-07-10T19:45:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5av5er",
          "commit": {
            "abbreviatedOid": "e69f5ff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T16:28:57Z",
          "updatedAt": "2023-07-10T16:28:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOFUmh7s5VGzgr",
      "title": "Add proposal from e-mail discussion",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/106",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T16:37:26Z",
      "updatedAt": "2023-07-23T20:56:39Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "open-new-stream-after-stop-sending",
      "headRefOid": "069d01a8edcaf07b6b058c2abed9d646cf068feb",
      "closedAt": "2023-07-23T20:56:38Z",
      "mergedAt": "2023-07-23T20:56:38Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "e5b77f3cc371f9a6e6e3afa3dad395ee03b388ec"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 108,
      "id": "PR_kwDOFUmh7s5Vzakn",
      "title": "Add references to close stream and enough drafts",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/108",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Add references and a paragraph to explain how the CLOSE_STREAM and ENOUGH frames could be used.\r\n\r\nClose #103 ",
      "createdAt": "2023-07-18T16:07:30Z",
      "updatedAt": "2023-07-23T23:01:18Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/103-close-stream-enough",
      "headRefOid": "9a849041eac94e2685c35034f637040f2a729c2b",
      "closedAt": "2023-07-23T23:01:17Z",
      "mergedAt": "2023-07-23T23:01:17Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d4e110464ecb592363d18d7064df24b2f26297c4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 109,
      "id": "PR_kwDOFUmh7s5V7Z0F",
      "title": "Add motivations section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/109",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "@mengelbart and @gchandok - I'm sure I'm leaving motivations out, so I'd appreciate your comments on this PR even more than usual!\r\n\r\ncloses #77 ",
      "createdAt": "2023-07-19T19:37:05Z",
      "updatedAt": "2023-07-23T21:35:46Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-77",
      "headRefOid": "49f76a05e20812b25c86e5abbb0b05ccc3f5bb99",
      "closedAt": "2023-07-23T21:35:45Z",
      "mergedAt": "2023-07-23T21:35:45Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "aa288626a71f637a3ec8ab7863a3340c6b8578a5"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Just FYI, I went back and thought about the motivations we had for QUIC when we chartered it for HTTP/3, and remembered that some of those motivations also apply for RTP. I also added cross-references to sections later in the document, to make me feel better about not including more details in the motivations themselves. \r\n\r\nShould I add a note that other people likely have other motivations in mind, and it would be great to add them?",
          "createdAt": "2023-07-23T00:24:22Z",
          "updatedAt": "2023-07-23T00:24:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 110,
      "id": "PR_kwDOFUmh7s5V7eyS",
      "title": "Clean up \"RTP-over-QUIC\" terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/110",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I also added \"(RoQ)\" to the document title, to make this easier to spot for readers. \r\n\r\nfixes #107 ",
      "createdAt": "2023-07-19T19:53:33Z",
      "updatedAt": "2023-07-23T21:01:51Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-107",
      "headRefOid": "72e7c42677ce00d6fddf488792af04a96b976d59",
      "closedAt": "2023-07-23T21:01:51Z",
      "mergedAt": "2023-07-23T21:01:50Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d63930b23f69915675615a4e2fb5852da535de52"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5btYHc",
          "commit": {
            "abbreviatedOid": "72e7c42"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-20T07:33:23Z",
          "updatedAt": "2023-07-20T07:33:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "PR_kwDOFUmh7s5XwzNX",
      "title": "fix typo, UTP->UDP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/119",
      "state": "MERGED",
      "author": "danwing",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-11T22:21:35Z",
      "updatedAt": "2023-08-12T07:30:58Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "17eaa8bf67885375ca62118cfe76d46ba0bdd785",
      "headRepository": "danwing/rtp-over-quic-draft",
      "headRefName": "typo",
      "headRefOid": "2360e33d2bf5666589e404f237b3a7f6ae9fca2d",
      "closedAt": "2023-08-12T07:30:58Z",
      "mergedAt": "2023-08-12T07:30:58Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "37090ca2ea9f361aee5cfdd7fcb2c001ca5f3751"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5d3u0y",
          "commit": {
            "abbreviatedOid": "2360e33"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks @danwing!",
          "createdAt": "2023-08-12T07:30:36Z",
          "updatedAt": "2023-08-12T07:30:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOFUmh7s5ZCJuJ",
      "title": "Move RTCP tables to appendix and reference section 8",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/120",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-29T13:02:44Z",
      "updatedAt": "2023-09-22T07:46:09Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "feda06569c34b2f31c8acf72027bcd2491dbf274",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/80-rtcp-tables-appendix",
      "headRefOid": "029a37862c77ecd9a9c0105b240c76d68ba5bdcb",
      "closedAt": "2023-09-22T07:46:08Z",
      "mergedAt": "2023-09-22T07:46:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "40be8b623b2cead67158ec8584e732155057627a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5hSCOW",
          "commit": {
            "abbreviatedOid": "a18316a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-18T23:18:33Z",
          "updatedAt": "2023-09-19T12:55:18Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "> considered lost. {{Section 6.2.1. of !RFC4585}} recommends to use this feature\r\n> **only, if** the underlying protocol cannot provide similar feedback. QUIC does not\r\n\r\nI'd suggest \"only if\" here. ",
              "createdAt": "2023-09-18T23:18:33Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            },
            {
              "originalPosition": 36,
              "body": "> Some of the standard\r\n> report blocks which can be implemented in extended reports can be implemented in\r\n> QUIC, too. \r\n\r\nI'm not sure if \"standard report blocks\" is the right term here. (\"Standard\" has so many meanings in IETF specifications!)\r\n\r\nIs this saying \r\n\r\n> Some of the statistics that are defined as extended report blocks can be derived from QUIC, too. ",
              "createdAt": "2023-09-18T23:29:33Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            },
            {
              "originalPosition": 67,
              "body": "I'd suggest enclosing {{Section 6 of !RFC9002}} in parentheses, as \"({{Section 6 of !RFC9002}}).\"",
              "createdAt": "2023-09-18T23:32:33Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            },
            {
              "originalPosition": 286,
              "body": "Two things for this text: \r\n\r\n> Several but not all of these control packets and their attributes can be mapped\r\n> from QUIC, as described in {{transport-layer-feedback}}. *Mappable from QUIC*\r\n> has one of three values: *yes*, *QUIC extension required*, and *no*.\r\n\r\nI THINK this paragraph applies to more subsections than **## RTCP Control Packet Types {#control-packets}**.\r\n\r\nAlso, I'm also seeing **partly** and **possibly** in this section, but I'm not seeing **QUIC extension required**.",
              "createdAt": "2023-09-19T12:53:12Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5hdDz1",
          "commit": {
            "abbreviatedOid": "a18316a"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-20T08:26:28Z",
          "updatedAt": "2023-09-20T08:26:28Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "Thanks! I moved the paragraph to the section introduction so it applies to all the following subsections. I also replaced *QUIC extension required* with *possibly* and *partly*, including short explanations and updated the table values to match their respective descriptions.",
              "createdAt": "2023-09-20T08:26:28Z",
              "updatedAt": "2023-09-20T08:26:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOFUmh7s5ZVCfe",
      "title": "Distinguish between adapting media stream contents and media stream \u2026",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/121",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "\u2026rate adaptation\r\n\r\nAlso corrected (I think) formats of multiple references to compact header extensions and SDES compact header extensions.\r\n\r\ncloses #116 ",
      "createdAt": "2023-09-01T11:09:42Z",
      "updatedAt": "2023-09-15T15:08:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "37090ca2ea9f361aee5cfdd7fcb2c001ca5f3751",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-116",
      "headRefOid": "88dd572ed45950637ebcf328700cc6c89045ce7a",
      "closedAt": "2023-09-15T15:08:43Z",
      "mergedAt": "2023-09-15T15:08:43Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "feda06569c34b2f31c8acf72027bcd2491dbf274"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5hE9jO",
          "commit": {
            "abbreviatedOid": "88dd572"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-15T10:47:13Z",
          "updatedAt": "2023-09-15T10:47:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOFUmh7s5ZWO7i",
      "title": "Describe considerations for streams, datagrams, and a mixture",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/123",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #93 \r\n\r\nNote that the \"- No link definition for link ID 'rfcnnnn' warnings are fixed in  PR #121",
      "createdAt": "2023-09-01T14:52:42Z",
      "updatedAt": "2023-09-15T15:07:17Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "37090ca2ea9f361aee5cfdd7fcb2c001ca5f3751",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-93",
      "headRefOid": "feef2b167cd03e43d01b7653c538324f6bc8a416",
      "closedAt": "2023-09-15T15:07:16Z",
      "mergedAt": "2023-09-15T15:07:16Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "e487461701ad44d64aea12192b879f3ba1867a22"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5hE_Qa",
          "commit": {
            "abbreviatedOid": "3191129"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-15T10:52:17Z",
          "updatedAt": "2023-09-15T10:52:23Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n* DATAGRAM frames belong to a QUIC connection as a whole. There is no QUIC-level way to multiplex/demultiplex DATAGRAM frames within a single QUIC connection. Any multiplexing identifiers must be added, interpreted, and removed by an application, and they will be sent as part of the payload of the DATAGRAM frame itself.\r\n```",
              "createdAt": "2023-09-15T10:52:17Z",
              "updatedAt": "2023-09-15T10:52:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5hE_yt",
          "commit": {
            "abbreviatedOid": "3191129"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T10:53:37Z",
          "updatedAt": "2023-09-15T10:53:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think adding that it is part of the payload makes it clear that it will not be in any header field of the frame, like the length would be, for example.",
              "createdAt": "2023-09-15T10:53:37Z",
              "updatedAt": "2023-09-15T10:53:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOFUmh7s5a-uJo",
      "title": "Remove suppressing RTCP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/124",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "RoQ should not change rules for QUIC or RTCP feedback. RTCP can be enhanced and bandwidth reduced, but everything should still look like valid QUIC and RTP/RTCP implementations.",
      "createdAt": "2023-09-22T11:00:14Z",
      "updatedAt": "2023-09-25T16:22:37Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ae0803dce52fdc17cabe6a804ad4814dc01c2ff8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/117-enhancing-instead-of-suppressing-rtcp",
      "headRefOid": "a374d8de0644ab41c96b9cc555d1e7f59704ca2d",
      "closedAt": "2023-09-25T16:22:36Z",
      "mergedAt": "2023-09-25T16:22:36Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "40cb17987fa31dd5c32c10ce5c0a9a1b46912373"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5h5JXg",
          "commit": {
            "abbreviatedOid": "6fe697a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T14:55:39Z",
          "updatedAt": "2023-09-25T15:25:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I might suggest\r\n\r\n> bandwidth to deliver **equivalent** control information **at more than one level of the protocol stack**.",
              "createdAt": "2023-09-25T14:55:39Z",
              "updatedAt": "2023-09-25T15:25:26Z"
            },
            {
              "originalPosition": 17,
              "body": "I think \r\n\r\n>for replacing some of the RTCP packet types by mapping the contents to QUIC\r\n>connection statistics. \r\n\r\nshould also say something like \r\n\r\n> for replacing some of the RTCP packet types by mapping the contents to QUIC\r\n> connection statistics, **and reducing the transmission frequency and bandwidth requirements for some RTCP packet types that must be transmitted periodically.**  ",
              "createdAt": "2023-09-25T15:17:06Z",
              "updatedAt": "2023-09-25T15:25:26Z"
            },
            {
              "originalPosition": 21,
              "body": "> The mechanisms described in this section can only be used for enhancing\r\n> the **statsitics** provided by RTCP while simultaneously reducing the bandwidth\r\n> overhead required by certain RTCP packets. \r\n\r\n **statsitics** should be  **statistics**.\r\n\r\nI'm struggling a bit with \"can only be used for\". Perhaps this would be better?\r\n\r\n> The mechanisms described in this section can **enhance**\r\n> the **statistics** provided by RTCP **and reduce** the bandwidth\r\n> overhead required by certain RTCP packets.",
              "createdAt": "2023-09-25T15:24:56Z",
              "updatedAt": "2023-09-25T15:25:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 125,
      "id": "PR_kwDOFUmh7s5a_UmQ",
      "title": "Add multihop topologies considerations for RTCP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/125",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-22T13:00:48Z",
      "updatedAt": "2023-09-25T16:17:23Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "40be8b623b2cead67158ec8584e732155057627a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/75-multihop-topology-considerations-for-rtcp",
      "headRefOid": "39d5bf1e35ee1d53ec3a16c1d744ff0bfbd87723",
      "closedAt": "2023-09-25T16:17:22Z",
      "mergedAt": "2023-09-25T16:17:22Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "ae0803dce52fdc17cabe6a804ad4814dc01c2ff8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5h5bQK",
          "commit": {
            "abbreviatedOid": "ca629e4"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T15:27:22Z",
          "updatedAt": "2023-09-25T16:03:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'd suggest \r\n\r\n> only **some** of the links",
              "createdAt": "2023-09-25T15:27:22Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 7,
              "body": "Just for completeness, \r\n\r\n> Other links may be using RTP over UDP, **or over some other supported RTP encapsulation protocol,** ",
              "createdAt": "2023-09-25T15:34:56Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 8,
              "body": "Again, for completeness, \r\n\r\n> participants **might be using implementations that don't support RoQ at all.** \r\n\r\n(the problem isn't that the participants aren't aware of RoQ, but that the implementations aren't aware. :wink:",
              "createdAt": "2023-09-25T15:40:04Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 11,
              "body": "I'd suggest \r\n\r\n> participants using **RoQ** **might** not be aware **that other**\r\n> participants are not using **RoQ**",
              "createdAt": "2023-09-25T15:43:55Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 18,
              "body": "This is all correct, but perhaps \r\n\r\n> There are two\r\n> ways to solve this problem: **if the middlebox** translating between RoQ and\r\n> RTP over **other RTP transport** protocols such as UDP or TCP **provides Back-to-Back RTP sessions as described in {{Section 3.2.2 of !RFC7667}}, this middlebox** can add RTCP packets for the\r\n> participants not using RoQ by using the statistics **the middlebox** gets from QUIC and the\r\n> mappings described in the following sections. **If the middlebox does not provide Back-to-Back RTP sessions,** participants may\r\n> use additional signalling to let the RoQ participants know what RTCP is\r\n> required.\r\n\r\nwould be better?",
              "createdAt": "2023-09-25T16:02:48Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDOFUmh7s5bOphe",
      "title": "Fix a reference",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/130",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-26T13:01:12Z",
      "updatedAt": "2023-10-10T07:35:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "40cb17987fa31dd5c32c10ce5c0a9a1b46912373",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/reference",
      "headRefOid": "24352bd0ba909737de6117f621803583ad4f4407",
      "closedAt": "2023-10-10T07:35:35Z",
      "mergedAt": "2023-10-10T07:35:35Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0821d79533383533e6563295167104c799df46ae"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 132,
      "id": "PR_kwDOFUmh7s5cPRDJ",
      "title": "Improve BYE to CONNECTION_CLOSE mapping considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/132",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-09T09:42:20Z",
      "updatedAt": "2023-10-16T13:33:23Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "e1ef3dc5050f7e83bfcff945e07e1af78ae5594d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/129-bye-connection_close-mapping",
      "headRefOid": "9cbb3195288eea6f68b25e6ac34bf9f9d46556fe",
      "closedAt": "2023-10-16T13:33:22Z",
      "mergedAt": "2023-10-16T13:33:22Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "478c72c3ab7f3c147a02d1b92f123b89166cf540"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5j1gdv",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-12T19:09:59Z",
          "updatedAt": "2023-10-12T19:22:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'd suggest rephrasing this sentence as \r\n\r\n> However, if the\r\n> participant only wishes to leave one RTP session while continuing to use the QUIC\r\n> connection, the *BYE* packet MUST be used, because the QUIC CONNECTION_CLOSE \r\n> would close the entire QUIC connection for all other QUIC streams and datagrams.",
              "createdAt": "2023-10-12T19:09:59Z",
              "updatedAt": "2023-10-12T19:22:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j43eZ",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T07:09:19Z",
          "updatedAt": "2023-10-13T07:09:20Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I would like to avoid the normative *MUST* in *the BYE packet MUST be used*, because that is not a requirement of RFC 3550 in the first place (*[A participant [...] MAY leave the group without sending a BYE at all.](https://www.rfc-editor.org/rfc/rfc3550#section-6.3.7)*). How about this:\r\n\r\n> However, if the\r\n> participant only wishes to leave one RTP session while continuing to use the QUIC\r\n> connection, it has to use the BYE packet because the QUIC CONNECTION_CLOSE\r\n> would close the entire QUIC connection for all other QUIC streams and datagrams.",
              "createdAt": "2023-10-13T07:09:19Z",
              "updatedAt": "2023-10-13T07:09:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kDFjW",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-15T00:26:18Z",
          "updatedAt": "2023-10-15T00:26:19Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Hi, @mengelbart - we're getting close to converging. \r\n\r\nThe point I was struggling with, is that if you don't send a BYE packet, the sender would continue to send RTP media until the sender detects that the receiver is no longer sending RRs, and \"times the receiver out\". I agree with you, that inserting a MUST is adding a requirement that isn't in RTP today, so I guess the assumption is that the receiver has some reason for not using BYE, and I shouldn't complain about that. \r\n\r\nI do think it's worth pointing out that we're allowing multiplexing of RTP/RTCP and other protocols in a single QUIC connection, so maybe it's better to also allow for the case where the participant is leaving the RTP session, but is continuing to use the QUIC connection for \"something else\", by saying something like \r\n\r\n> However, if the\r\n> participant wishes to **use this QUIC\r\n> connection for any other multiplexed traffic**, the participant has to use the BYE packet because the QUIC CONNECTION_CLOSE\r\n> would close the entire QUIC connection for all other QUIC streams and datagrams.\r\n\r\nDoes that make sense?\r\n",
              "createdAt": "2023-10-15T00:26:19Z",
              "updatedAt": "2023-10-15T00:26:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kIsQX",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T13:32:06Z",
          "updatedAt": "2023-10-16T13:32:07Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "That sounds good. I updated the PR with your proposal and will merge it now.",
              "createdAt": "2023-10-16T13:32:07Z",
              "updatedAt": "2023-10-16T13:32:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDOFUmh7s5cWGOU",
      "title": "Move RTCP mappings requiring extensions to appendix",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/133",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #127 \r\n\r\nThis PR does not yet remove the references to the timestamp extensions from section 7. (*Congestion Control and Rate Adaptation*). I am planning to do that in a PR for #128.",
      "createdAt": "2023-10-10T07:51:40Z",
      "updatedAt": "2023-10-23T14:12:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0821d79533383533e6563295167104c799df46ae",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/127-normative-references",
      "headRefOid": "e6b7337f76c0e7a01d10a2f7826df1c2a61647bb",
      "closedAt": "2023-10-23T14:12:42Z",
      "mergedAt": "2023-10-23T14:12:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "9d13e8d0997b6fd7681eebd2bf528b19cedfc6e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5jnjjQ",
          "commit": {
            "abbreviatedOid": "e6b7337"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-11T13:56:52Z",
          "updatedAt": "2023-10-11T13:56:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5j1rva",
          "commit": {
            "abbreviatedOid": "e6b7337"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looked fine to me, with no changes requested. ",
          "createdAt": "2023-10-12T19:33:56Z",
          "updatedAt": "2023-10-12T19:33:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDOFUmh7s5cY2Tf",
      "title": "Clarify congestion and rate control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/134",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #128 ",
      "createdAt": "2023-10-10T13:55:16Z",
      "updatedAt": "2023-10-23T14:26:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/128-congestion-and-rate-control",
      "headRefOid": "7a03e8f0e5539b4554980a12cafa70dfff1c37f9",
      "closedAt": "2023-10-23T14:26:28Z",
      "mergedAt": "2023-10-23T14:26:28Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0a9d21956019349cd27f203d3577956fd99531c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5j17RB",
          "commit": {
            "abbreviatedOid": "7603ce0"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-12T20:00:44Z",
          "updatedAt": "2023-10-12T23:53:35Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This sentence ^^ reads as if building queues are the only cause of jitter. I'd suggest phrasing this as \r\n\r\n> maximize the amount of information that is sent to a receiver without causing *buffer bloat*, when \r\n> queues build beyond a reasonable amount, or *jitter*, when interpacket arrival times fluctuate due to queuing delays. ",
              "createdAt": "2023-10-12T20:00:44Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 27,
              "body": "I'd suggest \r\n\r\n> Rate adaptation is one way to respond to **sending rate limitations** imposed by",
              "createdAt": "2023-10-12T20:01:59Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 86,
              "body": "Just for readability - the previous paragraphs have pointed to document sections at the end of each sentence, but this paragraph starts with the pointer to a document section. Perhaps\r\n\r\n> This document also discusses congestion control implications of using shared\r\n> or multiple separate QUIC connections to send and receive multiple independent\r\n> data streams in {{shared-connections}}.\r\n\r\nor perhaps just flip the previous paragraphs to match this one? Your call, of course. ",
              "createdAt": "2023-10-12T20:08:54Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 159,
              "body": "I'd suggest \r\n\r\n> to avoid bursts and minimize variation in inter-packet arrival times.",
              "createdAt": "2023-10-12T23:49:13Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 199,
              "body": "I'd suggest\r\n\r\n> when losses are no longer **being** detected)",
              "createdAt": "2023-10-12T23:52:06Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kDFnF",
          "commit": {
            "abbreviatedOid": "5f37e1f"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is ready to merge.",
          "createdAt": "2023-10-15T00:29:49Z",
          "updatedAt": "2023-10-15T00:29:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 137,
      "id": "PR_kwDOFUmh7s5cfTBV",
      "title": "Remove note referencing CLOSE_STREAM and ENOUGH",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/137",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Close #113 ",
      "createdAt": "2023-10-11T09:21:27Z",
      "updatedAt": "2023-10-11T14:02:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0821d79533383533e6563295167104c799df46ae",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/113-close-stream-enough",
      "headRefOid": "c59640f7b5f384f1c5cc84cd322864a0cce7ef2c",
      "closedAt": "2023-10-11T14:02:40Z",
      "mergedAt": "2023-10-11T14:02:40Z",
      "mergedBy": "joerg-ott",
      "mergeCommit": {
        "oid": "e1ef3dc5050f7e83bfcff945e07e1af78ae5594d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 138,
      "id": "PR_kwDOFUmh7s5cfYQr",
      "title": "Remove normative API requirements",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/138",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I don't think normative SHOULD's are useful for describing API considerations. This also clarifies the datagram/stream acknowledgement mappings.\r\n\r\nAdditionally, I removed the API write functions section. I think resetting streams is a core feature of QUIC and it shouldn't be necessary to be listed explicitly. And congestion control configuration is not something that needs an API at runtime. The updates to the congestion control section in #134 should also make this more clear.",
      "createdAt": "2023-10-11T09:34:40Z",
      "updatedAt": "2023-10-23T14:59:38Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d468b6fe4a0977a651234104fd89afd30e706a80",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/131-api-considerations",
      "headRefOid": "0069229d86dac2b306ef00774bb2d6414833b523",
      "closedAt": "2023-10-23T14:59:37Z",
      "mergedAt": "2023-10-23T14:59:37Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "ea21fe4b81de53ebdd1183d6fe8f3beaab7e5f92"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5j3R8T",
          "commit": {
            "abbreviatedOid": "b7803be"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks fine. ",
          "createdAt": "2023-10-12T23:59:48Z",
          "updatedAt": "2023-10-12T23:59:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 139,
      "id": "PR_kwDOFUmh7s5cgk2m",
      "title": "Allow to resume sending datagrams after STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/139",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-11T12:35:34Z",
      "updatedAt": "2023-10-16T14:04:26Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "e1ef3dc5050f7e83bfcff945e07e1af78ae5594d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/136-stop-sending-continue-datagrams",
      "headRefOid": "47c4d1e60ba93991fe39d574f357b317a3a83dfe",
      "closedAt": "2023-10-16T14:04:25Z",
      "mergedAt": "2023-10-16T14:04:25Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0b580e7bf671abd48b30990b255f3b38b5b5982d"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The problem I see is with this sentence:\r\n\r\n> the RoQ sender MUST open one or more new QUIC streams before sending new media frames.\r\n\r\nTo me, this sounds like I definitely MUST continue sending new media on new streams. But I might want to continue sending the subsequent frames as datagrams instead (and never open a new QUIC stream again). We might instead add something like *STOP_SENDING is not a request to end the media stream but only an indication that a receiver stopped reading a media frame. A sender SHOULD continue sending new media frames of the same media stream. New media frames can be sent in new QUIC streams or as QUIC datagrams (see section ...).*\r\n\r\nI'm using *SHOULD* here because the sender may decide to stop the media stream for different reasons.",
          "createdAt": "2023-10-13T07:23:33Z",
          "updatedAt": "2023-10-13T07:23:33Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - we're converging. I have a somewhat different suggestion, but I agree with where you're going with this text. \r\n\r\n> STOP_SENDING is not a request **to the sender to stop sending the RTP media stream, only an indication that a receiver stopped reading the QUIC stream being used**. A sender **with additional media frames to send SHOULD continue sending them on a QUIC stream in the \"Ready\" state**. **Alternatively**, new media frames can be sent as QUIC datagrams (see section ...).\r\n\r\nDoes that make sense?",
          "createdAt": "2023-10-15T00:52:28Z",
          "updatedAt": "2023-10-15T00:53:57Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> > STOP_SENDING is not a request **to the sender to stop sending the RTP media stream, only an indication that a receiver stopped reading the QUIC stream being used**. A sender **with additional media frames to send SHOULD continue sending them on a QUIC stream in the \"Ready\" state**. **Alternatively**, new media frames can be sent as QUIC datagrams (see section ...).\r\n\r\n\r\nI updated the PR, but instead of `a QUIC stream in the \"Ready\" state`, I used `another QUIC stream,` which is closer to how it was before the change because the *Ready* state is only one of the possible states described in RFC9000. I think it could also be in the *Send* state if the other QUIC stream was used for other packets before.",
          "createdAt": "2023-10-16T13:28:25Z",
          "updatedAt": "2023-10-16T13:28:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @mengelbart - I think we're converged here (on your text). I was hoping I would be able to qualify \"another QUIC stream\", but after reflection, I don't think that's necessary or helpful. \r\n\r\nDude - merge it!",
          "createdAt": "2023-10-16T13:53:59Z",
          "updatedAt": "2023-10-16T13:53:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5jnqh5",
          "commit": {
            "abbreviatedOid": "a2ac4fe"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "or as datagram(s)?",
          "createdAt": "2023-10-11T14:08:10Z",
          "updatedAt": "2023-10-11T14:08:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5j3g2y",
          "commit": {
            "abbreviatedOid": "a2ac4fe"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Mentioning datagrams within the section discussing STOP_SENDING seems confusing, because this is in Section 5.2 (streams), and because datagrams aren't associated with a stream, STOP_SENDING and RESET_STREAM won't have any effect on whether the sender continues to send datagrams.\r\n\r\nIf you want to say the same kind of thing about datagrams that we're saying here about streams (\"don't re-send old media\"), I guess we can say that in Section 5.3, but I'm not sure I understand why we need to say anything. \r\n\r\nBut I'm not sure what you're trying to get at, with this change. I might guess, but I'd be guessing. HELP! \ud83d\ude36\r\n\r\n(Ping me on Slack if we need to talk, please!)",
          "createdAt": "2023-10-13T00:47:17Z",
          "updatedAt": "2023-10-13T00:47:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 140,
      "id": "PR_kwDOFUmh7s5cgokR",
      "title": "Add IANA considerations for error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/140",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "closes #76 ",
      "createdAt": "2023-10-11T12:44:57Z",
      "updatedAt": "2023-10-23T14:09:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/finish-error-codes",
      "headRefOid": "8fb68afd6e27c636b259e1663cf5ab819596a394",
      "closedAt": "2023-10-23T14:09:54Z",
      "mergedAt": "2023-10-23T14:09:54Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "a5398b587f5373b42e1adb608257880948ec93a6"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart, this seems ready to merge - thank you for looking over my comments!",
          "createdAt": "2023-10-15T00:33:14Z",
          "updatedAt": "2023-10-15T00:33:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5jnsG_",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-11T14:10:48Z",
          "updatedAt": "2023-10-11T14:10:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5j3kAE",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T01:02:39Z",
          "updatedAt": "2023-10-13T01:28:32Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I don't understand this part at all. There's a lot of cool stuff in 22.1, but is it all applicable to the RoQ error code registry? ",
              "createdAt": "2023-10-13T01:02:39Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 34,
              "body": "Possibly \r\n\r\n> duplication **or interaction** with existing error codes",
              "createdAt": "2023-10-13T01:04:24Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 51,
              "body": "Especially because we're tying this registry to QUIC practice, the initial registration should probably contain all the fields for each entry, in the order we want them to appear, as the QUIC registries [here](https://www.iana.org/assignments/quic/quic.xhtml#quic-transport-error-codes) show.",
              "createdAt": "2023-10-13T01:10:59Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 40,
              "body": "If you want to match the [QUIC transport error code registry](https://www.iana.org/assignments/quic/quic.xhtml#quic-transport-error-codes), this should be \"CODE\". ",
              "createdAt": "2023-10-13T01:20:53Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 41,
              "body": "> A short mnemonic for the parameter",
              "createdAt": "2023-10-13T01:22:29Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 44,
              "body": "We might as well match this, too:\r\n\r\n> A brief description of the error code semantics, which MAY be a summary if a specification reference is provided.\r\n\r\n",
              "createdAt": "2023-10-13T01:24:04Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j72-c",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:31:58Z",
          "updatedAt": "2023-10-13T14:31:58Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I tried to follow what [HTTP/3](https://datatracker.ietf.org/doc/html/rfc9114#name-error-codes) and [DNS over QUIC](https://datatracker.ietf.org/doc/html/rfc9250#name-dns-over-quic-error-codes-r) did. I'm not an expert on this and it may not be applicable, but to me, it seemed to make sense to follow what other application protocol mappings to QUIC do.",
              "createdAt": "2023-10-13T14:31:58Z",
              "updatedAt": "2023-10-13T14:31:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j75F1",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:36:48Z",
          "updatedAt": "2023-10-13T14:36:49Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I don't mind what we use here, but HTTP/3 uses *Name*, and DNS over QUIC uses *Error* :D ",
              "createdAt": "2023-10-13T14:36:49Z",
              "updatedAt": "2023-10-13T14:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j76FE",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:39:07Z",
          "updatedAt": "2023-10-13T14:39:07Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Also taken from HTTP/3. I find *A name for the error code* much easier to understand, especially since the codes are not called parameters anywhere else.",
              "createdAt": "2023-10-13T14:39:07Z",
              "updatedAt": "2023-10-13T14:39:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j7-E5",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:47:47Z",
          "updatedAt": "2023-10-13T14:47:47Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I think all fields are included: *Name*, *Value*, *Description*, and *Specification* are in the table, *Status*, *Change Controller*, and *Contact* for all are given in the text above. HTTP/3 uses this order but the table in the registry uses a different order. I'll swap it here, so we may have the same order here and in the registry.",
              "createdAt": "2023-10-13T14:47:47Z",
              "updatedAt": "2023-10-13T14:47:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kR99Z",
          "commit": {
            "abbreviatedOid": "d4ac416"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I see a couple of nits that would be good to fix before we call everyone's attention to the IANA section. Could you let me know in Slack when you've had a chance to fix them? ",
          "createdAt": "2023-10-17T13:51:20Z",
          "updatedAt": "2023-10-17T14:06:49Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Nit: I'd suggest adding parentheses here. \r\n\r\n> This document registers a new ALPN protocol ID **(in {{iana-alpn}})** and creates a new\r\n> registry that manages the assignment of error code points in RoQ **(in \r\n> {{iana-error-codes}}).**",
              "createdAt": "2023-10-17T13:51:21Z",
              "updatedAt": "2023-10-17T14:06:49Z"
            },
            {
              "originalPosition": 34,
              "body": "> (RoQ) Error Codes\" registry manages a 62-bit space and is listed under the **the**\r\n\r\nhas an extra \"the\". ",
              "createdAt": "2023-10-17T13:52:17Z",
              "updatedAt": "2023-10-17T14:06:49Z"
            },
            {
              "originalPosition": 51,
              "body": "As we discussed yesterday, I knew we were trying to match the QUIC error codes, but didn't realize that HTTP/3 error codes and DNS over QUIC error codes didn't match QUIC, or each other. My apologies, obviously my comment doesn't matter!",
              "createdAt": "2023-10-17T14:04:24Z",
              "updatedAt": "2023-10-17T14:13:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 143,
      "id": "PR_kwDOFUmh7s5dMWJO",
      "title": "Configure streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/143",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #142 ",
      "createdAt": "2023-10-18T21:36:25Z",
      "updatedAt": "2023-10-23T14:23:24Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-142-configure-streams",
      "headRefOid": "e91d2aff10b3c5f38fbfca9496c76275ef5eb432",
      "closedAt": "2023-10-23T14:23:23Z",
      "mergedAt": "2023-10-23T14:23:23Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5ed81891f001e6be3e308277a4aad2c55920aaf6"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I'm looking at this text, also in {#quic-streams},\r\n\r\n> A RoQ receiver MUST be prepared to receive RTP packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n> \r\n> Note: A sender may or may not decide to discontinue using a lower stream number after starting packet transmission on a higher stream number.\r\n\r\nI think this would be better as \r\n\r\n> **Because a sender can continue sending on a lower stream number after starting packet transmission on a higher stream number,** a RoQ receiver MUST be prepared to receive RoQ packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n\r\nI'm not wild about  \r\n\r\n> **SHOULD** not make assumptions about which RTP sequence numbers are carried in which streams\r\n\r\nfor a couple of reasons.\r\n\r\nIs this more like \r\n\r\n> SHOULD be prepared to accept any RTP sequence number on any open stream?\r\n\r\nWe can wait to talk about the SHOULD until we work on #111, but in any event, \r\n\r\n- we should have a legitimate reason for why a RoQ receiver would choose not to accept any RTP sequence number on any open stream, given that a RoQ sender can send any RTP sequence number on any open stream, and \r\n- if a RoQ receiver makes that choice, we need to think about what happens next.\r\n\r\nIf you send me an RTP packet with sequence number 12 on stream 32, and I'm not prepared to accept it. Do I drop it? Do I need to tell you that I'm dropping it because of the stream it arrived on, so you don't look at the ACKs/RRs and decide that you need to reduce the sending rate (because you're sending RTP packets that aren't being acknowledged)? Etc.\r\n\r\n",
          "createdAt": "2023-10-23T12:34:44Z",
          "updatedAt": "2023-10-23T12:34:44Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> @mengelbart - I'm looking at this text, also in {#quic-streams},\r\n> \r\n> > A RoQ receiver MUST be prepared to receive RTP packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n> > Note: A sender may or may not decide to discontinue using a lower stream number after starting packet transmission on a higher stream number.\r\n> \r\n> I think this would be better as\r\n> \r\n> > **Because a sender can continue sending on a lower stream number after starting packet transmission on a higher stream number,** a RoQ receiver MUST be prepared to receive RoQ packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n\r\nSounds good to me.\r\n\r\n> I'm not wild about\r\n> \r\n> > **SHOULD** not make assumptions about which RTP sequence numbers are carried in which streams\r\n> \r\n> for a couple of reasons.\r\n> \r\n> Is this more like\r\n> \r\n> > SHOULD be prepared to accept any RTP sequence number on any open stream?\r\n> \r\n> We can wait to talk about the SHOULD until we work on #111, but in any event,\r\n> \r\n>     * we should have a legitimate reason for why a RoQ receiver would choose not to accept any RTP sequence number on any open stream, given that a RoQ sender can send any RTP sequence number on any open stream, and\r\n> \r\n>     * if a RoQ receiver makes that choice, we need to think about what happens next.\r\n> \r\n> \r\n> If you send me an RTP packet with sequence number 12 on stream 32, and I'm not prepared to accept it. Do I drop it? Do I need to tell you that I'm dropping it because of the stream it arrived on, so you don't look at the ACKs/RRs and decide that you need to reduce the sending rate (because you're sending RTP packets that aren't being acknowledged)? Etc.\r\n\r\nThese are good points. I think we want to use *MUST* instead. There should be no special treatment of RTP packets just because they arrive on a stream with a lower ID or on datagrams.\r\n",
          "createdAt": "2023-10-23T13:52:31Z",
          "updatedAt": "2023-10-23T13:52:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kjH1L",
          "commit": {
            "abbreviatedOid": "92551ea"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T07:32:18Z",
          "updatedAt": "2023-10-19T07:32:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This is a useful addition, but I suggest moving it into the MAX_STREAMS/flow control subsection to keep all the things related to that issue in one place.",
              "createdAt": "2023-10-19T07:32:18Z",
              "updatedAt": "2023-10-19T07:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k30MK",
          "commit": {
            "abbreviatedOid": "92551ea"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T11:58:24Z",
          "updatedAt": "2023-10-23T11:58:24Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agreed (thanks for the helpful suggestion). I committed a change for this. ",
              "createdAt": "2023-10-23T11:58:24Z",
              "updatedAt": "2023-10-23T11:58:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 144,
      "id": "PR_kwDOFUmh7s5dNbuC",
      "title": "Describe strategies for reacting to datagram non-support",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/144",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Please note that I moved text about QUIC implementations exposing maximum datagram sizes to the API section as well. \r\n\r\ncloses #122 \r\ncloses #13 ",
      "createdAt": "2023-10-19T01:46:57Z",
      "updatedAt": "2023-10-23T14:27:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-122-no-datagram-support-during-handshake",
      "headRefOid": "7b8d11b975f489380126ab5fd72bb444a896ae97",
      "closedAt": "2023-10-23T14:27:49Z",
      "mergedAt": "2023-10-23T14:27:49Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "7e04a44f24d4a9cbad8755b111c6f3a1fd0f78ba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kjFgL",
          "commit": {
            "abbreviatedOid": "e6d3b31"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-19T07:26:59Z",
          "updatedAt": "2023-10-19T07:27:28Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I would prefer to keep the normative MUST out of here. #138 removes all the other normative SHOULDs from this section, too. I would suggest removing the MUST here and in the datagram encapsulation section. Instead, we should explain why the application should be able to learn about the maximum size and what can happen if it cannot. If the application does not know the maximum size, it may try to send datagrams that will be dropped. I think it makes sense to explain that in the datagram encapsulation section.",
              "createdAt": "2023-10-19T07:26:59Z",
              "updatedAt": "2023-10-19T07:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kxtu0",
          "commit": {
            "abbreviatedOid": "e6d3b31"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:58:21Z",
          "updatedAt": "2023-10-20T18:58:22Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> I would prefer to keep the normative MUST out of here. #138 removes all the other normative SHOULDs from this section, too. I would suggest removing the MUST here and in the datagram encapsulation section. Instead, we should explain why the application should be able to learn about the maximum size and what can happen if it cannot. If the application does not know the maximum size, it may try to send datagrams that will be dropped. I think it makes sense to explain that in the datagram encapsulation section.\r\n\r\n@mengelbart - that makes sense to me, and I'll make the change you're suggesting, but I should point out that \r\n\r\n> This section provides a list of items that an application might want to export\r\nfrom an underlying QUIC implementation. It is thus **RECOMMENDED** that a QUIC\r\nimplementation exports the listed items to the application.\r\n\r\nis also BCP14-normative ... our terminology section uses the BCP14 template, and [BCP14 uses SHOULD and RECOMMENDED as synonyms](https://datatracker.ietf.org/doc/html/rfc2119#autoid-3). \r\n\r\nWould you like me to make a change there, too?",
              "createdAt": "2023-10-20T18:58:22Z",
              "updatedAt": "2023-10-20T18:58:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k2aqT",
          "commit": {
            "abbreviatedOid": "e6d3b31"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T08:31:42Z",
          "updatedAt": "2023-10-23T08:31:43Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "No need to. It will already be changed with #138.",
              "createdAt": "2023-10-23T08:31:42Z",
              "updatedAt": "2023-10-23T08:31:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 145,
      "id": "PR_kwDOFUmh7s5dNen-",
      "title": "Move rate adaptation mention to scope",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/145",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "close #141 ",
      "createdAt": "2023-10-19T02:04:36Z",
      "updatedAt": "2023-10-23T14:08:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-141-move-rate-adapt-to-scope",
      "headRefOid": "3511b43f16523c944e014416f6eebc4e0750f6b5",
      "closedAt": "2023-10-23T14:08:42Z",
      "mergedAt": "2023-10-23T14:08:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "57b12e50d36413fd7d0efc438c7fbbde132e3d43"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kiWhv",
          "commit": {
            "abbreviatedOid": "3511b43"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-19T05:33:12Z",
          "updatedAt": "2023-10-19T05:33:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 146,
      "id": "PR_kwDOFUmh7s5dVCjT",
      "title": "Improve congestion control  and rate adaptation in motivation section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/146",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Also adding explanation of the use of congestion control and rate adaptation terms in this document.\r\n\r\ncloses #135 ",
      "createdAt": "2023-10-20T00:40:15Z",
      "updatedAt": "2023-10-23T14:42:45Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "7e04a44f24d4a9cbad8755b111c6f3a1fd0f78ba",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-135-cc-and-rate-adaptation-in-motivation-section",
      "headRefOid": "4693f44ba8cd8982046d1b663a7b0268a1558868",
      "closedAt": "2023-10-23T14:42:44Z",
      "mergedAt": "2023-10-23T14:42:44Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "d468b6fe4a0977a651234104fd89afd30e706a80"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba, could you take a look at the changes I made in the terminology section about \"congestion control\" and \"rate adaptation\" term usage? I think what I said is accurate, but I'm also wondering what else we can do. ",
          "createdAt": "2023-10-20T17:21:20Z",
          "updatedAt": "2023-10-20T17:21:20Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Comments provided within the PR.\u00a0On Oct 20, 2023, at 10:21, Spencer Dawkins ***@***.***> wrote:\ufeff\r\n@aboba, could you take a look at the changes I made in the terminology section about \"congestion control\" and \"rate adaptation\" term usage? I think what I said is accurate, but I'm also wondering what else we can do.\r\n\r\n\u2014Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you were mentioned.Message ID: ***@***.***>",
          "createdAt": "2023-10-20T22:44:18Z",
          "updatedAt": "2023-10-20T22:44:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @mengelbart - I think you both had valuable comments on this text:\r\n\r\n> Taken as a whole,\r\n> \r\n> * RTP stream-level rate adaptation can give a better user experience than QUIC connection-level congestion control by minimizing packet loss,\r\n> * but QUIC connection-level congestion control can respond more quickly to the end of congestion than RTP \"circuit breakers\".\r\n\r\nJust to make sure my change is consistent, I'm checking with both of you about this proposed revision (now committed).\r\n\r\n> Taken as a whole,\r\n> \r\n> * **Timely** RTP stream-level rate adaptation **will** give a better user experience by minimizing **endpoint queuing delays and** packet loss,\r\n> * but **in the presence of packet loss**, QUIC connection-level congestion control **will** respond more quickly to the end of congestion than RTP \"circuit breakers\".",
          "createdAt": "2023-10-23T13:19:22Z",
          "updatedAt": "2023-10-23T13:54:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kycvn",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "aboba",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Since QUIC CC is always there, there's no real choice here. You might say that \"timely rate adaptation can minimize endpoint queuing delays and loss\". ",
          "createdAt": "2023-10-20T21:58:56Z",
          "updatedAt": "2023-10-20T21:58:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5k2jwY",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-23T08:51:16Z",
          "updatedAt": "2023-10-23T08:58:09Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> QUIC congestion avoidance procedures (for example, the procedures defined in {{?RFC9002}}) will cause the RTP packets to be buffered and only placed on the network path as part of a response to detected loss.\r\n\r\nI don't understand the sentence why would packets be placed on the network in response to detected loss? Is there a word/fragment of the sentence missing here?",
              "createdAt": "2023-10-23T08:51:16Z",
              "updatedAt": "2023-10-23T08:58:09Z"
            },
            {
              "originalPosition": 36,
              "body": "I suggest phrasing this as *QUIC connection-level congestion control __will__ respond more quickly* to emphasize that it is not a choice between the two and that QUIC congestion control is not optional.",
              "createdAt": "2023-10-23T08:53:57Z",
              "updatedAt": "2023-10-23T08:58:09Z"
            },
            {
              "originalPosition": 51,
              "body": "In #128 I removed the {{nested-CC}} section and merged it with the one before because they became very similar. I also removed the note about bufferbloat. Maybe we can directly include that here and remove the reference to the other section?",
              "createdAt": "2023-10-23T08:57:45Z",
              "updatedAt": "2023-10-23T08:58:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k4loS",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T13:29:37Z",
          "updatedAt": "2023-10-23T13:29:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "@mengelbart - you don't understand \r\n\r\n> I don't understand the sentence why would packets be placed on the network in response to detected loss? Is there a word/fragment of the sentence missing here?\r\n\r\nbecause it's wrong! This should have been something like \r\n\r\n> The result is that even if an RTP sender continues to \"send\", QUIC congestion avoidance procedures (for example, the procedures defined in {{?RFC9002}}) will cause the RTP packets to be buffered **while QUIC responds to detected packet loss**. This happens without RTP senders taking any action, **but the RTP sender has no control over this QUIC mechanism**. \r\n\r\nNow committed. ",
              "createdAt": "2023-10-23T13:29:37Z",
              "updatedAt": "2023-10-23T13:29:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k42e7",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T13:51:53Z",
          "updatedAt": "2023-10-23T13:51:53Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Hi, @mengelbart - that sounds good, but I'm not sure whether you wanted to fix this, or have me fix it. Since we have a conference call in 9 minutes, let's fix it exactly once!",
              "createdAt": "2023-10-23T13:51:53Z",
              "updatedAt": "2023-10-23T13:51:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 148,
      "id": "PR_kwDOFUmh7s5ezFGr",
      "title": "Update error codes starting from 0x00",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/148",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "@LPardue noticed we didn't assign 0x00 to any error code. I think it would be nice to have 0x00 as NO_ERROR. I also added the real codes to the error handling section.",
      "createdAt": "2023-11-07T12:06:30Z",
      "updatedAt": "2023-11-27T09:00:08Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ea21fe4b81de53ebdd1183d6fe8f3beaab7e5f92",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/error-codes",
      "headRefOid": "4b162adc06bfb60248f8d2ae1ddf5b5290f66e4c",
      "closedAt": "2023-11-27T09:00:07Z",
      "mergedAt": "2023-11-27T09:00:07Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d46cbffe37ae493130f63003b81727432f99df67"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5mZTWl",
          "commit": {
            "abbreviatedOid": "4b162ad"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "@LPurdue is a smart guy. That's a good thing to do. \r\n\r\nIt looks good to merge, to me!",
          "createdAt": "2023-11-07T14:54:34Z",
          "updatedAt": "2023-11-07T14:54:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5mayS2",
          "commit": {
            "abbreviatedOid": "4b162ad"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM :shipit: ",
          "createdAt": "2023-11-07T17:28:53Z",
          "updatedAt": "2023-11-07T17:28:53Z",
          "comments": []
        }
      ]
    }
  ]
}